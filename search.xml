<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试问答汇总]]></title>
    <url>%2Fblog%2F2019%2F11%2F09%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[图形学相关渲染管线顶点数据 =&gt; 顶点着色器 =&gt; 曲面细分 =&gt; 几何着色器 =&gt; 图元装配 =&gt; 裁剪剔除 =&gt; 光栅化 =&gt; 片元着色器 =&gt; 测试混合 Unity轻量级渲染管线又称通用渲染管线，区别于Unity内置渲染管线，仅保留很小的C++内核，暴露出更多的接口来支持C#脚本自定义渲染管线。特点为注重性能，单通道前向渲染，Shader Graph支持。而Unity内置渲染管线则更加通用而功能强大。 人物阴影渲染两个立方体之间的阴影渲染PBR主要参数以Unity标准材质为例： Albedo 反射率（漫反射） Metallic 金属度 specular 高光度（镜面反射） Smoothness 光滑度 Occlusion 环境光遮蔽贴图 Normal 法线贴图 Emission 自发光贴图 扩展链接：https://zhuanlan.zhihu.com/p/53086060 光栅化的几种方法线段扫描转换： 数字微分画线算法DDA Bresenham光栅化算法 多边形填充： 扫描线填充算法 引擎相关游戏引擎主要模块C#相关C++相关数据结构相关算法相关项目相关]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件工程思考题]]></title>
    <url>%2Fblog%2F2019%2F07%2F06%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%80%9D%E8%80%83%E9%A2%98%2F</url>
    <content type="text"><![CDATA[软件设计原则 论述一下“针对接口编程”的好处。 信息隐藏原则要求接口与实现分离，接口可以理解为一个类所提供的所有服务。实现就是类自身实现服务的方式。不必是因为没有必要知道内情就可以协作工作；不应是因为如果类的实现细节让客户知道，第一增加客户的负担，导致程序的可理解性降低；第二可能使客户的某些行为依赖于这些实现细节，导致若类内部实现发生变化，会迫使客户跟着变化。 信息隐藏非常重要的原因在于，它可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用、阅读及修改。 信息隐藏可以促进软件的复用，由于每个模块都不依赖于其他模块而存在，因此每个模块都可以独立地在其他的地方使用。 论述一下“优先使用对象组合”的好处。 若类B想获得类A的一些功能，不要首先想到让B去继承A，而是应当让B拥有A的一个对象。 这么做简明易用。B类对A类的其他方法与继承情况没兴趣，能使用所需的特定方法就成。 如果要继承，虽然也能使用特定方法，但不得不与整个继承体系紧紧地绑在一块了。 论述一下“抽象”与“软件的可重用性”的关系。 抽象化是一种使软件更具有一般性、灵活性、可理解性和可重用性的主要技术。 抽象化存在于多种不同的形式和层次中，是软件构思者与设计者的先行原则。 抽象化是任何重用技术的本质特征。但是，抽象化具有艰难的技巧性，并且是一个软件系统获得成功的主要障碍。 设计模式 对于某个模式，问“何种情形下会考虑使用此模式”？ 给出某种情形，问“采用何种模式比较适合？为什么？” 精确画出某个模式的结构图。 软件体系结构 软件体系结构的作用 软件体系结构是软件设计过程的一个阶段，它关心的是如何将复杂的软件系统划分为主/子系统、以及如何规范子系统的构成和性能。 一个外向目标：建立满足最终用户的系统需求； 一个内向目标：即那里满足后期设计者需要的、易于系统实现、维护和扩展的系统部件构成。 提高认识和理解体系结构，可以使系统的高层次关系的到全面表达和深刻理解； 获得正确的体系结构常常是软件系统设计成功的关键； 体系结构对于复杂系统的高层次性能分析至关重要； 熟练掌握体系结构的概念和描述，可以使软件设计者之间、设计者和用户之间快速方便地交流知识、经验； 在体系结构的全局思想指导下的系统维护、扩充和升级，不会因为修改和扩充而破坏整体的完整和一致性。 MVC模式 模型：模型用于管理应用程序域的行为和数据，并响应为获取其状态信息（通常来自视图）而发出的请求，还会响应更改状态的指令（通常来自控制器）。包含了应用问题核心数据、逻辑关系和计算功能。控制器依据输入/输出的需要调用这些操作，模型还为视图获取显示数据而提供了访问其数据的操作。 视图：视图用于管理信息的显示。以不同的表达形式显示模型的数据和状态。每个视图有一个更新操作，它们可以被变化-传播机制所激活。当视图的更新操作被调用时，它还会反过来获得来自模型的数据。 控制器：控制器用于解释用户的鼠标和键盘输入，以通知模型和或视图进行相应的更改。以事件触发的方式接收用户输入。控制器如何获得事件依赖于界面的运行平台。控制器通过事件处理过程对事件进行处理，并为每个输入事件提供了相应的操作服务，把事件转化成对模型或视图的激发操作。 用户输入导致模型变化，并触发变更-传递机制的过程： 控制器在事件处理中接受用户输入事件，解释事件，并激活模型的相应服务方法； 模型执行所请求的服务，导致其内部数据和状态的变化； 模型找到在其中注册了的视图和控制器，并调用它们的update()方法，对它们进行通知； 每个注册了视图从模型中读取已经改变的数据，并更新其在视图中的显示； 每个注册的控制器从模型中读取已经改变的数据，根据设定关系允许或者禁止某些功能。 C/S结构 应用框架 论述与其它软件复用技术的异同。 与类库的对比 相同点：都是可复用一组的类。 不同点： 类库中的一组类往往提供了一些软件的通用功能；而框架的这组类往往是针对某一个特定的应用领域。 类库中的那些类之间往往关系松散，很少存在相互协作的关系；而框架中的一组类一定是代表了一个整体结构，它们之间的协作非常紧密。 使用者使用类库时往往自己来定义程序的控制结构，自己去主动调用类库中的类方法；而框架使用者写的代码只能被框架调用。 如果说类库像一堆零散砖头，而框架则就接近建筑的半成品了。 与设计模式对比 相同点：都是软件复用的形式。 不同点： 设计模式是比框架更小的体系结构元素，一个框架包括了多个设计模式，而反之绝非如此。 设计模式比框架更抽象：框架能够用代码表示，能被直接执行和复用；而设计模式在每一次被复用时，都需要被实现，才能表示为代码。 框架比设计模式更加特例化：框架总是针对一个特定的应用领域；而设计模式几乎能被应用于任何领域。 论述一下“框架”与“模版方法模式”、“钩子方法”、“凝点”、“热点”等概念之间的联系。 从框架的复用机制来看，框架有三种类型：白盒、黑盒和灰盒三种，其中白盒和黑盒是两个极端，灰盒介于白盒、黑盒之间。 白盒框架包含一些抽象类（未完成的类），这些类中包含若干空方法，称之为钩子方法（Hook Methods）。框架应用者必须继承（Inheritance）这些未完成的类，并在子类中复写钩子方法，提供特定于具体需求的有意义的实现。所以白盒框架的热点机制是继承和钩子方法。 我们把某领域的程序族中反复出现的不变部分识别并“固化”到框架中，术语叫框架的“凝点”（Freeze Spots）。 另一种重要任务是要把程序族中可变部分识别出来，在框架中给它们留下一些“空位”（Placeholder），术语称之为框架的“热点”（Hot Spots）。这些空位是留给应用程序员填写的，以支持特殊应用的特殊需求。 凝点是框架提供了软件复用的根源，热点使软件复用成为可能。 软件重构 论述“软件重构”是如何与“软件设计”相互补充来解决过度设计问题的？ 设计阶段，人们总是预先仔细设计，力求得到一个灵活的解决方案，希望它能够承受所能预见的所有需求变化。 过度设计问题：灵活的解决方案比简单的解决方案要复杂得多，所需的成本很高，最终得到的软件通常也会更难以维护。如果在所有可能出现变化的地点都建立起灵活性，整个系统的复杂度和维护难度将很难估计。但是，你无法预测到底哪些灵活性派不上用场，为了获得自己想要的灵活性，你不得不加入比实际需要更多的灵活性。 有了重构，你就可以通过一条不同的途径来应付变化带来的风险。你仍旧需要思考潜在的需求变化，仍旧需要考虑灵活的解决方案。但是你不必再逐一实现这些解决方案，而是应该问问自己：“把一个简单的解决方案重构成这个灵活的方案有多大难度？”如果答案是“相当容易”，那么你就实现目前的简单方案就行了。 使用重构，你仍然坐预先设计，但是不必一定找到完美的解决方案，只需要得到一个足够合理的解决方案就够了。 论述重构技术的意义和作用。 重构的意义： 重构改进设计 重构使软件更容易理解 重构有助于找到bugs 重构有助于提高编程速度 需要重构的程序结构： 重复的代码 过长函数 过大的类 过长的参数列表 发散式变化 依恋情结 switch语句 面向组件的软件开发 描述一下“面向对象技术”的缺陷。 整体性的(Monolithic)：而不是有明显的组件构成。 封闭性的(Closed)：而不能再扩展。 私有性的(Proprietary)：而不能在用于第三方。 接口与实现的分离还不够彻底：类与子类的概念承担了太多的责任，用“类”来标示组件的接口，必然牵扯进很多实现方面的东西，使得“接口”与“实现”分割得不太彻底。 重代码复用，轻复合机制：在对象技术应用的早期，复用功能的技术主要使用“继承”机制，而缺乏将现有对象“复合”在一起以完成新功能的认识。 对象并不是天生为复用而设计的：被自然设计出来对象一般是私有性质的，不能被用在其它项目中。其根源在于：对象的接口机制只能保证其信息的单向对外隐藏，使得其客户不知实现细节；但是对象的实现却对其外部环境做了很多假设，即对象的外部环境对对象的实现没有进行信息隐藏，这导致此对象不能适应其它的运行环境。 软件组件都有哪些特性？ 更严格的接口与实现分离： 没有任何暴露在外的实现细节。 只要保持组件的接口不变，组件的内部实现可以自由替换，而客户不受影响。 有些组件甚至更进一步，具有“pluggable”实现，即组件实际工作的代码可以在软件运行时动态确定，主要技术手段是通过组件的配置设置。 明确的环境依赖、反向控制： 组件不能对它使用的外在的运行环境做出过多的假设。一个反例是，组件需要某种服务，但它以实现类型保存着实现此种服务的对象。如果组件的运行必须得到外界环境的服务，这种对环境的依赖性必须明确化。 为了避免对环境的依赖，有些组件被设计成不直接与环境打交道，而是通过“反向控制模式”，即：组件的容器(Container)负责打理组件运行所需的一切，组件处于被动状态：被请求时才运作。这也叫“好莱坞原则”。 内省、可视化编辑： 组件一般会提供一种机制，可以让外界在一定范围内配置其功能。而对象则绝没有这种能力。通常这种机制是通过可视化图形配置工具来提供的。 组件是如何做到对外信息隐藏的？ 更严格的接口与实现分离 明确的环境依赖、反向控制]]></content>
  </entry>
  <entry>
    <title><![CDATA[Improving Level Design Through Game User Research 论文笔记]]></title>
    <url>%2Fblog%2F2019%2F04%2F10%2FImproving-Level-Design-Through-GUR-a-Comparison-of-Methodologies%2F</url>
    <content type="text"><![CDATA[Abstract User interviews, game metrics, psychophysiology Based on the results we conclude that user interviews provide the clearest indications for improvement among the considered methodologies while metrics and biometrics add different types of information that cannot be obtained otherwise. Three Methodologies Participant interviews with player observation by researchers. Players were interviewed for about ten minutes, using a standardized script. They also filled out a 50 item questionnaire. Data collection through metrics; the game was modified to log data about user behavior and user-game interaction. We logged a large number of events such as all types of movements, attacks (including attacker and target), collection of bonus items, upgrades, downgrades and game deaths, and each single key press made by the participant. Data collection through biometrics; this data was gathered from the play tester by using sensors to monitor heart rate, skin conductivity and the activity of the two facial muscles, the zygomaticus major and the corrugator supercillii. Phase 1: Preparation of the Benchmark Levels This phase was intended to set a benchmark, to define a point at which professional designers would release their work for internal quality assurance. Phase 2: GUR Data Collection General level ratings: each player had to rate the level they had played in terms of fun, length and difficulty using a 5-point Likert scale. Interview data: Open-ended, semi-structured interviews with players were held at the end of each level. Game metric data: This allowed for periodic tracking of the player position as well as relevant game events, such as defeating enemies, jumps, collecting bonus items, etc. Biometric data: All participants were monitored with several biometric sensors during the test sessions. Phase 3: Data Evaluation and Visualization Interview GUR data:remove irrelevant information, classified as actionable changes and non-essential changes. Metric data: Apart from acquiring play statistics for each participant, the logs were used to create heatmaps. Biometric data: For the evaluation of biometric data, each level was divided into 12 equally long sections. Phase 4: Modifications Each level was modified based on the data collected in phase 3 according to the three different pair-wise combinations of methodologies. These were: interviews and game metrics; interviews and biometrics; game metrics and biometrics. For each combination of methodologies, a total of six changes were implemented across the three levels. Phase 5: Evaluation of Modifications Players were asked to complete the Game Experience Questionnaire (GEQ), a tool that is commonly used in the GUR field to quickly analyze player experience. A total of 40 participants (22 of which were female) in ages ranging from 15 to 27 years (median age of 23 years)took part in this second data collection session. Players played one version of the modified level-sets, consisting of three levels. Results On the whole, the differences between the combined methodologies were much smaller than we expected. A consistent pattern can be seen across the variables Positive Affect, Flow, Positive Experience, and Competence: The levels modified by `interview &amp; metrics’ were rated most positively. three dimensions had statistically significant differences between the groups: Positive Experience (p=.008, F=5.595), Competence (p=.04, F=3.530), and Positive Affect (p=.048, F=3.290). the significant differences within those dimensions are found between the pairings “interview &amp; metrics” and “biometrics &amp; metrics” for the dimensions Competence (p=.03) and Positive Affect (p=.038), and between the pairings “interview &amp; metrics” and “interview &amp; biometrics” for the dimension Positive Experience (p=.008). there could be a Type II error as the ANOVA analysis was significant for only a few GEQ dimensions. From the point of view of a level designer, each pair of GUR methodologies was able to provide actionable indications regarding locations or situations that should be modified to improve player satisfaction. Deficiency 第二次组织试玩没有测试metrics和biometrics数据验证。 关卡的修改比较主观，没有说明与数据的对应关系。 样板数量过小]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity构造单例模式]]></title>
    <url>%2Fblog%2F2019%2F04%2F09%2FUnity%E6%9E%84%E9%80%A0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[public class GameManager : MonoBehaviour&#123; public static GameManager instance; private void Awake() &#123; //singleton pattern if (!instance) &#123; instance = this; &#125; else if (instance != this) &#123; DestroyImmediate(this); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LearnOpenGL练习]]></title>
    <url>%2Fblog%2F2019%2F03%2F12%2FLearnOpenGL%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[你好，三角形添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形#include "pch.h"#include &lt;iostream&gt;#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;// Function prototypesvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);// Window dimensionsconst GLuint WIDTH = 800, HEIGHT = 600;// Shadersconst GLchar* vertexShaderSource = "#version 330 core\n""layout (location = 0) in vec3 position;\n""void main()\n""&#123;\n""gl_Position = vec4(position.x, position.y, position.z, 1.0);\n""&#125;\0";const GLchar* fragmentShaderSource = "#version 330 core\n""out vec4 color;\n""void main()\n""&#123;\n""color = vec4(1.0f, 0.7f, 0.3f, 0.8f);\n""&#125;\n\0";// The MAIN function, from here we start the application and run the game loopint main()&#123; std::cout &lt;&lt; "Starting GLFW context, OpenGL 3.3" &lt;&lt; std::endl; // Init GLFW glfwInit(); // Set all the required options for GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Create a GLFWwindow object that we can use for GLFW's functions GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr); glfwMakeContextCurrent(window); // Set the required callback functions glfwSetKeyCallback(window, key_callback); // Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions glewExperimental = GL_TRUE; // Initialize GLEW to setup the OpenGL Function pointers glewInit(); // Define the viewport dimensions int width, height; glfwGetFramebufferSize(window, &amp;width, &amp;height); glViewport(0, 0, width, height); // Build and compile our shader program // Vertex shader GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); // Check for compile time errors GLint success; GLchar infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Fragment shader GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); // Check for compile time errors glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Link shaders GLuint shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); // Check for linking errors glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; glDeleteShader(vertexShader); glDeleteShader(fragmentShader); // Set up vertex data (and buffer(s)) and attribute pointers //GLfloat vertices[] = &#123; // // First triangle // 0.5f, 0.5f, // Top Right // 0.5f, -0.5f, // Bottom Right // -0.5f, 0.5f, // Top Left // // Second triangle // 0.5f, -0.5f, // Bottom Right // -0.5f, -0.5f, // Bottom Left // -0.5f, 0.5f // Top Left //&#125;; GLfloat vertices[] = &#123; 0.5f, 0.5f, 0.0f, // Top Right 0.5f, -0.5f, 0.0f, // Bottom Right -0.5f, -0.5f, 0.0f, // Bottom Left -0.5f, 0.5f, 0.0f // Top Left &#125;; GLuint indices[] = &#123; // Note that we start from 0! 0, 1, 3, // First Triangle 1, 2, 3 // Second Triangle &#125;; GLuint VBO, VAO, EBO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); // Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s). glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); // Note that this is allowed, the call to glVertexAttribPointer registered VBO as the currently bound vertex buffer object so afterwards we can safely unbind glBindVertexArray(0); // Unbind VAO (it's always a good thing to unbind any buffer/array to prevent strange bugs), remember: do NOT unbind the EBO, keep it bound to this VAO // Uncommenting this call will result in wireframe polygons. glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); // Game loop while (!glfwWindowShouldClose(window)) &#123; // Check if any events have been activiated (key pressed, mouse moved etc.) and call corresponding response functions glfwPollEvents(); // Render // Clear the colorbuffer glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // Draw our first triangle glUseProgram(shaderProgram); glBindVertexArray(VAO); //glDrawArrays(GL_TRIANGLES, 0, 6); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0); // Swap the screen buffers glfwSwapBuffers(window); &#125; // Properly de-allocate all resources once they've outlived their purpose glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glDeleteBuffers(1, &amp;EBO); // Terminate GLFW, clearing any resources allocated by GLFW. glfwTerminate(); return 0;&#125;// Is called whenever a key is pressed/released via GLFWvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE);&#125; 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO#include "pch.h"#include &lt;iostream&gt;#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;// Function prototypesvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);// Window dimensionsconst GLuint WIDTH = 800, HEIGHT = 600;// Shadersconst GLchar* vertexShaderSource = "#version 330 core\n""layout (location = 0) in vec3 position;\n""void main()\n""&#123;\n""gl_Position = vec4(position.x, position.y, position.z, 1.0);\n""&#125;\0";const GLchar* fragmentShaderSource = "#version 330 core\n""out vec4 color;\n""void main()\n""&#123;\n""color = vec4(1.0f, 0.7f, 0.3f, 0.8f);\n""&#125;\n\0";// The MAIN function, from here we start the application and run the game loopint main()&#123; std::cout &lt;&lt; "Starting GLFW context, OpenGL 3.3" &lt;&lt; std::endl; // Init GLFW glfwInit(); // Set all the required options for GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Create a GLFWwindow object that we can use for GLFW's functions GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr); glfwMakeContextCurrent(window); // Set the required callback functions glfwSetKeyCallback(window, key_callback); // Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions glewExperimental = GL_TRUE; // Initialize GLEW to setup the OpenGL Function pointers glewInit(); // Define the viewport dimensions int width, height; glfwGetFramebufferSize(window, &amp;width, &amp;height); glViewport(0, 0, width, height); // Build and compile our shader program // Vertex shader GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); // Check for compile time errors GLint success; GLchar infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Fragment shader GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); // Check for compile time errors glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Link shaders GLuint shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); // Check for linking errors glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; glDeleteShader(vertexShader); glDeleteShader(fragmentShader); // Set up vertex data (and buffer(s)) and attribute pointers GLfloat rect0[] = &#123; 0.5f, 0.5f, 0.0f, // Top Right 0.5f, -0.5f, 0.0f, // Bottom Right -0.5f, -0.5f, 0.0f, // Bottom Left -0.5f, 0.5f, 0.0f // Top Left &#125;; GLfloat rect1[] = &#123; 1.0f, 0.0f, 0.0f, // Top Right 1.0f, -1.0f, 0.0f, // Bottom Right 0.5f, -1.0f, 0.0f, // Bottom Left 0.5f, 0.0f, 0.0f // Top Left &#125;; GLuint indices0[] = &#123; // Note that we start from 0! 0, 1, 3, // First Triangle 1, 2, 3 // Second Triangle &#125;; GLuint indices1[] = &#123; // Note that we start from 0! 0, 1, 3, // First Triangle 1, 2, 3 // Second Triangle &#125;; GLuint VBO[2], VAO[2], EBO[2]; glGenVertexArrays(2, VAO); glGenBuffers(2, VBO); glGenBuffers(2, EBO); // Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s). glBindVertexArray(VAO[0]); glBindBuffer(GL_ARRAY_BUFFER, VBO[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(rect0), rect0, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO[0]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices0), indices0, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); // Note that this is allowed, the call to glVertexAttribPointer registered VBO as the currently bound vertex buffer object so afterwards we can safely unbind glBindVertexArray(0); // Unbind VAO (it's always a good thing to unbind any buffer/array to prevent strange bugs), remember: do NOT unbind the EBO, keep it bound to this VAO glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s). glBindVertexArray(VAO[1]); glBindBuffer(GL_ARRAY_BUFFER, VBO[1]); glBufferData(GL_ARRAY_BUFFER, sizeof(rect1), rect1, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO[1]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices1), indices1, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); // Note that this is allowed, the call to glVertexAttribPointer registered VBO as the currently bound vertex buffer object so afterwards we can safely unbind glBindVertexArray(0); // Unbind VAO (it's always a good thing to unbind any buffer/array to prevent strange bugs), remember: do NOT unbind the EBO, keep it bound to this VAO glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // Uncommenting this call will result in wireframe polygons. glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // Game loop while (!glfwWindowShouldClose(window)) &#123; // Check if any events have been activiated (key pressed, mouse moved etc.) and call corresponding response functions glfwPollEvents(); // Render // Clear the colorbuffer glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // Draw our first triangle glUseProgram(shaderProgram); glBindVertexArray(VAO[0]); //glDrawArrays(GL_TRIANGLES, 0, 6); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(VAO[1]); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0); // Swap the screen buffers glfwSwapBuffers(window); &#125; // Properly de-allocate all resources once they've outlived their purpose glDeleteVertexArrays(2, VAO); glDeleteBuffers(2, VBO); glDeleteBuffers(2, EBO); // Terminate GLFW, clearing any resources allocated by GLFW. glfwTerminate(); return 0;&#125;// Is called whenever a key is pressed/released via GLFWvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE);&#125; 创建两个着色器程序，第二个程序使用与第一个不同的片段着色器，输出黄色；再次绘制这两个三角形，其中一个输出为黄色#include "pch.h"#include &lt;iostream&gt;#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;// Function prototypesvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);// Window dimensionsconst GLuint WIDTH = 800, HEIGHT = 600;// Shadersconst GLchar* vertexShaderSource = "#version 330 core\n""layout (location = 0) in vec3 position;\n""void main()\n""&#123;\n""gl_Position = vec4(position.x, position.y, position.z, 1.0);\n""&#125;\0";const GLchar* fragmentShaderSourceY = "#version 330 core\n""out vec4 color;\n""void main()\n""&#123;\n""color = vec4(1.0f, 0.7f, 0.3f, 0.8f);\n""&#125;\n\0";const GLchar* fragmentShaderSourceG = "#version 330 core\n""out vec4 color;\n""void main()\n""&#123;\n""color = vec4(0.2f, 0.8f, 0.6f, 0.8f);\n""&#125;\n\0";// The MAIN function, from here we start the application and run the game loopint main()&#123; std::cout &lt;&lt; "Starting GLFW context, OpenGL 3.3" &lt;&lt; std::endl; // Init GLFW glfwInit(); // Set all the required options for GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Create a GLFWwindow object that we can use for GLFW's functions GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr); glfwMakeContextCurrent(window); // Set the required callback functions glfwSetKeyCallback(window, key_callback); // Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions glewExperimental = GL_TRUE; // Initialize GLEW to setup the OpenGL Function pointers glewInit(); // Define the viewport dimensions int width, height; glfwGetFramebufferSize(window, &amp;width, &amp;height); glViewport(0, 0, width, height); // Build and compile our shader program // Vertex shader GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); // Check for compile time errors GLint success; GLchar infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Fragment shader Y GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSourceY, NULL); glCompileShader(fragmentShader); // Check for compile time errors glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Link shaders Y GLuint shaderProgramY = glCreateProgram(); glAttachShader(shaderProgramY, vertexShader); glAttachShader(shaderProgramY, fragmentShader); glLinkProgram(shaderProgramY); // Check for linking errors glGetProgramiv(shaderProgramY, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgramY, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Fragment shader G fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSourceG, NULL); glCompileShader(fragmentShader); // Check for compile time errors glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Link shaders G GLuint shaderProgramG = glCreateProgram(); glAttachShader(shaderProgramG, vertexShader); glAttachShader(shaderProgramG, fragmentShader); glLinkProgram(shaderProgramG); // Check for linking errors glGetProgramiv(shaderProgramG, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgramG, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; glDeleteShader(vertexShader); glDeleteShader(fragmentShader); // Set up vertex data (and buffer(s)) and attribute pointers GLfloat rect0[] = &#123; 0.5f, 0.5f, 0.0f, // Top Right 0.5f, -0.5f, 0.0f, // Bottom Right -0.5f, -0.5f, 0.0f, // Bottom Left -0.5f, 0.5f, 0.0f // Top Left &#125;; GLfloat rect1[] = &#123; 1.0f, 0.0f, 0.0f, // Top Right 1.0f, -1.0f, 0.0f, // Bottom Right 0.5f, -1.0f, 0.0f, // Bottom Left 0.5f, 0.0f, 0.0f // Top Left &#125;; GLuint indices0[] = &#123; // Note that we start from 0! 0, 1, 3, // First Triangle 1, 2, 3 // Second Triangle &#125;; GLuint indices1[] = &#123; // Note that we start from 0! 0, 1, 3, // First Triangle 1, 2, 3 // Second Triangle &#125;; GLuint VBO[2], VAO[2], EBO[2]; glGenVertexArrays(2, VAO); glGenBuffers(2, VBO); glGenBuffers(2, EBO); // Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s). glBindVertexArray(VAO[0]); glBindBuffer(GL_ARRAY_BUFFER, VBO[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(rect0), rect0, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO[0]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices0), indices0, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); // Note that this is allowed, the call to glVertexAttribPointer registered VBO as the currently bound vertex buffer object so afterwards we can safely unbind glBindVertexArray(0); // Unbind VAO (it's always a good thing to unbind any buffer/array to prevent strange bugs), remember: do NOT unbind the EBO, keep it bound to this VAO glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s). glBindVertexArray(VAO[1]); glBindBuffer(GL_ARRAY_BUFFER, VBO[1]); glBufferData(GL_ARRAY_BUFFER, sizeof(rect1), rect1, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO[1]); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices1), indices1, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); // Note that this is allowed, the call to glVertexAttribPointer registered VBO as the currently bound vertex buffer object so afterwards we can safely unbind glBindVertexArray(0); // Unbind VAO (it's always a good thing to unbind any buffer/array to prevent strange bugs), remember: do NOT unbind the EBO, keep it bound to this VAO glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); // Uncommenting this call will result in wireframe polygons. glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); // Game loop while (!glfwWindowShouldClose(window)) &#123; // Check if any events have been activiated (key pressed, mouse moved etc.) and call corresponding response functions glfwPollEvents(); // Render // Clear the colorbuffer glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // Draw our first rect glUseProgram(shaderProgramY); glBindVertexArray(VAO[0]); //glDrawArrays(GL_TRIANGLES, 0, 6); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // Draw our second rect glUseProgram(shaderProgramG); glBindVertexArray(VAO[1]); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0); // Swap the screen buffers glfwSwapBuffers(window); &#125; // Properly de-allocate all resources once they've outlived their purpose glDeleteVertexArrays(2, VAO); glDeleteBuffers(2, VBO); glDeleteBuffers(2, EBO); // Terminate GLFW, clearing any resources allocated by GLFW. glfwTerminate(); return 0;&#125;// Is called whenever a key is pressed/released via GLFWvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE);&#125; 着色器使用uniform定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧xOffsetShader.cpp #include "pch.h"#include &lt;iostream&gt;#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;// Other includes#include "Shader.h"// Function prototypesvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);// Window dimensionsconst GLuint WIDTH = 800, HEIGHT = 600;// The MAIN function, from here we start the application and run the game loopint main()&#123; // Init GLFW glfwInit(); // Set all the required options for GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Create a GLFWwindow object that we can use for GLFW's functions GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr); glfwMakeContextCurrent(window); // Set the required callback functions glfwSetKeyCallback(window, key_callback); // Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions glewExperimental = GL_TRUE; // Initialize GLEW to setup the OpenGL Function pointers glewInit(); // Define the viewport dimensions glViewport(0, 0, WIDTH, HEIGHT); // Build and compile our shader program Shader ourShader("../shaders/xOffset.vs", "../shaders/default.frag"); // Set up vertex data (and buffer(s)) and attribute pointers GLfloat vertices[] = &#123; // Positions // Colors 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // Bottom Right -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // Bottom Left 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // Top &#125;; GLuint VBO, VAO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); // Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s). glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // Position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0); glEnableVertexAttribArray(0); // Color attribute glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat))); glEnableVertexAttribArray(1); glBindVertexArray(0); // Unbind VAO float xOffset = 0; // Game loop while (!glfwWindowShouldClose(window)) &#123; // Check if any events have been activiated (key pressed, mouse moved etc.) and call corresponding response functions glfwPollEvents(); // Render // Clear the colorbuffer glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); xOffset += 0.0001; ourShader.SetUniformFloat("xOffset", xOffset); // Draw the triangle ourShader.Use(); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glBindVertexArray(0); // Swap the screen buffers glfwSwapBuffers(window); &#125; // Properly de-allocate all resources once they've outlived their purpose glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); // Terminate GLFW, clearing any resources allocated by GLFW. glfwTerminate(); return 0;&#125;// Is called whenever a key is pressed/released via GLFWvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE);&#125; xOffset.vs #version 330 corelayout (location = 0) in vec3 position;layout (location = 1) in vec3 color;out vec3 ourColor;uniform float xOffset;void main()&#123; gl_Position = vec4(position.x + xOffset, position.yz, 1.0f); ourColor = color;&#125; default.frag #version 330 corein vec3 ourColor;out vec4 color;void main()&#123; color = vec4(ourColor, 1.0f);&#125; shader.h #ifndef SHADER_H#define SHADER_H#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;GL/glew.h&gt;class Shader&#123;public: GLuint Program; // Constructor generates the shader on the fly Shader(const GLchar* vertexPath, const GLchar* fragmentPath) &#123; // 1. Retrieve the vertex/fragment source code from filePath std::string vertexCode; std::string fragmentCode; std::ifstream vShaderFile; std::ifstream fShaderFile; // ensures ifstream objects can throw exceptions: vShaderFile.exceptions(std::ifstream::badbit); fShaderFile.exceptions(std::ifstream::badbit); try &#123; // Open files vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // Read file's buffer contents into streams vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); // close file handlers vShaderFile.close(); fShaderFile.close(); // Convert stream into string vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); &#125; catch (std::ifstream::failure e) &#123; std::cout &lt;&lt; "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" &lt;&lt; std::endl; &#125; const GLchar* vShaderCode = vertexCode.c_str(); const GLchar * fShaderCode = fragmentCode.c_str(); // 2. Compile shaders GLuint vertex, fragment; GLint success; GLchar infoLog[512]; // Vertex Shader vertex = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertex, 1, &amp;vShaderCode, NULL); glCompileShader(vertex); // Print compile errors if any glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertex, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Fragment Shader fragment = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragment, 1, &amp;fShaderCode, NULL); glCompileShader(fragment); // Print compile errors if any glGetShaderiv(fragment, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragment, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Shader Program this-&gt;Program = glCreateProgram(); glAttachShader(this-&gt;Program, vertex); glAttachShader(this-&gt;Program, fragment); glLinkProgram(this-&gt;Program); // Print linking errors if any glGetProgramiv(this-&gt;Program, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(this-&gt;Program, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // Delete the shaders as they're linked into our program now and no longer necessery glDeleteShader(vertex); glDeleteShader(fragment); &#125; // Uses the current shader void Use() &#123; glUseProgram(this-&gt;Program); &#125; void SetUniformFloat(const char* name, float value) &#123; GLint uniformLocation = glGetUniformLocation(Program, name); glUseProgram(Program); glUniform1f(uniformLocation, value); &#125;&#125;;#endif]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法练习]]></title>
    <url>%2Fblog%2F2019%2F03%2F11%2FLeetCode%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Two SumApproach 1: Brute Forceclass Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result; for(int i = 0 ; i &lt; nums.size() ; i++) &#123; for (int j = i + 1 ; j &lt; nums.size() ; j++) &#123; if(nums[i] + nums[j] == target) &#123; result = &#123;i, j&#125;; &#125; &#125; &#125; return result; throw "No solution"; &#125;&#125;; $$T(n)=O(n^2)\S(n)=O(1)$$ Approach 2: One-pass Hash Tableclass Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result; map&lt;int, int&gt; hash; for(int i = 0; i &lt; nums.size(); i++) &#123; int complement = target - nums[i]; if(hash.count(complement)) &#123; result = &#123;hash[complement], i&#125;; return result; &#125; hash[nums[i]] = i; &#125; throw "No solution"; &#125;&#125;; $$T(n)=O(n) \ S(n)=O(n)$$ Runtime: 12 ms, faster than 94.28% of C++ online submissions for Two Sum. Memory Usage: 10.4 MB, less than 32.76% of C++ online submissions for Two Sum. Add Two NumbersApproach 1: Elementary Math/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* result = new ListNode(0); ListNode* head = result; while(l1 || l2) &#123; if(l1) &#123; result-&gt;val += l1-&gt;val; l1 = l1-&gt;next; &#125; if(l2) &#123; result-&gt;val += l2-&gt;val; l2 = l2-&gt;next; &#125; if(result-&gt;val &gt; 9) &#123; result-&gt;val = result-&gt;val % 10; result-&gt;next = new ListNode(1); &#125; else &#123; if(l1 || l2) &#123; result-&gt;next = new ListNode(0); &#125; &#125; result = result-&gt;next; &#125; return head; &#125;&#125;; $$T(n)=O(max(m, n)) \ S(n)=O(max(m, n))$$ Runtime: 40 ms, faster than 96.35% of C++ online submissions for Add Two Numbers. Memory Usage: 19.1 MB, less than 61.79% of C++ online submissions for Add Two Numbers. Longest Substring Without Repeating CharactersApproach 1: Sliding Windowclass Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int maxLength = 0; int lastStart = 0; map&lt;char, int&gt; charIndex; for(int i = 0; i &lt; s.size(); i++) &#123; if(charIndex.count(s[i]) &amp;&amp; charIndex[s[i]] &gt;= lastStart) &#123; lastStart = charIndex[s[i]] + 1; &#125; if(maxLength &lt; i - lastStart + 1) &#123; maxLength = i - lastStart + 1; &#125; charIndex[s[i]] = i; &#125; return maxLength; &#125;&#125;; $$T(n)=O(n) \ S(n)=O(min(m, n))$$ Runtime: 36 ms, faster than 49.65% of C++ online submissions for Longest Substring Without Repeating Characters. Memory Usage: 16.1 MB, less than 60.63% of C++ online submissions for Longest Substring Without Repeating Characters. Approach 2: Brute Forceclass Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int maxLength = 0; set&lt;char&gt; substring; for(int i = 0; i &lt; s.size(); i++) &#123; for(int j = i; j &lt; s.size() &amp;&amp; !substring.count(s[j]); j++) &#123; substring.insert(s[j]); &#125; if(maxLength &lt; substring.size()) &#123; maxLength = substring.size(); &#125; substring.clear(); &#125; return maxLength; &#125;&#125;; $$T(n)=O(n^2) \ S(n)=O(min(m, n))$$ Runtime: 1148 ms, faster than 5.14% of C++ online submissions for Longest Substring Without Repeating Characters. Memory Usage: 272 MB, less than 5.03% of C++ online submissions for Longest Substring Without Repeating Characters.]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019腾讯游戏开发工程师笔试题]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2F2019%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题 第二题 第三题 第四题 第五题]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人歌词集（2010-2013）]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2F%E4%B8%AA%E4%BA%BA%E6%AD%8C%E8%AF%8D%E9%9B%86%EF%BC%882010-2013%EF%BC%89%2F</url>
    <content type="text"><![CDATA[向日葵盛开的夏天 校门外的老树前­ 操场旁边的林荫间­ 你坐在我旁边­ 看我描点­ 连成一条抛物线­ 风在空中拉着线­ 阳光洒满清澈的弦­ 你我面前­ 天空好远­ 找不到最高点­ （一天天、一天天、一年年、一年年、一个又一个的夏天、风吹过的校园、斑驳的树影间、操场的阳光前、我在你旁边、看你抬头望着天、那么多值得珍藏的画面、都变成电影里磨损无声的胶片、怎么也、看不清了从前、而我呢、依然、奔跑在这校园、顺着空气想念、刻画下我们曾经的笑脸、书写着我们永恒的怀恋、向日葵盛开的夏天、在风中不变、在阳光下永远、永远不变、记忆里、半透明了夏天、­） 你说你还记得那个夏天 向日葵开遍 阳光下的荒原­ 你说你深爱着那个夏天 坚定的侧脸­ 夏天从未改变­ 向日葵盛开的夏天­ 我们在山坡上一起许愿­ 面对天边­ 沿着视线­ 你说你看不见­ 未来多遥远­ 向日葵盛开的夏天­ 我们和向日葵(肩并着肩)一起默念­ 面向阳光­ 背对忧伤­ 你说我们都一样(我们都一样)­ 面朝希望­ 不曾绝望 （印象中的向日葵是阳光下大片的金色海洋、其中、每一株向日葵都是一个原点、点动成线、线动成面、一株株肩并着肩、一排排汇聚视线、焦点指向天边、阴影抛给地面、整齐地心连着心然后连成一片、嗯、面向阳光、就拥有了阳光般明媚的笑脸、背对忧伤、就瞬间找回了倔强的坚强、阳光、倔强、倔强的阳光、阳光的倔强、就在那个夏天、向日葵盛开的夏天、你说了不变、­） 你说你还记得那个夏天(细腻的风揉进葱绿的夏天)­ 向日葵开遍(向日葵)­ 阳光下的荒原(哼唱着阳光陪着你入眠)­ 你说你深爱着那个夏天(被时光碾碎迷醉的夏天)­ 坚定的侧脸(你单纯的侧脸)­ 夏天从未改变(嗯、不会改变)­ 向日葵盛开的夏天­ 我们在山坡上一起许愿­ 面对天边­ 沿着视线­ 你说你看不见­ 未来多遥远­ 向日葵盛开的夏天­ 我们和向日葵(肩并着肩)一起默念­ 面向阳光­ 背对忧伤­ 你说我们都一样(我们都一样)­ 向日葵盛开的夏天­ 我们在山坡上一起许愿­ 面对天边­ 沿着视线­ 你说你看不见­ 未来多遥远­ 向日葵盛开的夏天­ 我们和向日葵(肩并着肩)一起默念­ 面向阳光­ 背对忧伤­ 你说我们都一样(我们都一样)­ 面朝希望­ 不曾绝望 （一天天、一天天、一年年、一年年、一个又一个的夏天、）­ 向日葵盛开的夏天­ （你说过的、不变）­ 夏天的边缘 你试着走过­ 一整个夏天­ 不知不觉错过 走到了边缘 多么想回到起点 可惜早已找不见 你倔强地抬头看天 阳光满脸 却那么遥远 你在窗台摇风铃 风也变得很安静 你很用心 画下几笔 浓绿的树影 你说害怕记不清 夏天里走过的风景 你的眼睛 我看不清 是阴还是晴 明媚阳光你不敢猜 晴朗天空晕不开 雨下过后才慢慢明白 你的等待 只是无奈 梦在绿荫下面徘徊 迷路的风回不来 枯叶散落在雨后的街 一片一片被时间瓦解 我在树下印脚印 你在一旁看风景 你很安静 冲淡表情 陪我等天晴 我说总是喜欢听 夏天里雨滴的声音 走走停停 穿过密林 树叶却落尽 明媚阳光你不敢猜（不敢猜） 晴朗天空晕不开（晕不开） 雨下过后才慢慢明白（我慢慢明白） 你的等待（我的） 只是无奈（无奈） 梦在绿荫下面徘徊（梦不再） 迷路的风回不来（逃不开） 枯叶散落在雨后的街（淋湿的街） 一片一片被时间瓦解 哒哒啦哒 哒哒啦哒 哒哒啦哒 哒哒哒 哒哒啦哒 哒哒啦哒 哒哒啦哒 哒哒哒 哒哒啦哒 哒哒啦哒 哒哒啦哒 哒哒哒 哒哒啦哒 哒哒啦哒 哒哒啦哒 哒哒哒 你说已经 不再期待 不再期待 他回来 屋顶阴霾 却无法散开 我的等待 只剩等待 梦在绿荫下面徘徊（哒哒啦哒 哒哒啦哒） 迷路的风回不来（哒哒啦哒 哒哒哒） 枯叶散落在雨后的街 一片一片用泪水书写 痛觉 你没离开 你不释怀 你站在、夏天的边缘 独自走在、夏天的边缘 不快乐 刚冲的咖啡凉了 窗外的灯全灭了 你还在桌前坐着 想熬到天都亮了 你给我打电话了 你说你不想说话 我听着你沉默着 我心里泛起苦涩 你懂得、没有人完全快乐 我说了这句、忍不住挂了 我懂得、你只是想找人诉说 我有些后悔、我太狠心了 你不快乐 我以为你懂得 没有人能够轻易代替你快乐 不知道该如何抉择 情绪总是莫名的 你总是把伤痛都清楚记得 你不快乐 我想你不值得 不值得因为挫折而放弃快乐 生命里那么多曲折 为什么不笑着呢 你可以抛开一切更快乐的 刚冲的咖啡凉了 窗外的灯全灭了 你还在桌前坐着 想熬到天都亮了 你给我打电话了 你说你不想说话 我听着你沉默着 我心里泛起苦涩 你懂得、没有人完全快乐 我说了这句、忍不住挂了 我懂得、你只是想找人诉说 我有些后悔、我太狠心了 你不快乐 我以为你懂得 没有人能够轻易代替你快乐 不知道该如何抉择 情绪总是莫名的 你总是把伤痛都清楚记得 你不快乐 我想你不值得 不值得因为挫折而放弃快乐 生命里那么多曲折 为什么不笑着呢 你可以抛开一切更快乐的 你可以抛开一切更快乐的 你可以抛开一切、努力幸福着 原来的我 淡蓝色天空把阳光染成透明色 我抱着吉他回想起纸飞机的快乐 不知你是否还记得 书本上青春的颜色 那时的我说我会变得优秀而独特 屋檐下的雨天我那时总是幻想着 一个人的大街我偶尔随风狂奔着 是否我注定追逐着 画面里纷飞的失落 有一些梦多么不舍得失去了轮廓 我说 原来的我 不拥有太多 有更多莫名的快乐 你说 现在的我 总偷偷沉默 傻傻地伪装起落寞 我说 原来的我 不会想太多 一天天随性地生活 你说 现在的我 没从前洒脱 习惯了流浪中奔波 遗失了太多 我的吉他 我从高一开始学吉他 妈妈说要学就要学好他 我试着弹呐弹呐弹几下 手指头疼呐疼呐都不怕 我从高二试着编吉他 只是功夫太差没办法 我只能练啊练啊烦死啦 干脆就扔到一边不管啦 我的吉他 你陪我度过作业的轰炸 我的吉他 抱着你快乐就开始喧哗 我的吉他你总是躲在墙角不说话 我爱你啊我可爱的小小小小小吉他 （蹦吧啦蹦吧啦蹦吧啦） 我上高三放下了吉他 为学习我不得不收起他 等灰尘落满落满他肩膀 我忽然明白他也老了吧 我的吉他你带我回到儿时夕阳下 我的吉他有了你梦想拼命在挣扎 我的吉他孤单时只有你陪我说话 我爱你啊我孤独的呆呆傻傻木吉他 现在我还是爱弹吉他 只是技术依旧烂到家 不管它前路风吹又雨打 我有你什么统统都不怕 我的吉他 你给我自由勇气和一个家 我的吉他有了你全世界都开满花 我的吉他你总是替我说出心里话 我爱你啊你爱我你是我的好吉他 关于青春 今天，昨天已经远离 晴天，阴天还在待续 每天，都怀念着过去 某天，日记里某一句 关于青春能说的太多 还记得那天我们手牵手 阳光洒落你身后 突然感觉好温柔 还以为就能这样到尽头 那树荫后那栋教学楼 你打开窗子冲我喊加油 我们说好了等候 冰淇淋店校门口 可是到如今只剩我一个 一个人走 我们，分别在那街角 我们，再也无法去寻找 有谁，还在脑海环绕 有谁，打开记忆的喧闹 关于青春一直在错过 我们终究怎么去拥有 回不去的那么多 我们无力再挽留 只能闭上眼一步步走 那年冬天那团大雪球 滚远了青春我们剩什么 如果提及那承诺 谁还会去再追究 我们都渐渐明白了永久 关于青春我们那么弱 莫名其妙什么都不说 找不到的是理由 没有声音的借口 总以为什么都能够承受 如果那天我没有开口 你会不会傻傻的依旧 其实不必多足够 只是我们不成熟 我们说好藏记忆在角落 从今以后]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019网易游戏引擎工程师笔试题]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2F2019%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题 第二题 第三题]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人诗词集（2003-2010）]]></title>
    <url>%2Fblog%2F2019%2F03%2F08%2F%E4%B8%AA%E4%BA%BA%E8%AF%97%E8%AF%8D%E9%9B%86%EF%BC%882003-2010%EF%BC%89%2F</url>
    <content type="text"><![CDATA[踏车行（2003）一条长蛇贯南北，千山万水形如飞。渭水绵延腾浪过，江山如此展雄威。 四月天 （2005）群鹜飞鸣楼宇间，莺歌燕舞碧云天。 细雨无边千百线，河烟濛阔起清涟。 两处山花两点丽，一弯路转一抹荫。 暮春四月皆绚艳，天人和洽尽欢颜。 自愁（2005）黑烟黄霭几时休？污水翻滚引入流。 可得一日清江水，草木丰茂碧悠悠。 杂词 · 暮游张家界（2005）长庚初露，斜阳更助，如画天涯处。山衬红日水映树，美景引人赴。 峰岩直矗，峭壁生木，金蝉鸣不住。十里长廊诗画路，将心如醉入。 一剪梅 · 心中秋感（2007.10.6）六年风萧两彷徨，雁又空唱，叶雨落黄。梦中泪眼见秋霜，艳菊才爽，串红仍放。 心蕴秋波万里浪，更又无常，但却激昂。浪中回首愁更怅，秋潮见涨，天地苍茫。 最相思（2008）梦绕魂萦夜无休，柔眸泪盼伴情愁。 轻灰留恋风尘去，一眼怎容满城秋？ 沁园春 · 少年志（2008.1.25）几路人生？独上微楼，叹何苦忧。愿一身正气，邪风斫就；持恒破浪，图志不休。万里连云，风华漫道，更谁刚强搏劲流。拭惘雾，唤了却尘埃，是非缘由。 嚣烦陋世何求，藏正义光明于心头。望才华横溢，风骚韵润；宽仁睿智，自恃清秋。对斩重霜，立挥潇雪，安得尽扫千古愁。立壮志，正年值少时，抛炫风流。 雪月（2008.1.27）俯首深吟凭冷月，昂头浅唱对华星。 斩风横扫千秋雪，劈浪立挥万里云。 题钰祥兄之马璐图（2009.12.5）春阳萦雪至，树影鸟鸣直。 泉间拂暖玉，莞尔璐如诗。 浣溪沙 · 清明（2010.4.5）闲枝浮梦沐日晴，短阳新柳柳无阴，空阶未雨暗花明。 清风掠水云自溢，暖絮萦烟泪空盈，门外花落谁堪听？ 江城子 · 二班必胜（2010.11.10）甘苦与共一春秋，不曾丢，志满楼。五十六人，团结胜一筹。过关斩将谁与休，风华秀，英姿流。 挥汗如雨冷风投，暴雨后，人莫愁。针锋相对，拼搏何须由。二班学子志尚在，今虽败，不低头！]]></content>
  </entry>
  <entry>
    <title><![CDATA[腾讯游戏实习生面试总结]]></title>
    <url>%2Fblog%2F2019%2F03%2F05%2F%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[初试面试官问到的主要问题： 数组与链表的主要优缺点分别是什么？如何整体复制一个数组？ 主要的排序方法有哪些？排序1000个数你会用哪种排序方法？快速排序在什么情况下为最坏情况，最坏情况下时间复杂度为多少？ 你对游戏引擎的理解？作为一个游戏引擎必须的部分有哪些？ 你是否了解游戏引擎背后的机制，选一个部分举例说明？ UDP和TCP协议在网络游戏中的应用？网络游戏中采取什么方式保证数据的可靠同步？你是否使用过reliable-UDP？ 谈谈你对渲染管线的理解，渲染管线全流程是什么样的？ 你知道哪些光照模型，分别有哪些特点？ 以你所做的项目深入，你怎么确定地形上植被的真实分布？你是否了解到有现有插件做到随机地图的生成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于Perlin Noise随机生成游戏地图]]></title>
    <url>%2Fblog%2F2019%2F03%2F05%2F%E5%9F%BA%E4%BA%8EPerlin-Noise%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%B8%B8%E6%88%8F%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[摘要 程序化内容生成（PCG）在游戏中的应用是使用随机数或伪随机数来实现游戏内容的程序化生成，其导致游戏内容更加不可预测，为游戏增加更多的可能性，为玩家带来更加持续的新鲜感。同时，这种方法也为游戏开发人员带来了许多优势，例如减少了内存消耗，辅助开发者更加迅速地进行游戏设计，以及对于基于人工的游戏开发作为一种补充。电子游戏中，地形地貌是游戏内容的重要组成部分，也会对游戏的整体美术风格与玩家的游戏体验造成很大影响。本文旨在提供一种顶视角2D像素风格游戏中实时生成无限地形地貌的可实行方案，希望能够提供一套基于Perlin noise的算法，通过输入有限个伪随机数种子，最终计算出较为美观的顶视角2D像素风格户外地貌，并且提供较强的多样性，使玩家在探索游戏地图时收获新鲜感与乐趣。 关键词 : 程序化内容生成, perlin噪声, 像素游戏 1. 引言 电子游戏中，地形地貌是游戏内容的重要组成部分，也会对游戏的整体美术风格与玩家的游戏体验造成很大影响。在以往的游戏中，地形地貌多为游戏设计与游戏开发人员事先设计好的内容，游戏一旦发布就已经固定，不具备任何随机性，而且不具备随着玩家的游戏进程实时生成，实时延展且无限延展的特性。近十年来，一大批内含程序化地形地貌生成的游戏涌现出来，如《Minecraft》，《Terraria》，《Don’t Starve》，《Enter the Gungeon》，这些游戏中或多或少的用到了程序化内容生成的思想，使其游戏内容尤其是游戏地形地貌更加的丰富和随机，带给玩家更持久的新鲜感，继而提供了更大的重复可玩性。 程序化内容生成（PCG）在游戏中的应用是使用随机数或伪随机数来实现游戏内容的程序化生成，其导致游戏内容更加不可预测，为游戏增加更多的可能性，为玩家带来更加持续的新鲜感。同时，这种方法也为游戏开发人员带来了许多优势，例如减少了内存消耗，辅助开发者更加迅速地进行游戏设计，以及对于基于人工的游戏开发作为一种补充[1]。PCG可以应用在影响游戏玩法的各种元素之上：地形，地图，图层，故事，对话，任务，角色，规则，变化或武器。PCG一种重要的应用就是生成无限的游戏内容，它可以用于实时生成具有足够变化性的内容。在1980年代，《Rogue》游戏为PCG开辟了一条新的道路，它创造了对后世影响深远的贡献，即游戏中的冒险是通过算法来生成的，每次游玩，就会创造一个全新的冒险[2]。后来很多游戏开发者模仿《Rogue》使用PCG来生成其游戏内容，以至于后来形成了一个新的roguelike游戏类型。Julian Togeliu等人提出了PCG在游戏创作中的三大目标和九大挑战，三大目标即多级多内容PCG，基于PCG的游戏设计和生成完整游戏，而九大挑战之中则包含非通用原创性内容生成这一挑战，其中提到了如今的roguelike游戏之中的地牢生成缺乏创意性[3]。Mark Hendrikx等人提出了程序化内容生成在游戏中应用的几个层次，自下而上分别为游戏比特层、游戏空间层、游戏系统层、游戏情节层、游戏设计层以及衍生内容层，其中，游戏地形地貌的程序化生成包含在游戏空间层，是基础而重要的一层[4]。 然而，在顶视角2D像素风格游戏中，游戏地形地貌如何合理并且丰富地展现给玩家是一个重要的问题。目前的顶视角2D游戏中使用的程序化地图生成技术，多数为地牢游戏中地牢房间的随机生成，而户外地形地貌生成的现有实现方案多数缺乏美观性。如何在顶视角2D游戏中程序化生成有一定风格的户外地形地貌，是一个有待解决的问题。 本文旨在提供一种顶视角2D像素风格游戏中实时生成无限地形地貌的可实行方案，希望能够提供一套算法，通过输入有限个伪随机数种子，最终计算出较为美观的顶视角2D像素风格户外地貌，并且提供较强的多样性，使玩家在探索游戏地图时收获新鲜感与乐趣。 为了实现这些目标，本文选用Perlin噪声为主要的伪随机数生成算法[5]，实现一个二维Perlin噪声网格，并且在此基础上建立由数值到地形类型的映射关系。另外，本文将根据每个点计算出的Perlin噪声值来指定生成地图资源如树木石头的概率。最后，将在水域地形上创造碰撞体，在特定地形上设定摩擦系数，改变角色的移动速率。 2. 相关工作 研究人员早已认识到程序化内容生成（PCG）在电子游戏创作中的重要性，之前有很多人从不同方面做出过相关的工作。在游戏开发中使用程序内容生成技术主要限于特定类型的游戏元素。PCG很少被用于生成整个游戏关卡，但是有一个值得注意的例外。地下城类型的游戏是一种在冒险和角色扮演游戏中经常遇到的游戏类型，其游戏关卡经常由PCG生成。由于其独特的游戏节奏，游戏玩法和游戏空间的组合，地牢关卡设计成为最适合展示PCG优势的地方。Roland van der Linden等人开展了关于生成地下城游戏关卡的程序方法的研究，他们总结了常见的做法，讨论了不同方法的优缺点，并确定了未来的一些有希望的挑战[6]。一般来说，当前的程序性地下城生成方法缺少的不是性能，而是更加强大的生成过程，以及对于生成过程更准确和更丰富的控制。这个领域仍然处于起步阶段，许多研究挑战仍然存在，例如，为设计师提高这些方法的直观性和可访问性。 关于将程序化内容生成应用于其他类型游戏地图生成领域，之前有人做出过一些实现方案。Lara-Cabrera等人为即时战略游戏《Planet Wars》提供了一个平衡的程序化地图生成器。该生成器使用进化策略生成和演化地图，并使用锦标赛系统评估这些地图的平衡质量，他们进行了几次实验，获得了一组可玩并且平衡的游戏地图[7]。Lawrence Johnson等人利用元胞自动机算法实现了洞穴关卡的无限生成，他们将基于元胞自动机的简单算法在无限洞穴游戏中进行评估，生成可玩且设计良好的基于隧道的地图。该算法具有非常低的计算成本，允许实时内容生成，并且所提出的地图在关卡设计方面提供了足够的灵活性[8]。Miguel Frade等人使用基于遗传算法的遗传地形程序技术自动演化地形，以获得所需的有足够可访问性的游戏地图[9]。Jean-David G´enevaux等人提出了一个框架，允许使用受水文学启发的概念快速直观地建模地形[10]。Houssam Hnaidi等人介绍了一种从一组参数化曲线生成地形的扩散方法，该曲线描述了地形特征，如山脊线，河床或悬崖。他们的方法为用户提供了基于矢量的直观的面向特征的地形控制。 不同类型的约束（例如高程，倾斜角和粗糙度）可以附加到曲线上，以便定义地形的形状，通过使用有效的多重网格扩散算法从曲线表示生成地形。 该算法可以在GPU上有效地实现，这允许用户以交互方式创建各种各样的景观[11]。 除了上述的地形地貌生成算法，还有许多研究者对于地图相关物的生成进行了一系列研究。Stefan Greuter提出了一种实时生成“伪无限”虚拟城市的方法。城市包含根据需要生成的几何变化的建筑物。建筑物生成参数由从建筑物位置导出的整数播种的伪随机数生成器创建。不同的建筑几何形状是从一组平面图中挑选出来。每个建筑物的楼层是通过在迭代过程中组合随机生成的多边形来创建的[12]。Soon Tee Teoh设计了一种算法模拟河流和海洋的侵蚀作用，来创建自然的河流、河流三角洲、沿海悬崖和海滩[13]。 与之前的程序化地形地貌生成相比，本文的地形地貌生成方法的难点之一在于如何在顶视角2D像素风格地图上表现出立体感，给与玩家以较为拟真的体验。另一个难点在于如何丰富地形地貌的多样性，以使玩家保持长久的新鲜感与游戏趣味。 3. 实现方法 3.1.Perlin noise Perlin噪声是一个非常强大的算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得奥斯卡科技成果奖。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形、火焰燃烧特效、水和云等等。柏林噪声绝大部分应用在二维，三维层面上，但某种意义上也能拓展到四维。一维柏林噪声可用于生成横版卷轴地形、模拟手绘线条等，在二维层面可以通过插值生成地形，而三维柏林噪声则可以模拟海平面上起伏的波浪。 Perlin噪声算法可以用于生成更加连续而平滑的随机数，没有白噪声的毛刺感，所以是生成游戏中地形地貌的一个重要工具。 3.2.计算噪声图 要使用Perlin噪声生成游戏地形地貌，需要计算出一个二维Perlin噪声，具体的实现方式需要以下几步。第一步，本文先用一个伪随机数生成器生成一个伪随机数序列，这个伪随机数生成器可以使用经典的线性同余法。第二步，需要在游戏场景中创建一个二维网格，本文暂且把每个单元格的大小设置为100*100，这个大小可以按需调整。之后，本文给二维网格的每个点指定一个随机的二维梯度向量，这些随机向量两个维度的值都是从第一步中伪随机数序列中抽取得到，之后对这个向量进行单位化，这样就得到了一张每个网格点都对应一个指向某个随机方向的单位向量的二维网格。第三步，也是最重要的一步，开始计算场景中每个点的噪声值，即一个0到1之间的随机数。 关于这个计算方法，本文将任取一个点举例说明。想要计算一个点的噪声值，首先，要先找到他所在的单元格，并且确定该单元格四个角的坐标点，这一操作可以通过整型变量除法得到。例如本文取坐标为（157，-233）的这个点，就可以得到其所在单元格的四个角的坐标分别为：（100，-300）、（100，-200）、（200，-300）、（200，-200）。然后通过两点位置矢量相减的方法分别得到这四个角指向待计算点的四个向量，将这四个向量分别与其所在的角的网格点对应的随机单位向量点乘，得到四个值，将这四个值根据待计算点在单元格内部的相对于左下角的uv值进行双线性插值。所谓uv值，即为相对于左下角的局部坐标系的坐标与单元格大小的比值，例如点（157，-233）局部坐标uv值即为（0.57,0.67），根据u值进行两次线性插值，再对结果根据v值进行一次线性插值，即为双线性插值。这样所得到的最终结果已与所需要的结果非常接近，但是可以发现，这样的计算结果的取值范围为（ ）。于是最后将结果乘以 之后加1再除以2，即得到本文所需要的取值范围（0,1）的噪声值。 3.3.配置地形数值映射表 虽然计算平滑且一阶导数连续的噪声值是本文地形地貌生成算法的重要一步，但是仅仅得到游戏场景中每个点的噪声值还是不够的，还需要建立噪声值与地形地貌之间的映射关系，才可以指导在屏幕上渲染什么样式的地形地貌贴图。本文将（0,1）这个范围根据需要分为若干个小区间，每一个小区间映射到一种类型的地形地貌。例如（0.2,0.35）映射为草地，那么当某一点的噪声值落在（0.2,0.35）区间内的时候，即可以根据其草地的特性为其贴上相应的地砖或是绘制相应的颜色。除此以外，还可以给每一种地形设置摩擦系数，以限制玩家角色在其上的奔跑速度，或者设置游戏中资源如在此种地形之上的生成概率，以控制资源在不同地形上的分布。 4. 结果与展望 本文在Unity引擎中利用引擎中的Tilemap系统实现了该算法，计算出一张足够大的二维Perlin噪声网格以键值对的形式保存在C#的字典结构中，然后根据这些噪声值在Tilemap系统中给各点贴上了地砖Tiles，并且根据设定的概率值添加了树木和石头等游戏中需要用到的资源，最后形成了比较好的效果。 在这个基于Perlin Noise生成游戏地图的算法基础之上，还有很多可以改进的点，比如更好的美术效果，在地图上加入剧情引导等。如何用PCG技术随机生成更具风格化与可玩性的游戏地图，还有待之后的研究不断进行探索。 参考文献 [1] Shaker N, Togelius J, Nelson M J. Procedural Content Generation in Games[M]. Cham: Springer International Publishing, 2016. [2] Amato A. Procedural Content Generation in the Game Industry[A]. 见: O. Korn, N. Lee. Game Dynamics[M]. Cham: Springer International Publishing, 2017: 15–25. [3] Togelius J, Champandard A J, Lanzi P L, et al. Procedural content generation: Goals, challenges and actionable steps[C]//Dagstuhl Follow-Ups. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2013, 6. [4] Hendrikx M, Meijer S, Van Der Velden J等. Procedural content generation for games: A survey[J]. ACM Transactions on Multimedia Computing, Communications, and Applications, 2013, 9(1): 1–22. [5] Liu D, Yan S, Ji R-R等. Image retrieval with query-adaptive hashing[J]. ACM Transactions on Multimedia Computing, Communications, and Applications, 2013, 9(1): 1–16. [6] van der Linden R, Lopes R, Bidarra R. Procedural Generation of Dungeons[J]. IEEE Transactions on Computational Intelligence and AI in Games, 2014, 6(1): 78–89. [7] Lara-Cabrera R, Cotta C, Fernández-Leiva A J. Procedural map generation for a RTS game[C]//13th International GAME-ON Conference on Intelligent Games and Simulation. 2012: 53-58. [8] Johnson L, Yannakakis G N, Togelius J. Cellular automata for real-time generation of infinite cave levels[A]. Proceedings of the 2010 Workshop on Procedural Content Generation in Games - PCGames ’10[C]. Monterey, California: ACM Press, 2010: 1–4. [9] Frade M, de Vega F F, Cotta C. Evolution of Artificial Terrains for Video Games Based on Accessibility[A]. 见: C. Di Chio, S. Cagnoni, C. Cotta等. Applications of Evolutionary Computation[M]. Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, 6024: 90–99. [10] Génevaux J-D, Galin É, Guérin E等. Terrain generation using procedural models based on hydrology[J]. ACM Transactions on Graphics, 2013, 32(4): 143. [11] Hnaidi H, Guérin E, Akkouche S等. Feature based terrain generation using diffusion equation[J]. Computer Graphics Forum, 2010, 29(7): 2179–2186. [12] Greuter S, Parker J, Stewart N, et al. Real-time procedural generation ofpseudo infinite’cities[C]//Proceedings of the 1st international conference on Computer graphics and interactive techniques in Australasia and South East Asia. ACM, 2003: 87-ff. [13] Teoh S T. River and Coastal Action in Automatic Terrain Generation[C]//CGVR. 2008: 3-9.]]></content>
  </entry>
  <entry>
    <title><![CDATA[怎样理解随机过程中的样本函数]]></title>
    <url>%2Fblog%2F2018%2F12%2F26%2F%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[结合上面信号分析角度的回答，我说一点自己的理解。 先说基本定义： 1.随机过程X(t,e)确定时间t，得到一个随机变量X(e)； 2.随机过程X(t,e)确定样本点e，得到一个定义域为T，值域为状态空间子集的普通函数X(t)，即样本函数，又称轨道。 随机过程可以看成一族随机变量的集合，也可以看成一族样本函数的集合。 我的理解是： 第一句话是在t时刻竖切一刀，从截面上得到此时刻下的概率分布； 第二句话是从随机过程这个很多缕曲线组成的“麻绳”中，横向拉出一条样本点e，取出不确定的随机过程中的一条确定的“实例”。这个“实例”消除了不确定性，所以是普通函数，图形表现为一条曲线。 例如： 在一个盒子中放置一个随机游走的粒子，观察其x方向的位置X(t,e)，这是一个随机过程。 在时刻t打开盒子观察，此时粒子各位置的可能性即构成了随机变量X(e)； 在[0,+∞)的时间段内一直打开盒子观察，得到此次观察中每个t时刻粒子的确定位置并记录，得到一个关于t的确定函数曲线，即为样本函数X(t)。 关于各态历经性： 刚才这个例子中，随机过程是具有各态历经性的，因为只要观察时间足够长，那么这个粒子必然会经过盒子中的任一点，即取得的这条样本函数X(t)的值域遍历了整个状态空间。 我们把粒子换成一个静止的小木块，初始时刻放在盒子里的随机位置，那么接下来其x方向位置也可以视作一个随机过程X(t,e)=A(e)，只不过是一个等于不随时间变化的常随机变量A(e)的随机过程。当我们在t时刻观察，由于初始位置是随机的，所以我们观察到的各种可能性即构成随机变量X(e)=A(e)；而我们持续观察，则会得到一条普通函数X(t)=a，即此时样本函数为一条平行于t轴的直线，值域为常数a，显然不能覆盖全部状态空间，而且观察时间再长也不会改变，此随机过程无各态历经性。 一点浅薄理解，若有错误，希望数学专业大佬能够指正。]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过NuGet包管理器快速在Visual Studio中配置OpenGL环境]]></title>
    <url>%2Fblog%2F2018%2F10%2F15%2Fe9-80-9a-e8-bf-87nuget-e5-8c-85-e7-ae-a1-e7-90-86-e5-99-a8-e5-bf-ab-e9-80-9f-e5-9c-a8visual-studio-e4-b8-ad-e9-85-8d-e7-bd-aeopengl-e7-8e-af-e5-a2-83%2F</url>
    <content type="text"><![CDATA[PM&gt; Install-Package nupengl.core -Version 0.1.0.1]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LAMP搭建私有云OwnCloud流程]]></title>
    <url>%2Fblog%2F2018%2F10%2F13%2Flamp-e6-90-ad-e5-bb-ba-e7-a7-81-e6-9c-89-e4-ba-91owncloud-e6-b5-81-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[STEP1: 在Ubuntu 16.04搭建LAMPApache installationTo install webserver i.e. Apache, open terminal &amp; execute the following command, $ sudo apt-get install apache2 Once the package has been installed, start the apache service &amp; enable it for boot, $ sudo systemctl start apache2 $ sudo systemctl enable apache2 Now we can test the apache installation. To test the apache installation, open web browser &amp; in the address bar enter the following url, http://localhost MySQL installationNext thing to install is database, we are using MySql as our choice of database server. To install MySql on Ubuntu machine, run the following command from terminal $ sudo apt-get install mysql-server mysql-client During the MySql installation, we will be asked to provide ‘root’ password, provide a suitable password &amp; than confirm it to complete the installation. Once the installation has been completed, start the MySql service &amp; enable it for boot, $ sudo systemctl start mysql $ sudo systemctl enable mysql We can now connect to the database to check the installation, to connect to MySql, use the following command, $ mysql -u root -p And than enter the root password that we provided at the time of installation to connect to mysql, PHP installationDynamic content of a website is processed by PHP, its a general purpose programming language. To install php on the system, execute the following command from terminal, $ sudo apt-get install php7.0-mysql php7.0-curl php7.0-json php7.0-cgi libapache2-mod-php7.0 php7.0 Once the isntallation has been complete, we will test the php. To do that, open $ sudo vim /var/www/html/test.php &amp; enter the following content to it, &lt;? phpinfo(); ?&gt; Save the file &amp; restart the apache service, $ sudo systemctl restart apache2 Now open the browser &amp; enter the following URL, http://localhost/test.php We should now see the following page with details about the installed PHP, We know have our LAMP stack on Ubuntu OS ready to use, we can now deploy the dynamic websites on this stack. STEP2: 搭建OwnCloud我们需要在自己的设备里安装这些包： $ sudo yum install php-mysql php-json php-xml php-mbstring php-zip php-gd curl php-curl php-pdo 安装 OwnCloud，我们现在需要在服务器上下载 OwnCloud 安装包。使用下面的命令从官方网站下载安装包（10.0.4）： $ wget https://download.owncloud.org/community/owncloud-10.0.4.tar.bz2 使用下面的命令解压： $ tar -xvf owncloud-10.0.4.tar.bz2 现在，将所有解压后的文件移动至 /var/www/html： $ mv owncloud/* /var/www/html 注意还有两个隐藏文件需要分别移动： $ mv owncloud/.htaccess /var/www/html $ mv owncloud/.user.ini /var/www/html 下一步，我们需要在 Apache 的配置文件 apache2.conf 上做些修改： $ sudo vim /etc/apache2/apache2.conf 更改下面的选项： AllowOverride All 保存该文件，并修改 OwnCloud 文件夹的文件权限： $ sudo chown -R www-data:www-data /var/www/html/ $ sudo chmod 777 /var/www/html/config/ 然后重启 Apache 服务器执行修改： $ sudo systemctl restart apache2 现在，我们需要在 MySQL 上创建一个数据库，保存来自 OwnCloud 的数据。使用下面的命令创建数据库owncloud和数据库用户ocuser： $ mysql -u root -p mysql &gt; create database owncloud; mysql &gt; GRANT ALL ON owncloud.* TO ocuser@localhost IDENTIFIED BY &apos;owncloud&apos;; mysql &gt; flush privileges; mysql &gt; exit 修改ocuser用户密码： $ mysql -u root -p mysql &gt; use mysql; mysql &gt; UPDATE user SET authentication_string=PASSWORD(&quot;your password&quot;) WHERE user=&apos;ocuser&apos;; mysql &gt; FLUSH PRIVILEGES; mysql &gt; quit; 在浏览器中输入你的服务器IP地址，显示如下界面，填写配置，服务器端搭建，完成！ 去官网下载并安装客户端：https://owncloud.org/download/。 ownCloud，启动！ 参考链接： https://linuxtechlab.com/install-lamp-stack-on-ubuntu https://linux.cn/article-9418-1.html 若有大佬对此文存在修改意见，或是配置过程中存在错误，请在评论区留言。]]></content>
      <categories>
        <category>应用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3 常用插件清单]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fsublime-text-3-e5-b8-b8-e7-94-a8-e6-8f-92-e4-bb-b6-e6-b8-85-e5-8d-95%2F</url>
    <content type="text"><![CDATA[BracketHighlighter DocBlockr Emmet SideBarEnhancements ColorPicker ConvertToUTF8 HTML-CSS-JS Prettify Git jQuery Python 3 Theme - Spacegray Sublime Text 3 License Code ----- BEGIN LICENSE —– sgbteam Single User License EA7E-1153259 8891CBB9 F1513E4F 1A3405C1 A865D53F 115F202E 7B91AB2D 0D2A40ED 352B269B 76E84F0B CD69BFC7 59F2DFEF E267328F 215652A3 E88F9D8F 4C38E3BA 5B2DAAE4 969624E7 DC9CD4D5 717FB40C 1B9738CF 20B3C4F1 E917B5B3 87C38D9C ACCE7DD8 5F7EF854 86B9743C FADC04AA FB0DA5C0 F913BE58 42FEA319 F954EFDD AE881E0B —— END LICENSE ——]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[24岁小结]]></title>
    <url>%2Fblog%2F2018%2F09%2F24%2F24%E5%B2%81%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[24岁，这一年经历了几个对我而言很重要的事件，也度过了一段比较难受的日子。 没有明白什么新的道理，不再像年少时那样进步飞速，一年有一年新的样子，更多时候是在实践中反复摸索。 已经不再习惯在生日时写一些长篇壮志。只是这一年，使我更加确定的是，人生无常，一定要明白自己生命中真正最想要的是什么，假如下一秒即将死亡，你最遗憾的事会是什么。即使暂时得不到，暂时无法做自己想要做的事，也至少理应明晰自己的方向。 关于我最想要的，在我22岁时已说过，愿矢志不渝。 愿乘长风破万里浪。]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git日志别名配置命令行git lg]]></title>
    <url>%2Fblog%2F2018%2F07%2F24%2Fgit-e6-97-a5-e5-bf-97-e5-88-ab-e5-90-8d-e9-85-8d-e7-bd-ae-e5-91-bd-e4-bb-a4-e8-a1-8cgit-lg%2F</url>
    <content type="text"><![CDATA[git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 表格组件]]></title>
    <url>%2Fblog%2F2018%2F03%2F24%2Fvue-js-e8-a1-a8-e6-a0-bc-e7-bb-84-e4-bb-b6%2F</url>
    <content type="text"><![CDATA[HTML： &lt;div id="target"&gt;&lt;/div&gt; JS： //Vue组件开始var Grid = Vue.extend(&#123; template: '&lt;table class="table" :class="&#123;layoutFixed: config.layoutFixed&#125;"&gt;\ &lt;thead&gt;\ &lt;tr&gt;\ &lt;th v-for="col in config.colModel" \ v-if="col.sort" \ :width="col.width" \ :col="col.name" \ :title="removeTag(col.display)" &gt;\ &lt;div class="sort ellipsis" :sortType="col.sortType"&gt;&#123; &#123;col.display&#125;&#125;\ &lt;i class="icon-chevron-up" @click="sortUp"&gt;&lt;/i&gt;\ &lt;i class="icon-chevron-down" @click="sortDown"&gt;&lt;/i&gt;\ &lt;/div&gt;&lt;/th&gt;\​ &lt;th v-else \​ class="ellipsis"\​ :width="col.width" \​ :col="col.name" \​ :title="removeTag(col.display)" &gt;&#123; &#123;col.display&#125;&#125;&lt;/th&gt;\​ &lt;/tr&gt;\​ &lt;/thead&gt;\​ &lt;tbody&gt;\​ &lt;tr v-for="row in resData.rows"&gt;\​ &lt;td v-for="col in config.colModel"\​ :title="removeTag(row\[col.name\])" v-handle="&#123;handler:col.handler, v:row\[col.name\], data:row&#125;"&gt;&#123; &#123;row\[col.name\]&#125;&#125;&lt;/td&gt;\​ &lt;/tr&gt;\​ &lt;/tbody&gt;\​ &lt;/table&gt;',​ data: function () &#123;​ return &#123;​ url: '',​ config: &#123;&#125;,​ param: &#123;&#125;,​ resData: &#123;&#125;​ &#125;;​ &#125;,​ computed: &#123;&#125;,methods: &#123; getData: function () &#123; var self = this; $.ajax(&#123; url: this.url, type: 'GET', data: this.param, success: function (json) &#123; json = JSON.parse(json); self.resData = json.data; &#125; &#125;); &#125;, sortUp: function (event) &#123; $.extend(this.param, &#123; sortType: $(event.target).parent().attr('sorttype'), orderType: "1" &#125;); this.getData(); &#125;, sortDown: function (event) &#123; $.extend(this.param, &#123; sortType: $(event.target).parent().attr('sorttype'), orderType: "2" &#125;); this.getData(); &#125;, removeTag: function (str) &#123; if (str) &#123; str = str.toString(); return str.replace(/&lt;("\[^"\]*"|'\[^'\]*'|\[^"'&gt;\])&gt;/g, ''); &#125; else &#123; return ''; &#125; &#125;, log: function (str) &#123; console.log(str); &#125;&#125;,directives: &#123; handle: &#123; inserted: function (el, binding) &#123; var handler = binding.value.handler; if (handler &amp;&amp; $.isFunction(handler)) &#123; handler(binding.value.v, binding.value.data, $(el), $(el).parent('tr')); &#125; &#125; &#125;&#125;,mounted: function () &#123; this.getData();&#125;&#125;);Vue.component('grid', Grid);//Vue组件结束//创建Vue实例开始var vm = new Grid(&#123; el: config.renderTo, data: &#123; url: config.url, config: config &#125;, computed: &#123;&#125;&#125;);//创建Vue实例结束]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[怎么使用正则表达式完美匹配HTML标签？]]></title>
    <url>%2Fblog%2F2018%2F03%2F24%2Fe6-80-8e-e4-b9-88-e4-bd-bf-e7-94-a8-e6-ad-a3-e5-88-99-e8-a1-a8-e8-be-be-e5-bc-8f-e5-ae-8c-e7-be-8e-e5-8c-b9-e9-85-%2F</url>
    <content type="text"><![CDATA[转自腾讯前端博客：http://imweb.io/topic/56e804e… 匹配HTML标签嘛，感觉很简单的样子，我们的第一反应可能是：var pattern = /&lt;[^&gt;]+&gt;/ 不过这样匹配可能存在的问题是：如果tag中含有&gt;，上面的正则就不能正常匹配了。如： &lt;input name=123 value=&quot;&gt;&quot; &gt; 虽然上面这种HTML的写法很少(sha)见(bi)，但确实合法的。因此，简单的&lt;[^&gt;]+&gt;就不能用了，需要想个聪明点的办法。 我们先来看一下HTML Tag中有什么规则：&lt;...&gt;中能够出现 引用文本（被单引号或双引号包裹的） 非引用形式的“其他文本”（包括除了&gt;和引号之外的任何字符） 引用文本：HTML中的引文可以用双引号，也可以用单引号，但不允许嵌套转义的引号。 因此我们可以使用/(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;)/来匹配。 其他文本：除了&gt;和引号之外的任意字符 可以使用/[^&#39;&quot;&gt;]/来匹配 现在可以得出匹配HTML Tag的正则表达式最终版！ var pattern = /&lt;(“[^”]“|’[^’]‘|[^’”&gt;])*&gt;/ 给这个正则表达式来点注释： &lt; # 开始的尖括号”&lt;” ( # 任意数量的… “[^”]*“ # 双引号字符串 | # 或者是… ‘[^’]*‘ # 单引号字符串 | # 或者是… [^’”&gt;] # “其他文本” )* #> # 结束的尖括号”&gt;” 需要注意的是，我们不用”+”来修饰[^&#39;&quot;&gt;]的原因是([^&#39;&quot;&gt;]+)*可能会带来灾难性的后果。匹配次数呈指数级增长。比如：对于简单的目标字符串helloworld，是星号会迭代10次，每一次迭代中[^&#39;&quot;&gt;]+匹配一个字符？还是星号迭代3次，内部的[^&#39;&quot;&gt;]+分别匹配5、2、3个字符？或者2、3、1、4个字符？还是其他情况？这样会把正则引擎搞疯掉的啦！]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Starter Kit 学习笔记]]></title>
    <url>%2Fblog%2F2018%2F03%2F24%2Freact-starter-kit-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0%2F</url>
    <content type="text"><![CDATA[根据http://reactjs.cn/react/docs/…页面中Starter Kit 15.3.1中的例子汇总修改而成。 HTML代码 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;React test&lt;/title&gt; &lt;link rel="stylesheet" href="react_transition.css"&gt; &lt;script src="lib/react-with-addons.js"&gt;&lt;/script&gt; &lt;script src="lib/react-dom.js"&gt;&lt;/script&gt; &lt;script src="lib/browser.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container1"&gt;&lt;/div&gt; &lt;div id="container2"&gt;&lt;/div&gt; &lt;div id="container3"&gt;&lt;/div&gt; &lt;div id="container4"&gt;&lt;/div&gt; &lt;div id="container5"&gt;&lt;/div&gt; &lt;div id="container6"&gt;&lt;/div&gt; &lt;div id="container7"&gt;&lt;/div&gt; &lt;div id="container8"&gt;&lt;/div&gt; &lt;div id="container9"&gt;&lt;/div&gt; &lt;div id="container10"&gt;&lt;/div&gt; &lt;script src="react_test.js" type="text/babel"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS代码 const container1 = document.getElementById('container1')const container2 = document.getElementById('container2')const container3 = document.getElementById('container3')const container4 = document.getElementById('container4')const container5 = document.getElementById('container5')const container6 = document.getElementById('container6')//1 'Hello' + namefunction Welcome(props) &#123; return &lt;h1 &gt; Hello, &#123; props.name &#125; &lt; /h1&gt;;&#125;const element = &lt; Welcome name = "Diary" / &gt; ;ReactDOM.render( element, container1);//2 流逝时间计时器var Elapsed = React.createClass(&#123; render: function () &#123; var elapsed = Math.round(this.props.elapsed / 100); var seconds = elapsed / 10 + (elapsed % 10 ? '' : '.0'); var message = 'React has been successfully running for ' + seconds + ' seconds.';​ return &lt;p &gt; &#123; message &#125; &lt; /p&gt;;&#125;&#125;);var start = new Date().getTime();setInterval(function () &#123; ReactDOM.render( &lt; Elapsed elapsed = &#123; new Date().getTime() - start &#125; / \&gt; , container2 );&#125;, 50);//3 按钮点击计数var Counter = React.createClass(&#123; getInitialState: function () &#123; return &#123; count: 2, sum: 100 &#125;; &#125;, handleClick: function () &#123; this.setState(&#123; count: this.state.count * this.state.count, &#125;); &#125;, handleDoubleClick: function () &#123; this.setState(&#123; count: 2, sum: 1000 &#125;) &#125;, render: function () &#123; return ( &lt; button onClick = &#123; this.handleClick &#125; onDoubleClick = &#123; this.handleDoubleClick &#125;&gt; sum - count: &#123; this.state.sum - this.state.count &#125; &lt; /button&gt; ); &#125;&#125;);ReactDOM.render( &lt; Counter / &gt; , container3);//4 流逝时间计时器（ES6写法）class ExampleApplication extends React.Component &#123; render() &#123; var elapsed = Math.round(this.props.elapsed / 100); var seconds = elapsed / 10 + (elapsed % 10 ? '' : '.0'); var message = `React has been successfully running for $&#123;seconds&#125; seconds.`;​ return &lt;p &gt; &#123; message &#125; &lt; /p&gt;;&#125;&#125;var start = new Date().getTime();setInterval(() =&gt; &#123; ReactDOM.render( &lt; ExampleApplication elapsed = &#123; new Date().getTime() - start &#125;/&gt;, container4 );&#125;, 50);//5 实时求解一元二次方程var QuadraticCalculator = React.createClass(&#123; getInitialState: function() &#123; return &#123; a: 1, b: 3, c: -4 &#125;; &#125;, /\*\* \* This function will be re-bound in render multiple times. Each .bind() will \* create a new function that calls this with the appropriate key as well as \* the event. The key is the key in the state object that the value should be \* mapped from. */ handleInputChange: function(key, event) &#123; var partialState = &#123;&#125;; partialState\[key\] = parseFloat(event.target.value); this.setState(partialState); &#125;, render: function() &#123; var a = this.state.a; var b = this.state.b; var c = this.state.c; var root = Math.sqrt(Math.pow(b, 2) - 4 * a * c); var denominator = 2 * a; var x1 = (-b + root) / denominator; var x2 = (-b - root) / denominator; return ( &lt;div&gt; &lt;strong&gt; &lt;em&gt;ax&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; + &lt;em&gt;bx&lt;/em&gt; + &lt;em&gt;c&lt;/em&gt; = 0 &lt;/strong&gt; &lt;h4&gt;Solve for &lt;em&gt;x&lt;/em&gt;:&lt;/h4&gt; &lt;p&gt; &lt;label&gt; a: &lt;input type="number" value=&#123;a&#125; onChange=&#123;this.handleInputChange.bind(null, 'a')&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; b: &lt;input type="number" value=&#123;b&#125; onChange=&#123;this.handleInputChange.bind(null, 'b')&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; c: &lt;input type="number" value=&#123;c&#125; onChange=&#123;this.handleInputChange.bind(null, 'c')&#125; /&gt; &lt;/label&gt; &lt;br /&gt; x: &lt;strong&gt;&#123;x1&#125;, &#123;x2&#125;&lt;/strong&gt; &lt;/p&gt; &lt;/div&gt;​ ); &#125;&#125;);ReactDOM.render( &lt;QuadraticCalculator /&gt;, container5);//6 调用React组件CSSTransitionGroup制作动画效果var CSSTransitionGroup = React.addons.CSSTransitionGroup;var INTERVAL = 2000;var AnimateDemo = React.createClass(&#123;getInitialState: function() &#123; return &#123;current: 0&#125;;&#125;,componentDidMount: function() &#123; this.interval = setInterval(this.tick, INTERVAL);&#125;,componentWillUnmount: function() &#123; clearInterval(this.interval);&#125;,tick: function() &#123; this.setState(&#123;current: this.state.current + 1&#125;);&#125;,render: function() &#123; var children = \[\]; var colors = \['#fac', '#cdc', '#36d', '#ca0', '#0aa'\]; for (var i = this.state.current, pos=0; i &lt; this.state.current + colors.length; i++, pos++) &#123; var style = &#123; left: pos * 128, background: colors\[i % colors.length\] &#125;; children.push(&lt;div key=&#123;i&#125; className="animateItem" style=&#123;style&#125;&gt;&#123;i&#125;&lt;/div&gt;); &#125; return ( &lt;CSSTransitionGroup className="animateExample" transitionEnterTimeout=&#123;250&#125; transitionLeaveTimeout=&#123;250&#125; transitionName="example"&gt; &#123;children&#125; &lt;/CSSTransitionGroup&gt; );&#125;&#125;);ReactDOM.render(&lt;AnimateDemo /&gt;,container6); CSS代码（仅在例6中使用） .example-enter,.example-leave &#123; -webkit-transition: all .25s; transition: all .25s;&#125;.example-enter,.example-leave.example-leave-active &#123; opacity: 0.01;&#125;.example-leave.example-leave-active &#123; margin-left: -128px;&#125;.example-enter &#123; margin-left: 128px;&#125;.example-enter.example-enter-active,.example-leave &#123; margin-left: 0; opacity: 1;&#125;.animateExample &#123; display: block; height: 128px; position: relative; width: 384px;&#125;.animateItem &#123; color: white; font-size: 36px; font-weight: bold; height: 128px; line-height: 128px; position: absolute; text-align: center; -webkit-transition: all .25s; /* TODO: make this a move animation */ transition: all .25s; /* TODO: make this a move animation */ width: 128px;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript闭包原理分析]]></title>
    <url>%2Fblog%2F2018%2F03%2F23%2Fjavascript-e9-97-ad-e5-8c-85-e5-8e-9f-e7-90-86-e5-88-86-e6-9e-90%2F</url>
    <content type="text"><![CDATA[写了几个小例子揭示JS中闭包的本质，适合自己运行后分析。 HTML文件 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Test&lt;/title&gt; &lt;script src="lib/jquery-3.1.0.js"&gt;&lt;/script&gt; &lt;script src="closure_example.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;0&lt;/button&gt; &lt;button&gt;1&lt;/button&gt; &lt;button&gt;2&lt;/button&gt; &lt;button&gt;3&lt;/button&gt; &lt;button&gt;4&lt;/button&gt; &lt;button&gt;5&lt;/button&gt; &lt;button style="display:none" class="hide"&gt;什么是闭包&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; JS代码 $(function () &#123;/*给6个按钮绑定事件，点击打印按钮的序号 */for (var i = 0; i &lt; 6; i++) &#123; $('button').eq(i).on('click', function () &#123; console.log(i); &#125;);&#125;/*解决方案一：借用DOM元素的属性存储序号i */for (var i = 0; i &lt; 6; i++) &#123; $('button').eq(i).attr('i', i).on('click', function () &#123; console.log($(this).attr('i')); &#125;);&#125;/*解决方案二：利用IIFE将i作为参数传递给内部函数 */for (var i = 0; i &lt; 6; i++) &#123; (function (i) &#123; $('button').eq(i).on('click', function () &#123; console.log(i); &#125;); &#125;)(i);&#125;/*错误方案：IIFE使用位置错误 */for (var i = 0; i &lt; 6; i++) &#123; $('button').eq(i).on('click', function () &#123; (function (i) &#123; console.log(i); &#125;)(i); &#125;);&#125;/*解决方案三：利用IIFE所创造的“块级作用域”，将i赋值给局部变量*/for (var i = 0; i &lt; 6; i++) &#123; (function () &#123; var temp = i; $('button').eq(temp).on('click', function () &#123; console.log(temp); &#125;); &#125;)();&#125;/*什么是闭包？*/function closure() &#123; var i = 0; return function fun() &#123; i++; console.log(i); &#125;&#125;var foo = closure();foo();foo();foo();var bar = closure();bar();bar();bar();$('.hide').show().on('click', foo)&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法（C++）代码练习（PTA题目）]]></title>
    <url>%2Fblog%2F2018%2F03%2F10%2Fe6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-e4-b8-8e-e7-ae-97-e6-b3-95-ef-bc-88c-ef-bc-89-e4-bb-a3-e7-a0-81-e7-bb-83-e4-b9-a0-ef-bc-88pta-e9-a2-98-e7-9b-ae-ef-bc-89%2F</url>
    <content type="text"><![CDATA[所有代码均由Microsoft Visual Studio 2015编译通过 在线算法输出N个整数的最大子列和#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int maxSubSum(int a[], int n)&#123; int thisSum = 0, maxSum = 0; for (int i = 0; i &lt; n; i++) &#123; thisSum += a[i]; if (thisSum &gt; maxSum) &#123; maxSum = thisSum; &#125; if (thisSum &lt; 0) &#123; thisSum = 0; &#125; &#125; return maxSum;&#125;void main()&#123; int n, *a, sum; cout &lt;&lt; "请输入数列长度：\n"; cin &gt;&gt; n; a = new int[n]; cout &lt;&lt; "请输入数列：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sum = maxSubSum(a, n); cout &lt;&lt; "最大子列和为：" &lt;&lt; sum &lt;&lt; "\n"; system("pause");&#125; 在线算法输出N个整数的最大子列和及其首尾项#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int maxSubSumPrint(int a[], int n)&#123; int thisSum = 0, maxSum = -1; int head, rear, flag = 0; int maxHead = 0, maxRear = n - 1; for (int i = 0; i &lt; n; i++) &#123; thisSum += a[i]; if (flag == 0) &#123; if (a[i] &gt;= 0) &#123; head = rear = i; flag = 1; &#125; &#125; else &#123; rear++; &#125; if (thisSum &gt; maxSum) &#123; maxSum = thisSum; maxHead = head; maxRear = rear; &#125; if (thisSum &lt; 0) &#123; thisSum = 0; flag = 0; &#125; &#125; if (maxSum == -1) &#123; maxSum = 0; &#125; cout &lt;&lt; "最大子列和为：" &lt;&lt; maxSum &lt;&lt; "\n"; cout &lt;&lt; "最大子列头数字为" &lt;&lt; a[maxHead] &lt;&lt; " 尾数字为" &lt;&lt; a[maxRear] &lt;&lt; "\n"; return maxSum;&#125;void main()&#123; int n, *a; cout &lt;&lt; "请输入数列长度：\n"; cin &gt;&gt; n; a = new int[n]; cout &lt;&lt; "请输入数列：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; maxSubSumPrint(a, n); system("pause");&#125; 使用链表输出两个一元多项式的乘积与和#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class PolyNode&#123;public: int coef; int expo; PolyNode *nextNode;&#125;;PolyNode* inputPoly(int n) &#123; if (n &lt;= 0) &#123; return NULL; &#125; PolyNode *poly = new PolyNode; PolyNode *p = NULL; cout &lt;&lt; "请以指数递降顺序输入各项系数与指数（以空格分开）：\n"; p = poly; cin &gt;&gt; p-&gt;coef; cin &gt;&gt; p-&gt;expo; while (--n) &#123; p-&gt;nextNode = new PolyNode; p = p-&gt;nextNode; cin &gt;&gt; p-&gt;coef; cin &gt;&gt; p-&gt;expo; &#125; p-&gt;nextNode = NULL; return poly;&#125;PolyNode* add(PolyNode* p1, PolyNode* p2)&#123; PolyNode* p = new PolyNode; p-&gt;nextNode = new PolyNode; PolyNode* p0 = NULL; if (p1 || p2) &#123; p0 = p-&gt;nextNode; &#125; while (p1&amp;&amp;p2) &#123; p = p-&gt;nextNode; if (p1-&gt;expo &gt; p2-&gt;expo) &#123; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;nextNode; &#125; else if (p1-&gt;expo &lt; p2-&gt;expo) &#123; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;nextNode; &#125; else &#123; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef + p2-&gt;coef; p1 = p1-&gt;nextNode; p2 = p2-&gt;nextNode; &#125; p-&gt;nextNode = new PolyNode; &#125; while (p1) &#123; p = p-&gt;nextNode; p-&gt;expo = p1-&gt;expo; p-&gt;coef = p1-&gt;coef; p1 = p1-&gt;nextNode; p-&gt;nextNode = new PolyNode; &#125; while (p2) &#123; p = p-&gt;nextNode; p-&gt;expo = p2-&gt;expo; p-&gt;coef = p2-&gt;coef; p2 = p2-&gt;nextNode; p-&gt;nextNode = new PolyNode; &#125; p-&gt;nextNode = NULL; return p0;&#125;PolyNode* mult(PolyNode* p1, PolyNode* p2)&#123; PolyNode *p = NULL; PolyNode *t = new PolyNode; t-&gt;nextNode = NULL; PolyNode \*i = p1, \*j = p2; while (i) &#123; if (i-&gt;coef) &#123; j = p2; while (j) &#123; if (j-&gt;coef) &#123; t-&gt;coef = i-&gt;coef*j-&gt;coef; t-&gt;expo = i-&gt;expo + j-&gt;expo; p = add(p, t); &#125; j = j-&gt;nextNode; &#125; &#125; i = i-&gt;nextNode; &#125; return p;&#125;void printPoly(PolyNode* p)&#123; int flag = 0; while (p) &#123; if (p-&gt;coef) &#123; cout &lt;&lt; p-&gt;coef &lt;&lt; ' ' &lt;&lt; p-&gt;expo &lt;&lt; ' '; flag = 1; &#125; p = p-&gt;nextNode; &#125; if (!flag) &#123; cout &lt;&lt; "0 0"; &#125; cout &lt;&lt; "\n";&#125;void main()&#123; int n1, n2; PolyNode \*p1, \*p2, \*padd, \*pmult; cout &lt;&lt; "请输入第一个多项式非零项项数：\n"; cin &gt;&gt; n1; p1 = inputPoly(n1); cout &lt;&lt; "请输入第二个多项式非零项项数：\n"; cin &gt;&gt; n2; p2 = inputPoly(n2); padd = add(p1, p2); pmult = mult(p1, p2); cout &lt;&lt; "和多项式的非零项为：\n"; printPoly(padd); cout &lt;&lt; "乘积多项式的非零项为：\n"; printPoly(pmult); system("pause");&#125; 以k为单位反转抽象链表#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class Node&#123;public: int Data; int Next;&#125;;void input(Node a[], int n)&#123; int i; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; i; cin &gt;&gt; a[i].Data &gt;&gt; a[i].Next; &#125;&#125;int count(Node a[], int h)&#123; int i = 0, p = h; while (p != -1) &#123; i++; p = a[p].Next; &#125; return i;&#125;void reverse(Node a[], int&amp; h, int k)&#123; int n, i = 0; n = count(a, h); int p, h1, h2, t1, t2; p = h1 = h2 = h; t1 = a[p].Next; t2 = a[t1].Next; while (++i) &#123; if (i &gt; n / k) &#123; break; &#125; for (int j = 0; j &lt; k - 1; j++) &#123; a[t1].Next = p; p = t1; t1 = t2; t2 = a[t2].Next; &#125; if (i == 1) &#123; h = p; &#125; else &#123; a[h1].Next = p; h1 = h2; &#125; p = t1; t1 = t2; t2 = a[t2].Next; h2 = p; &#125; a[h1].Next = p;&#125;void print(Node a[], int h)&#123; int p = h; while (p != -1 &amp;&amp; a[p].Next != -1) &#123; cout &lt;&lt; setfill('0') &lt;&lt; setw(5) &lt;&lt; p &lt;&lt; ' ' &lt;&lt; a[p].Data &lt;&lt; ' ' &lt;&lt; setw(5) &lt;&lt; a[p].Next &lt;&lt; '\n'; p = a[p].Next; &#125; if (a[p].Next == -1) &#123; cout &lt;&lt; setfill('0') &lt;&lt; setw(5) &lt;&lt; p &lt;&lt; ' ' &lt;&lt; a[p].Data &lt;&lt; ' ' &lt;&lt; a[p].Next &lt;&lt; '\n'; &#125;&#125;void main()&#123; int head, n, k; Node Memory[100000]; cout &lt;&lt; "请输入头地址、节点总数、反转单位长度：\n"; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; input(Memory, n); reverse(Memory, head, k); cout &lt;&lt; "反转后结果：\n"; print(Memory, head); system("pause");&#125; 判断一组数是否为可能的出栈结果#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class Node&#123;public: int Data; Node* Next;&#125;;void push(Node* &amp;top, int&amp; sum, int a)&#123; Node* temp = new Node; temp-&gt;Next = top; top = temp; top-&gt;Data = a; sum++;&#125;int pop(Node* &amp;top, int&amp; sum)&#123; Node* temp = top; top = top-&gt;Next; temp-&gt;Next = NULL; sum--; return temp-&gt;Data;&#125;int check(int m, int n)&#123; int temp = 0, sum = 0; int x; int result = 1; Node* top = new Node; top-&gt;Next = NULL; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x; if (x &lt; temp) &#123; if (top-&gt;Data != x) &#123; result = 0; &#125; else &#123; pop(top, sum); &#125; continue; &#125; while (++temp != x) &#123; push(top, sum, temp); if (sum &gt; m - 1) &#123; result = 0; break; &#125; &#125; &#125; return result;&#125;void main()&#123; int m, n, k; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; int *result; result = new int[k]; for (int i = 0; i &lt; k; i++) &#123; result[i] = check(m, n); &#125; for (int i = 0; i &lt; k; i++) &#123; switch (result[i]) &#123; case 0:cout &lt;&lt; "NO\n"; break; case 1:cout &lt;&lt; "YES\n"; break; &#125; &#125; system("pause");&#125; 递归法判断树的同构#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class Node&#123;public: char data; int left; int right; int isRoot;&#125;;int input(Node *&amp;a)&#123; int n; int root; char left, right; cin &gt;&gt; n; if (!n) &#123; a = NULL; return -1; &#125; a = new Node[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].data &gt;&gt; left &gt;&gt; right; a[i].isRoot = 1; if (left == '-') &#123; a[i].left = -1; &#125; else &#123; a[i].left = int(left) - 48; &#125; if (right == '-') &#123; a[i].right = -1; &#125; else &#123; a[i].right = int(right) - 48; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i].left != -1) &#123; a[a[i].left].isRoot = 0; &#125; if (a[i].right != -1) &#123; a[a[i].right].isRoot = 0; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i].isRoot) &#123; root = i; &#125; &#125; return root;&#125;int compare(Node* a, Node* b, int aRoot, int bRoot)&#123; if (!a&amp;&amp;!b) &#123; return 1; &#125; else if (!a || !b) &#123; return 0; &#125; else if (aRoot == -1 &amp;&amp; bRoot == -1) &#123; return 1; &#125; else if (aRoot == -1 || bRoot == -1) &#123; return 0; &#125; else if (a[aRoot].data != b[bRoot].data) &#123; return 0; &#125; else if (compare(a, b, a[aRoot].left, b[bRoot].left)) &#123; return compare(a, b, a[aRoot].right, b[bRoot].right); &#125; else if (compare(a, b, a[aRoot].left, b[bRoot].right)) &#123; return compare(a, b, a[aRoot].right, b[bRoot].left); &#125; else &#123; return 0; &#125;&#125;void main()&#123; Node \*a, \*b; int aRoot, bRoot; int result; aRoot = input(a); bRoot = input(b); result = compare(a, b, aRoot, bRoot); if (result == 1) &#123; cout &lt;&lt; "Yes"; &#125; else &#123; cout &lt;&lt; "No"; &#125; system("pause");&#125; 层序遍历打印叶子结点#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class Node&#123;public: int left; int right; int isRoot; int isLeaf;&#125;;class QueueNode&#123;public: int a; QueueNode* next;&#125;;int input(Node *&amp;a)&#123; int n; int root; char left, right; cin &gt;&gt; n; if (!n) &#123; a = NULL; return -1; &#125; a = new Node[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; left &gt;&gt; right; a[i].isRoot = 1; a[i].isLeaf = 1; if (left == '-') &#123; a[i].left = -1; &#125; else &#123; a[i].left = int(left) - int('0'); &#125; if (right == '-') &#123; a[i].right = -1; &#125; else &#123; a[i].right = int(right) - int('0'); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i].left != -1) &#123; a[a[i].left].isRoot = 0; a[i].isLeaf = 0; &#125; if (a[i].right != -1) &#123; a[a[i].right].isRoot = 0; a[i].isLeaf = 0; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i].isRoot) &#123; root = i; &#125; &#125; return root;&#125;void enqueue(int a, QueueNode*&amp; rear) &#123; rear-&gt;a = a; rear-&gt;next = new QueueNode; rear = rear-&gt;next; rear-&gt;next = NULL;&#125;int dequeue(QueueNode*&amp; front) &#123; QueueNode* temp = front; front = front-&gt;next; temp-&gt;next = NULL; return temp-&gt;a;&#125;void printLeaf(Node *tree, int root) &#123; QueueNode \*front, \*rear; int a, flag = 0; front = rear = new QueueNode; rear-&gt;next = NULL; enqueue(root, rear); while (front != rear) &#123; a = dequeue(front); if (tree[a].isLeaf) &#123; if (!flag) &#123; cout &lt;&lt; a; flag = 1; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; a; &#125; &#125; if (tree[a].left != -1) &#123; enqueue(tree[a].left, rear); &#125; if (tree[a].right != -1) &#123; enqueue(tree[a].right, rear); &#125; &#125;&#125;void main()&#123; Node *tree; int root; root = input(tree); printLeaf(tree, root); system("pause");&#125; 2016年3月]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法（C++）代码练习（基础）]]></title>
    <url>%2Fblog%2F2018%2F03%2F10%2Fe6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-e4-b8-8e-e7-ae-97-e6-b3-95-ef-bc-88c-ef-bc-89-e4-bb-a3-e7-a0-81-e7-bb-83-e4-b9-a0-ef-bc-88-e5-9f-ba-e7-a1-80-ef-bc-89%2F</url>
    <content type="text"><![CDATA[所有代码均由Microsoft Visual Studio 2015编译通过 递推法求sinx#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;float sinx(float x);void main()&#123; float x; cout &lt;&lt; "请输入x："; cin &gt;&gt; x; if (fabs(x) &gt;= 1) &#123; cout &lt;&lt; "x大于等于1，数值非法"; &#125; else &#123; cout &lt;&lt; "sin " &lt;&lt; x &lt;&lt; " = " &lt;&lt; sinx(x); &#125; system("pause");&#125;float sinx(float x)&#123; float term = x, result = x; for (int n = 1;; n++) &#123; term = -term\*x\*x / ((2 * n)*(2 * n + 1)); if (fabs(term)&lt;0.0001) &#123; break; &#125; result += term; &#125; return result;&#125; 递推法输出斐波那契数列前20项#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;void main()&#123; long int f1,f2,f3; f1 = f2 = 1; cout &lt;&lt; setw(10) &lt;&lt; f1 &lt;&lt; setw(10) &lt;&lt; f2; for (int i = 3; i &lt;= 20; i++) &#123; f3 = f1 + f2; cout &lt;&lt; setw(10) &lt;&lt; f3; f1 = f2; f2 = f3; if (i % 5 == 0) &#123; cout &lt;&lt; "\n"; &#125; &#125; system("pause");&#125; 欧几里得算法求两正整数最大公约数#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;void main()&#123; int a, b,a0,b0; int temp; cout &lt;&lt; "请输入两整数的值"; cin &gt;&gt; a &gt;&gt; b; a0 = a, b0 = b; if (a &lt;= 0 || b &lt;= 0) &#123; cout &lt;&lt; "只能计算正整数！\n"; &#125; else &#123; while (a%b != 0) &#123; temp = a%b; a = b; b = temp; &#125; cout &lt;&lt; a0 &lt;&lt; "与" &lt;&lt; b0 &lt;&lt; "的最大公约数为" &lt;&lt; b &lt;&lt; "\n"; &#125; system("pause");&#125; 递推法求n阶乘#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;void main()&#123; int n; int result=1; cout &lt;&lt; "请输入正整数n\n"; cin &gt;&gt; n; if (n &lt;= 0) &#123; cout &lt;&lt; "不是正整数！"; &#125; else &#123; for (; n &gt; 0; n--) &#123; result *= n; &#125; cout &lt;&lt; "n！=" &lt;&lt; result &lt;&lt; "\n"; &#125; system("pause");&#125; 递归法求n阶乘#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int x(int n)&#123; if (n != 0) &#123; return n*x(n - 1); &#125; return 1;&#125;void main()&#123; int n; int result; cout &lt;&lt; "请输入正整数n\n"; cin &gt;&gt; n; if (n &lt;= 0) &#123; cout &lt;&lt; "不是正整数！"; &#125; else &#123; result=x(n); cout &lt;&lt; "n！=" &lt;&lt; result &lt;&lt; "\n"; &#125; system("pause");&#125; 递归法输出斐波那契数列前20项#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int fib(int n)&#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fib(n - 1) + fib(n - 2);&#125;void main()&#123; for (int i = 1; i &lt;= 20; i++) &#123; cout &lt;&lt; setw(10) &lt;&lt; fib(i); if (i % 5 == 0) &#123; cout &lt;&lt; "\n"; &#125; &#125; system("pause");&#125; 汉诺塔问题#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;void hanio(int n ,char a , char b , char c ,int &amp;i)&#123; if (n == 0) &#123; return; &#125; hanio(n - 1, a, c, b, i); cout &lt;&lt; "移动第" &lt;&lt; n &lt;&lt; "个盘 从" &lt;&lt; a &lt;&lt; "柱到" &lt;&lt; c &lt;&lt; "柱\n"; i++; hanio(n - 1, b, a, c, i); return;&#125;void main()&#123; int n, steps=0; cout &lt;&lt; "请输入汉诺塔总盘数："; cin &gt;&gt; n; hanio(n,'A','B','C',steps); cout &lt;&lt; "总步数：" &lt;&lt; steps &lt;&lt; "步\n"; system("pause");&#125; 筛法求3-100以内素数#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;void main()&#123; int prime[49]; for (int i = 0; i &lt; 49; i++) &#123; prime[i] = 3 + 2 * i; &#125; for (int i = 0; i &lt; 4; i++) &#123; if (prime[i]) &#123; for (int j = i + 1; j &lt; 49; j++) &#123; if (prime[j] % prime[i] == 0) &#123; prime[j] = 0; &#125; &#125; &#125; &#125; int j = 0; for (int i = 0; i &lt; 49; i++) &#123; if (prime[i] != 0) &#123; cout &lt;&lt; prime[i] &lt;&lt; setw(10); j++; &#125; if (j != 0 &amp;&amp; j % 5 == 0) &#123; cout &lt;&lt; "\n"; &#125; &#125; system("pause");&#125; 输入成绩并输出成绩低于平均成绩的学生#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 100using namespace std;void main()&#123; float x[N], sum = 0, ave; int i = 0; cout &lt;&lt; "请输入学生成绩，以负数结束\n"; do &#123; cin &gt;&gt; x[i]; sum += x[i]; &#125; while (x[i++] &gt;= 0 &amp;&amp; i &lt; N); if (i == N) &#123; ave = sum / i; &#125; else &#123; ave = (sum - x[--i]) / i; &#125; cout &lt;&lt; "共输入" &lt;&lt; i &lt;&lt; "个学生 平均成绩" &lt;&lt; ave &lt;&lt; "分\n\n"; cout &lt;&lt; "其中低于平均成绩的学生有："; for (int j = 0; j &lt; i; j++) &#123; if (x[j] &lt; ave) &#123; cout &lt;&lt; "第" &lt;&lt; j+1 &lt;&lt; "个学生 " &lt;&lt; x[j] &lt;&lt; "分\n"; &#125; &#125; system("pause");&#125; 打印10层杨辉三角形#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;void main()&#123; int a[N][N]; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (j == 0 || j == i) &#123; a[i][j] = 1; &#125; else &#123; a[i][j] = a[i - 1][j] + a[i - 1][j - 1]; &#125; cout &lt;&lt; a[i][j] &lt;&lt; setw(10); &#125; cout &lt;&lt; "\n"; &#125; system("pause");&#125; 2016年3月]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法（C++）代码练习（查找）]]></title>
    <url>%2Fblog%2F2018%2F03%2F10%2Fe6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-e4-b8-8e-e7-ae-97-e6-b3-95-ef-bc-88c-ef-bc-89-e4-bb-a3-e7-a0-81-e7-bb-83-e4-b9-a0-ef-bc-88-e6-9f-a5-e6-89-be-ef-bc-89%2F</url>
    <content type="text"><![CDATA[所有代码均由Microsoft Visual Studio 2015编译通过 20个随机数的数组中的顺序查找#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define N 20using namespace std;void Order_Search(int a[], int n)&#123; for (int i=0;i&lt;N;i++)&#123; if (a[i] == n) &#123; cout &lt;&lt; "在第" &lt;&lt;i+1 &lt;&lt; "个位置上找到" &lt;&lt; n &lt;&lt; "\n"; return; &#125; &#125; cout &lt;&lt; "未找到\n"; return;&#125;void main()&#123; int a[N],n; srand(unsigned(time)); for (int i = 0; i &lt; N; i++) &#123; a[i] = rand(); cout &lt;&lt; a[i] &lt;&lt; '\t'; &#125; cout &lt;&lt; "\n请输入要查找的数："; cin &gt;&gt; n; cout &lt;&lt; "\n\n"; Order_Search(a,n); system("pause");&#125; 20个随机数的数组中的二分查找#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define N 20using namespace std;void Bubble_Sort(int a[])&#123; int temp, flag = 1; for (int j = N - 1; j &gt; 0 &amp;&amp; flag; j--) &#123; flag = 0; for (int i = 0; i &lt; j; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; flag = 1; &#125; &#125; &#125;&#125;void Binary_Search(int a[], int n)&#123; int left = 0, right = N, mid; while (left &lt;= right) &#123; mid = (left + right) / 2; if (a[mid] &gt; n) &#123; right = mid-1; &#125; else if (a[mid] &lt; n) &#123; left = mid+1; &#125; else &#123; cout &lt;&lt; "在升序第" &lt;&lt; mid + 1 &lt;&lt; "个位置上找到" &lt;&lt; n &lt;&lt; "\n"; return; &#125; &#125; cout &lt;&lt; "未找到\n"; return;&#125;void main()&#123; int a[N], n; srand(unsigned(time)); for (int i = 0; i &lt; N; i++) &#123; a[i] = rand(); cout &lt;&lt; a[i] &lt;&lt; '\t'; &#125; cout &lt;&lt; "\n请输入要查找的数："; cin &gt;&gt; n; cout &lt;&lt; "\n\n"; Bubble_Sort(a); Binary_Search(a, n); system("pause");&#125; 使用平方探测的散列表的插入、删除、查找#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 43#define I -100000#define HOLD 100000using namespace std;int Hash(int key)&#123; return key%N;&#125;int findPos(int key, int table[])&#123; int n = 0; int pos, ipos; pos = ipos = Hash(key); while (table[pos]!=I &amp;&amp; table[pos] != key) &#123; if (++n % 2) &#123; pos = ipos + (n + 1) / 2 * (n + 1) / 2; while (pos &gt;= N) &#123; pos -= N; &#125; &#125; else &#123; pos = ipos - (n / 2)*(n / 2); while (pos &lt; 0) &#123; pos += N; &#125; &#125; &#125; return pos;&#125;int contain(int key, int table[])&#123; int pos=findPos(key, table); if (table[pos]==I) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;void insert(int key, int table[])&#123; int pos = findPos(key, table); table[pos] = key;&#125;int remove(int key, int table[])&#123; int pos = findPos(key, table); if (table[pos]==I) &#123; return 0; &#125; else &#123; table[pos] = HOLD; return 1; &#125;&#125;void main()&#123; int n, a, res; int hashTable[N]; for (int i = 0; i &lt; N; i++) &#123; hashTable[i] = I; &#125; cout &lt;&lt; "请输入要插入的数据个数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入数据：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; insert(a, hashTable); &#125; cout &lt;&lt; "请输入要删除的数据个数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入要删除的数据：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; res = remove(a, hashTable); cout &lt;&lt; (res ? "删除成功\n" : "查无此数\n"); &#125; cout &lt;&lt; "请输入要查找的数据个数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入要查找的数据：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; res = contain(a, hashTable); cout &lt;&lt; (res ? "已找到\n" : "未找到\n"); &#125; system("pause");&#125; 2016年3月]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法（C++）代码练习（树）]]></title>
    <url>%2Fblog%2F2018%2F03%2F10%2Fe6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-e4-b8-8e-e7-ae-97-e6-b3-95-ef-bc-88c-ef-bc-89-e4-bb-a3-e7-a0-81-e7-bb-83-e4-b9-a0-ef-bc-88-e6-a0-91-ef-bc-89%2F</url>
    <content type="text"><![CDATA[所有代码均由Microsoft Visual Studio 2015编译通过 递归法实现二叉树的三种遍历 #include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class treeNode&#123;public: int data; treeNode* left; treeNode* right;&#125;;int max(int a, int b)&#123; return (a &gt; b ? a : b);&#125;int height(treeNode* root)&#123; if (!root) &#123; return -1; &#125; else &#123; return max(height(root-&gt;left), height(root-&gt;right)) + 1; &#125;&#125;void singleRotateLeft(treeNode*&amp; root)&#123; treeNode* temp = root; root = root-&gt;left; temp-&gt;left = root-&gt;right; root-&gt;right = temp;&#125;void singleRotateRight(treeNode*&amp; root)&#123; treeNode* temp = root; root = root-&gt;right; temp-&gt;right = root-&gt;left; root-&gt;left = temp;&#125;void doubleRotateLeft(treeNode*&amp; root)&#123; singleRotateRight(root-&gt;left); singleRotateLeft(root);&#125;void doubleRotateRight(treeNode*&amp; root)&#123; singleRotateLeft(root-&gt;right); singleRotateRight(root);&#125;treeNode* findMin(treeNode* root)&#123; if (!root) &#123; return NULL; &#125; while (root-&gt;left) &#123; root = root-&gt;left; &#125; return root;&#125;treeNode* findMax(treeNode* root)&#123; if (!root) &#123; return NULL; &#125; while (root-&gt;right) &#123; root = root-&gt;right; &#125; return root;&#125;int incertNode(int a, treeNode*&amp; root)&#123; int res; if (!root) &#123; root = new treeNode; root-&gt;data = a; root-&gt;left = root-&gt;right = NULL; return 1; &#125; if (a &lt; root-&gt;data) &#123; res = incertNode(a, root-&gt;left); if (height(root-&gt;left) - height(root-&gt;right) &gt;= 2) &#123; if (a &lt; root-&gt;left-&gt;data) &#123; singleRotateLeft(root); &#125; else &#123; doubleRotateLeft(root); &#125; &#125; return res; &#125; else if (a &gt; root-&gt;data) &#123; res = incertNode(a, root-&gt;right); if (height(root-&gt;right) - height(root-&gt;left) &gt;= 2) &#123; if (a &gt; root-&gt;right-&gt;data) &#123; singleRotateRight(root); &#125; else &#123; doubleRotateRight(root); &#125; &#125; return res; &#125; else &#123; return 0; &#125;&#125;void preorderTraverse(treeNode* root)&#123; if (root) &#123; cout &lt;&lt; root-&gt;data; preorderTraverse(root-&gt;left); preorderTraverse(root-&gt;right); &#125;&#125;void inorderTraverse(treeNode* root)&#123; if (root) &#123; inorderTraverse(root-&gt;left); cout &lt;&lt; root-&gt;data; inorderTraverse(root-&gt;right); &#125;&#125;void postorderTraverse(treeNode* root)&#123; if (root) &#123; postorderTraverse(root-&gt;left); postorderTraverse(root-&gt;right); cout &lt;&lt; root-&gt;data; &#125;&#125;void main()&#123; int n, a, res; treeNode* root = NULL; cout &lt;&lt; "请输入二叉树结点总数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入结点数字：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; res = incertNode(a, root); cout &lt;&lt; (res ? "插入成功\n" : "数据重复\n"); &#125; cout &lt;&lt; "二叉树构建完毕，高度为：" &lt;&lt; height(root) &lt;&lt; '\n'; cout &lt;&lt; "\n前序遍历：\n"; preorderTraverse(root); cout &lt;&lt; "\n中序遍历：\n"; inorderTraverse(root); cout &lt;&lt; "\n后序遍历：\n"; postorderTraverse(root); system("pause");&#125; 非递归法实现二叉树的中序遍历#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class treeNode&#123;public: int data; treeNode* left; treeNode* right;&#125;;class Node&#123;public: treeNode* p; Node* next;&#125;;void push(Node* &amp;top, treeNode* p)&#123; Node* temp = new Node; temp-&gt;next = top; top = temp; top-&gt;p = p;&#125;treeNode* pop(Node* &amp;top)&#123; Node* temp = top; top = top-&gt;next; temp-&gt;next = NULL; return temp-&gt;p;&#125;int max(int a, int b)&#123; return (a &gt; b ? a : b);&#125;int height(treeNode* root)&#123; if (!root) &#123; return -1; &#125; else &#123; return max(height(root-&gt;left), height(root-&gt;right)) + 1; &#125;&#125;void singleRotateLeft(treeNode*&amp; root)&#123; treeNode* temp = root; root = root-&gt;left; temp-&gt;left = root-&gt;right; root-&gt;right = temp;&#125;void singleRotateRight(treeNode*&amp; root)&#123; treeNode* temp = root; root = root-&gt;right; temp-&gt;right = root-&gt;left; root-&gt;left = temp;&#125;void doubleRotateLeft(treeNode*&amp; root)&#123; singleRotateRight(root-&gt;left); singleRotateLeft(root);&#125;void doubleRotateRight(treeNode*&amp; root)&#123; singleRotateLeft(root-&gt;right); singleRotateRight(root);&#125;treeNode* findMin(treeNode* root)&#123; if (!root) &#123; return NULL; &#125; while (root-&gt;left) &#123; root = root-&gt;left; &#125; return root;&#125;treeNode* findMax(treeNode* root)&#123; if (!root) &#123; return NULL; &#125; while (root-&gt;right) &#123; root = root-&gt;right; &#125; return root;&#125;int incertNode(int a, treeNode*&amp; root)&#123; int res; if (!root) &#123; root = new treeNode; root-&gt;data = a; root-&gt;left = root-&gt;right = NULL; return 1; &#125; if (a &lt; root-&gt;data) &#123; res = incertNode(a, root-&gt;left); if (height(root-&gt;left) - height(root-&gt;right) &gt;= 2) &#123; if (a &lt; root-&gt;left-&gt;data) &#123; singleRotateLeft(root); &#125; else &#123; doubleRotateLeft(root); &#125; &#125; return res; &#125; else if (a &gt; root-&gt;data) &#123; res = incertNode(a, root-&gt;right); if (height(root-&gt;right) - height(root-&gt;left) &gt;= 2) &#123; if (a &gt; root-&gt;right-&gt;data) &#123; singleRotateRight(root); &#125; else &#123; doubleRotateRight(root); &#125; &#125; return res; &#125; else &#123; return 0; &#125;&#125;void inorderTraverse(treeNode* root)&#123; Node* stack = new Node; stack-&gt;next = NULL; while (root||stack-&gt;next) &#123; while (root) &#123; push(stack, root); root = root-&gt;left; &#125; root = pop(stack); cout &lt;&lt; root-&gt;data; root = root-&gt;right; &#125;&#125;void main()&#123; int n, a, res; treeNode* root = NULL; cout &lt;&lt; "请输入二叉树结点总数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入结点数字：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; res = incertNode(a, root); cout &lt;&lt; (res ? "插入成功\n" : "数据重复\n"); &#125; cout &lt;&lt; "二叉树构建完毕，高度为：" &lt;&lt; height(root) &lt;&lt; '\n'; cout &lt;&lt; "\n中序遍历：\n"; inorderTraverse(root); system("pause");&#125; 平衡二叉树的插入、删除、查找 #include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class treeNode&#123;public: int data; treeNode* left; treeNode* right;&#125;;int max(int a, int b)&#123; return (a &gt; b ? a : b);&#125;int height(treeNode* root)&#123; if (!root) &#123; return -1; &#125; else &#123; return max(height(root-&gt;left), height(root-&gt;right)) + 1; &#125;&#125;void singleRotateLeft(treeNode*&amp; root)&#123; treeNode* temp = root; root = root-&gt;left; temp-&gt;left = root-&gt;right; root-&gt;right = temp;&#125;void singleRotateRight(treeNode*&amp; root)&#123; treeNode* temp = root; root = root-&gt;right; temp-&gt;right = root-&gt;left; root-&gt;left = temp;&#125;void doubleRotateLeft(treeNode*&amp; root)&#123; singleRotateRight(root-&gt;left); singleRotateLeft(root);&#125;void doubleRotateRight(treeNode*&amp; root)&#123; singleRotateLeft(root-&gt;right); singleRotateRight(root);&#125;treeNode* find(int a, treeNode* root)&#123; if (!root) &#123; return NULL; &#125; if (a &lt; root-&gt;data) &#123; return find(a, root-&gt;left); &#125; else if (a &gt; root-&gt;data) &#123; return find(a, root-&gt;right); &#125; else &#123; return root; &#125;&#125;treeNode* findMin(treeNode* root)&#123; if (!root) &#123; return NULL; &#125; while (root-&gt;left) &#123; root = root-&gt;left; &#125; return root;&#125;treeNode* findMax(treeNode* root)&#123; if (!root) &#123; return NULL; &#125; while (root-&gt;right) &#123; root = root-&gt;right; &#125; return root;&#125;int incertNode(int a, treeNode*&amp; root)&#123; int res; if (!root) &#123; root = new treeNode; root-&gt;data = a; root-&gt;left = root-&gt;right = NULL; return 1; &#125; if (a &lt; root-&gt;data) &#123; res = incertNode(a, root-&gt;left); if (height(root-&gt;left) - height(root-&gt;right) &gt;= 2) &#123; if (a &lt; root-&gt;left-&gt;data) &#123; singleRotateLeft(root); &#125; else &#123; doubleRotateLeft(root); &#125; &#125; return res; &#125; else if (a &gt; root-&gt;data) &#123; res = incertNode(a, root-&gt;right); if (height(root-&gt;right) - height(root-&gt;left) &gt;= 2) &#123; if (a &gt; root-&gt;right-&gt;data) &#123; singleRotateRight(root); &#125; else &#123; doubleRotateRight(root); &#125; &#125; return res; &#125; else &#123; return 0; &#125;&#125;int deleteNode(int a, treeNode*&amp; root)&#123; if (!root) &#123; return 0; &#125; if (a &lt; root-&gt;data) &#123; return deleteNode(a, root-&gt;left); &#125; else if (a &gt; root-&gt;data) &#123; return deleteNode(a, root-&gt;right); &#125; else if (root-&gt;left&amp;&amp;root-&gt;right) &#123; treeNode* p; if (height(root-&gt;left) &lt; height(root-&gt;right)) &#123; p = findMin(root-&gt;right); root-&gt;data = p-&gt;data; return deleteNode(p-&gt;data, root-&gt;right); &#125; else &#123; p = findMax(root-&gt;left); root-&gt;data = p-&gt;data; return deleteNode(p-&gt;data, root-&gt;left); &#125; &#125; else if (root-&gt;left || root-&gt;right) &#123; treeNode* p = (root-&gt;left ? root-&gt;left : root-&gt;right); delete root; root = p; return 1; &#125; else &#123; delete root; root = NULL; return 1; &#125;&#125;void main()&#123; int n, a, res; treeNode* root = NULL, *resP = NULL; cout &lt;&lt; "请输入二叉树结点总数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入结点数字：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; res = incertNode(a, root); cout &lt;&lt; (res ? "插入成功\n" : "数据重复\n"); &#125; cout &lt;&lt; "二叉树构建完毕，高度为：" &lt;&lt; height(root) &lt;&lt; '\n'; cout &lt;&lt; "请输入要删除的结点个数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入结点数字：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; res = deleteNode(a, root); cout &lt;&lt; (res ? "删除成功\n" : "查无此数\n"); &#125; cout &lt;&lt; "删除完毕，高度为：" &lt;&lt; height(root) &lt;&lt; '\n'; cout &lt;&lt; "请输入要查找的结点个数：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入结点数字：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; resP = find(a, root); cout &lt;&lt; (resP ? "已找到\n" : "未找到\n"); &#125; system("pause");&#125; 最小堆的插入与删除#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 100#define MAX 100000using namespace std;class Heap&#123;public: int size; int a[N];&#125;;void checkOdd(Heap&amp; minHeap)&#123; if (!(minHeap.size % 2)) &#123; minHeap.a[minHeap.size + 1] = MAX; &#125;&#125;void incertMinHeap(int a, Heap&amp; minHeap)&#123; int hole = ++minHeap.size; while (hole != 1 &amp;&amp; a &lt; minHeap.a[hole / 2]) &#123; minHeap.a[hole] = minHeap.a[hole / 2]; hole = hole / 2; &#125; minHeap.a[hole] = a; checkOdd(minHeap);&#125;int deleteMin(Heap&amp; minHeap)&#123; int min = minHeap.a[1]; int hole = 1; while (hole &lt;= minHeap.size / 2 &amp;&amp; (minHeap.a[minHeap.size] &gt; minHeap.a[hole * 2 + 1] || minHeap.a[minHeap.size] &gt; minHeap.a[hole * 2])) &#123; if (minHeap.a[hole * 2 + 1] &lt; minHeap.a[hole * 2]) &#123; minHeap.a[hole] = minHeap.a[hole * 2 + 1]; hole = hole * 2 + 1; &#125; else &#123; minHeap.a[hole] = minHeap.a[hole * 2]; hole = hole * 2; &#125; &#125; minHeap.a[hole] = minHeap.a[minHeap.size]; minHeap.size--; checkOdd(minHeap); return min;&#125;void main()&#123; int n, a; Heap minHeap; minHeap.size = 0; cout &lt;&lt; "请输入最小堆结点个数（100以内）：\n"; cin &gt;&gt; n; cout &lt;&lt; "请依次输入结点数字：\n"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; incertMinHeap(a, minHeap); cout &lt;&lt; "已插入第" &lt;&lt; i + 1 &lt;&lt; "个数\n"; &#125; cout &lt;&lt; "请输入要查看从小到大排列的前几个数：\n"; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; a = deleteMin(minHeap); cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "小的数为：" &lt;&lt; a &lt;&lt; "\n"; &#125; system("pause");&#125; 2016年3月]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法（C++）代码练习（排序）]]></title>
    <url>%2Fblog%2F2018%2F03%2F10%2Fe6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-e4-b8-8e-e7-ae-97-e6-b3-95-ef-bc-88c-ef-bc-89-e4-bb-a3-e7-a0-81-e7-bb-83-e4-b9-a0-ef-bc-88-e6-8e-92-e5-ba-8f-ef-bc-89%2F</url>
    <content type="text"><![CDATA[所有代码均由Microsoft Visual Studio 2015编译通过 插入排序（Insertion_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;void Insertion_Sort(int a[], int n)&#123; int temp; for (int i = 1; i &lt; n; i++) &#123; int j = i - 1; temp = a[i]; while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = temp; &#125;&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数：\n"; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Insertion_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 希尔排序（Shell_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;void Shell_Sort(int a[], int n)&#123; int temp; for (int gap = n / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; n; i += gap) &#123; int j = i - gap; temp = a[i]; while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) &#123; a[j + gap] = a[j]; j -= gap; &#125; a[j + gap] = temp; &#125; &#125;&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数：\n"; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Shell_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 冒泡排序（Bubble_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;void Bubble_Sort(int a[], int n)&#123; int temp, flag = 1; for (int j = n - 1; j &gt; 0 &amp;&amp; flag; j--) &#123; flag = 0; for (int i = 0; i &lt; j; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; flag = 1; &#125; &#125; &#125;&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数："; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Bubble_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 快速排序（Quick_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;void Insertion_Sort(int a[], int n)&#123; int temp; for (int i = 1; i &lt; n; i++) &#123; int j = i - 1; temp = a[i]; while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = temp; &#125;&#125;void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125;int median(int a[], int l, int r)&#123; int c = (l + r) / 2; if (a[l] &gt; a[c]) &#123; swap(a[l], a[c]); &#125; if (a[c] &gt; a[r]) &#123; swap(a[c], a[r]); &#125; if (a[l] &gt; a[c]) &#123; swap(a[l], a[c]); &#125; swap(a[c], a[r - 1]); return a[r - 1];&#125;void quickSort(int a[], int left, int right)&#123; if (right - left + 1 &gt; 3) &#123; int pivot = median(a, left, right); int i, j; i = left; j = right - 1; while (1) &#123; while (a[++i] &lt; pivot) &#123;&#125; while (a[--j] &gt; pivot) &#123;&#125; if (i &lt; j) &#123; swap(a[i], a[j]); &#125; else &#123; break; &#125; &#125; swap(a[i], a[right - 1]); quickSort(a, left, i - 1); quickSort(a, i + 1, right); &#125; else &#123; Insertion_Sort(a + left, right - left + 1); &#125;&#125;void Quick_Sort(int a[], int n)&#123; quickSort(a, 0, n - 1);&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数：\n"; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Quick_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 选择排序（Select_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;void Select_Sort(int a[], int n)&#123; int min, temp; for (int i = 0; i &lt; n - 1; i++) &#123; min = i; for (int j = i + 1; j &lt; n; j++) &#123; if (a[j] &lt; a[min]) &#123; min = j; &#125; &#125; temp = a[i]; a[i] = a[min]; a[min] = temp; &#125;&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数："; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Select_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 堆排序（Heap_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;class Heap&#123;public: int size; int* a; Heap() &#123; size = 0; &#125;&#125;;void incertMaxHeap(int a, Heap&amp; maxHeap)&#123; int hole = maxHeap.size++; while (hole != 0 &amp;&amp; a &gt; maxHeap.a[(hole - 1) / 2]) &#123; maxHeap.a[hole] = maxHeap.a[(hole - 1) / 2]; hole = (hole - 1) / 2; &#125; maxHeap.a[hole] = a;&#125;void moveMaxRear(Heap&amp; maxHeap)&#123; int max = maxHeap.a[0]; int hole = 0; while (hole &lt;= maxHeap.size / 2 - 1 &amp;&amp; (maxHeap.a[maxHeap.size - 1] &lt; maxHeap.a[hole * 2 + 1] || maxHeap.a[maxHeap.size - 1] &lt; maxHeap.a[hole * 2 + 2])) &#123; if (maxHeap.a[hole * 2 + 2] &gt; maxHeap.a[hole * 2 + 1]) &#123; maxHeap.a[hole] = maxHeap.a[hole * 2 + 2]; hole = hole * 2 + 2; &#125; else &#123; maxHeap.a[hole] = maxHeap.a[hole * 2 + 1]; hole = hole * 2 + 1; &#125; &#125; if (maxHeap.size % 2 == 0 &amp;&amp; hole == maxHeap.size) &#123; maxHeap.a[maxHeap.size] = maxHeap.a[(hole - 1) / 2]; hole = (hole - 1) / 2; &#125; maxHeap.a[hole] = maxHeap.a[maxHeap.size - 1]; maxHeap.size--; maxHeap.a[maxHeap.size] = max;&#125;void Heap_Sort(int a[], int n)&#123; Heap maxHeap; maxHeap.a = a; for (int i = 0; i &lt; n; i++) &#123; incertMaxHeap(a[i], maxHeap); &#125; for (int i = 0; i &lt; n; i++) &#123; moveMaxRear(maxHeap); &#125;&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数：\n"; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Heap_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 归并排序（Merge_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10using namespace std;void merge(int obj[], int src[], int left, int right, int rEnd)&#123; int lEnd = right - 1; int i = left; while (left &lt;= lEnd&amp;&amp;right &lt;= rEnd) &#123; if (src[left] &lt;= src[right]) &#123; obj[i++] = src[left++]; &#125; else &#123; obj[i++] = src[right++]; &#125; &#125; while (left &lt;= lEnd) &#123; obj[i++] = src[left++]; &#125; while (right &lt;= rEnd) &#123; obj[i++] = src[right++]; &#125;&#125;void mergeSort(int obj[],int src[],int left,int right)&#123; if (left &gt;= right) &#123; return; &#125; int center = (left + right) / 2; mergeSort(src, obj, left, center); mergeSort(src, obj, center + 1, right); merge(obj, src, left, center + 1, right);&#125;void Merge_Sort(int a[], int n)&#123; int* temp = new int[n]; for (int i = 0; i &lt; n; i++) &#123; temp[i] = a[i]; &#125; mergeSort(a, temp, 0, n - 1);&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数：\n"; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Merge_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 桶排序（Bucket_Sort）#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 10#define SIZE 100using namespace std;class listNode&#123;public: int data; listNode* next; listNode() &#123; next = NULL; &#125;&#125;;void addNode(listNode&amp; node, int n)&#123; listNode* p = new listNode; p-&gt;data = n; p-&gt;next = node.next; node.next = p;&#125;void readNode(listNode bucket[], int a[])&#123; int j = 0; for (int i = 0; i &lt; SIZE; i++) &#123; listNode* p = bucket[i].next; while (p) &#123; a[j++] = p-&gt;data; p = p-&gt;next; &#125; &#125;&#125;void Bucket_Sort(int a[], int n)&#123; listNode bucket[SIZE]; for (int i = 0; i &lt; n; i++) &#123; addNode(bucket[a[i]], a[i]); &#125; readNode(bucket, a);&#125;void main()&#123; int a[N]; cout &lt;&lt; "请输入要排序的" &lt;&lt; N &lt;&lt; "个整数(0-99之间)：\n"; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; Bucket_Sort(a, N); cout &lt;&lt; "排序后："; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; system("pause");&#125; 2016年3月]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法（C++）代码练习（图）]]></title>
    <url>%2Fblog%2F2017%2F11%2F27%2Fe6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-e4-b8-8e-e7-ae-97-e6-b3-95-ef-bc-88c-ef-bc-89-e4-bb-a3-e7-a0-81-e7-bb-83-e4-b9-a0%2F</url>
    <content type="text"><![CDATA[所有代码均由Microsoft Visual Studio 2015编译通过 图的遍历DFS和BFS#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 16using namespace std;class listNode&#123;public: int data; listNode* next;&#125;;class QueueNode&#123;public: int a; QueueNode* next;&#125;;void enqueue(int a, QueueNode*&amp; rear) &#123; rear-&gt;a = a; rear-&gt;next = new QueueNode; rear = rear-&gt;next; rear-&gt;next = NULL;&#125;int dequeue(QueueNode*&amp; front) &#123; QueueNode* temp = front; front = front-&gt;next; temp-&gt;next = NULL; return temp-&gt;a;&#125;void inputLesson(listNode* head[])&#123; head[0] = NULL; head[1] = new listNode; head[1]-&gt;data = 3; head[1]-&gt;next = NULL; head[2] = new listNode; head[2]-&gt;data = 3; head[2]-&gt;next = new listNode; head[2]-&gt;next-&gt;data = 13; head[2]-&gt;next-&gt;next = NULL; head[3] = new listNode; head[3]-&gt;data = 7; head[3]-&gt;next = NULL; head[4] = new listNode; head[4]-&gt;data = 5; head[4]-&gt;next = NULL; head[5] = new listNode; head[5]-&gt;data = 6; head[5]-&gt;next = NULL; head[6] = new listNode; head[6]-&gt;data = 15; head[6]-&gt;next = NULL; head[7] = new listNode; head[7]-&gt;data = 10; head[7]-&gt;next = new listNode; head[7]-&gt;next-&gt;data = 11; head[7]-&gt;next-&gt;next = new listNode; head[7]-&gt;next-&gt;next-&gt;data = 12; head[7]-&gt;next-&gt;next-&gt;next = NULL; head[8] = new listNode; head[8]-&gt;data = 9; head[8]-&gt;next = NULL; head[9] = new listNode; head[9]-&gt;data = 10; head[9]-&gt;next = new listNode; head[9]-&gt;next-&gt;data = 11; head[9]-&gt;next-&gt;next = NULL; head[10] = new listNode; head[10]-&gt;data = 14; head[10]-&gt;next = NULL; head[11] = NULL; head[12] = NULL; head[13] = NULL; head[14] = NULL; head[15] = NULL;&#125;void DFS(listNode* list[], int index, int visited[])&#123; listNode* p; if (visited[index]) &#123; return; &#125; cout &lt;&lt; index; visited[index] = 1; p = list[index]; while (p) &#123; DFS(list, p-&gt;data, visited); p = p-&gt;next; &#125;&#125;void BFS(listNode* list[], int index, int visited[])&#123; int v; listNode* p; QueueNode* front,* rear; front = rear = new QueueNode; rear-&gt;next = NULL; enqueue(index, rear); visited[index] = 1; while (front != rear) &#123; v = dequeue(front); cout &lt;&lt; v; p = list[v]; while (p) &#123; if (!(visited[p-&gt;data])) &#123; enqueue(p-&gt;data, rear); visited[p-&gt;data] = 1; &#125; p = p-&gt;next; &#125; &#125;&#125;void resetVisited(int visited[])&#123; for (int i = 0; i &lt; N; i++) &#123; visited[i] = 0; &#125;&#125;void main()&#123; listNode* list[N]; int n; int visited[N]; inputLesson(list); cout &lt;&lt; "请输入深度优先搜索起始点序号：\n"; cin &gt;&gt; n; resetVisited(visited); DFS(list, n, visited); cout &lt;&lt; '\n'; cout &lt;&lt; "请输入广度优先搜索起始点序号：\n"; cin &gt;&gt; n; resetVisited(visited); BFS(list, n, visited); cout &lt;&lt; '\n'; system("pause");&#125; 最小生成树Prim算法#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 8#define MAX 100000using namespace std;class AdjList&#123;public: int data; int dist; AdjList* next; AdjList() &#123; next = NULL; &#125;&#125;;class Vertex&#123;public: int id; AdjList* adj; int dist; int visited; int path; Vertex() &#123; adj = NULL; path = 0; visited = 0; dist = MAX; &#125;&#125;;class Edge&#123;public: int v; int w; void printEdge() &#123; cout &lt;&lt; v &lt;&lt; '-' &lt;&lt; w &lt;&lt; "\n"; &#125;&#125;;class Heap&#123;public: int size; Vertex a[N];&#125;;void checkOdd(Heap&amp; minHeap)&#123; if (!(minHeap.size % 2)) &#123; minHeap.a[minHeap.size + 1].dist = MAX; &#125;&#125;void incertMinHeap(Vertex v, Heap&amp; minHeap)&#123; int hole = ++minHeap.size; while (hole != 1 &amp;&amp; v.dist &lt; minHeap.a[hole / 2].dist) &#123; minHeap.a[hole] = minHeap.a[hole / 2]; hole = hole / 2; &#125; minHeap.a[hole] = v; checkOdd(minHeap);&#125;Vertex deleteMin(Heap&amp; minHeap)&#123; Vertex min = minHeap.a[1]; int hole = 1; while (hole &lt;= minHeap.size / 2 &amp;&amp; (minHeap.a[minHeap.size].dist &gt; minHeap.a[hole * 2 + 1].dist || minHeap.a[minHeap.size].dist &gt; minHeap.a[hole * 2].dist)) &#123; if (minHeap.a[hole * 2 + 1].dist &lt; minHeap.a[hole * 2].dist) &#123; minHeap.a[hole] = minHeap.a[hole * 2 + 1]; hole = hole * 2 + 1; &#125; else &#123; minHeap.a[hole] = minHeap.a[hole * 2]; hole = hole * 2; &#125; &#125; minHeap.a[hole] = minHeap.a[minHeap.size]; minHeap.size--; checkOdd(minHeap); return min;&#125;void input(Vertex &amp;v, int data, int dist)&#123; AdjList*&amp; p = v.adj; if (data == 0 &amp;&amp; dist == 0) &#123; p = NULL; return; &#125; if (!p) &#123; p = new AdjList; p-&gt;data = data; p-&gt;dist = dist; &#125; else &#123; AdjList* temp = p; while (p-&gt;next) &#123; p = p-&gt;next; &#125; p-&gt;next = new AdjList; p-&gt;next-&gt;data = data; p-&gt;next-&gt;dist = dist; p = temp; &#125;&#125;void inputSample(Vertex v[])&#123; for (int i = 0; i &lt; N; i++) &#123; v[i].id = i; &#125; input(v[1], 2, 2); input(v[1], 3, 4); input(v[1], 4, 1); input(v[2], 1, 2); input(v[2], 4, 3); input(v[2], 5, 10); input(v[3], 1, 4); input(v[3], 4, 2); input(v[3], 6, 5); input(v[4], 1, 1); input(v[4], 2, 3); input(v[4], 3, 2); input(v[4], 5, 7); input(v[4], 6, 8); input(v[4], 7, 4); input(v[5], 2, 10); input(v[5], 4, 7); input(v[5], 7, 6); input(v[6], 3, 5); input(v[6], 4, 8); input(v[6], 7, 1); input(v[7], 4, 4); input(v[7], 5, 6); input(v[7], 6, 1);&#125;void Prim(Vertex &amp;s, Vertex g[], Edge MST[])&#123; int i = 0; Vertex v; AdjList* p; Heap minHeap; minHeap.size = 0; s.dist = 0; incertMinHeap(s, minHeap); while (minHeap.size) &#123; v = deleteMin(minHeap); while (g[v.id].visited) &#123; if (!minHeap.size) &#123; return; &#125; v = deleteMin(minHeap); &#125; g[v.id].visited = 1; g[v.id].dist = 0; if (v.path) &#123; i++; MST[i].v = v.path; MST[i].w = v.id; &#125; p = v.adj; while (p) &#123; if (g[p-&gt;data].visited == 0 &amp;&amp; p-&gt;dist &lt; g[p-&gt;data].dist) &#123; g[p-&gt;data].dist = p-&gt;dist ; g[p-&gt;data].path = v.id; incertMinHeap(g[p-&gt;data], minHeap); &#125; p = p-&gt;next; &#125; &#125;&#125;void check(Vertex v[])&#123; AdjList* p; for (int i = 1; i &lt; N; i++) &#123; cout &lt;&lt; i &lt;&lt; '\n'; p = v[i].adj; while (p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; ' ' &lt;&lt; p-&gt;dist &lt;&lt; ' ' &lt;&lt; p-&gt;next &lt;&lt; '\n'; p = p-&gt;next; &#125; &#125; system("pause");&#125;void main()&#123;Vertex v[N];Edge MST[N - 1];int n;inputSample(v);cout &lt;&lt; "请输入源点序号：\n";cin &gt;&gt; n;Prim(v[n], v, MST);cout &lt;&lt; "最小生成树为：\n";for (int i = 1; i &lt; N - 1; i++)&#123; MST[i].printEdge();&#125;system("pause");&#125; 最小生成树Kruskal算法#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 8#define MAX 100000using namespace std;class AdjList&#123;public: int data; int dist; AdjList* next; AdjList() &#123; next = NULL; &#125;&#125;;class Vertex&#123;public: int id; AdjList* adj; int root; int visited;```Vertex() &#123; adj = NULL; root = -1; visited = 0;&#125;```&#125;;class Edge&#123;public: int v; int w; int l; Edge(int v = 0, int w = 0, int l = 0) :v(v), w(w), l(l) &#123;&#125; void printEdge() &#123; cout &lt;&lt; v &lt;&lt; '-' &lt;&lt; w &lt;&lt; "\n"; &#125;&#125;;class Heap&#123;public: int size; Edge a[N*(N - 1)]; Heap() &#123; size = 0; &#125;&#125;;void checkOdd(Heap&amp; minHeap)&#123; if (!(minHeap.size % 2)) &#123; minHeap.a[minHeap.size + 1].l = MAX; &#125;&#125;void incertMinHeap(Edge e, Heap&amp; minHeap)&#123; int hole = ++minHeap.size; while (hole != 1 &amp;&amp; e.l &lt; minHeap.a[hole / 2].l) &#123; minHeap.a[hole] = minHeap.a[hole / 2]; hole = hole / 2; &#125; minHeap.a[hole] = e; checkOdd(minHeap);&#125;Edge deleteMin(Heap&amp; minHeap)&#123; Edge min = minHeap.a[1]; int hole = 1; while (hole &lt;= minHeap.size / 2 &amp;&amp; (minHeap.a[minHeap.size].l &gt; minHeap.a[hole * 2 + 1].l || minHeap.a[minHeap.size].l &gt; minHeap.a[hole * 2].l)) &#123; if (minHeap.a[hole * 2 + 1].l &lt; minHeap.a[hole * 2].l) &#123; minHeap.a[hole] = minHeap.a[hole * 2 + 1]; hole = hole * 2 + 1; &#125; else &#123; minHeap.a[hole] = minHeap.a[hole * 2]; hole = hole * 2; &#125; &#125; minHeap.a[hole] = minHeap.a[minHeap.size]; minHeap.size--; checkOdd(minHeap); return min;&#125;int find(Vertex v, Vertex g[])&#123; if (v.root == -1) &#123; return v.id; &#125; return find(g[v.root], g);&#125;void unionSet(int r1, int r2, Vertex g[])&#123; g[r2].root = g[r1].id;&#125;void input(Vertex &amp;v, int data, int dist)&#123; AdjList*&amp; p = v.adj; if (data == 0 &amp;&amp; dist == 0) &#123; p = NULL; return; &#125; if (!p) &#123; p = new AdjList; p-&gt;data = data; p-&gt;dist = dist; &#125; else &#123; AdjList* temp = p; while (p-&gt;next) &#123; p = p-&gt;next; &#125; p-&gt;next = new AdjList; p-&gt;next-&gt;data = data; p-&gt;next-&gt;dist = dist; p = temp; &#125;&#125;void inputSample(Vertex v[])&#123; for (int i = 0; i &lt; N; i++) &#123; v[i].id = i; &#125; input(v[1], 2, 2); input(v[1], 3, 4); input(v[1], 4, 1); input(v[2], 1, 2); input(v[2], 4, 3); input(v[2], 5, 10); input(v[3], 1, 4); input(v[3], 4, 2); input(v[3], 6, 5); input(v[4], 1, 1); input(v[4], 2, 3); input(v[4], 3, 2); input(v[4], 5, 7); input(v[4], 6, 8); input(v[4], 7, 4); input(v[5], 2, 10); input(v[5], 4, 7); input(v[5], 7, 6); input(v[6], 3, 5); input(v[6], 4, 8); input(v[6], 7, 1); input(v[7], 4, 4); input(v[7], 5, 6); input(v[7], 6, 1);&#125;void Kruskal(Vertex g[], Edge MST[])&#123; Heap minHeap; Edge e; int i = 0; for (int i = 1; i &lt; N; i++) &#123; AdjList* p = g[i].adj; while (p) &#123; if (!g[p-&gt;data].visited) &#123; Edge e(i, p-&gt;data, p-&gt;dist); incertMinHeap(e, minHeap); &#125; p = p-&gt;next; &#125; g[i].visited = 1; &#125; while (minHeap.size) &#123; e = deleteMin(minHeap); int r1 = find(g[e.v], g); int r2 = find(g[e.w], g); if (r1 != r2) &#123; MST[++i] = e; unionSet(r1, r2, g); &#125; &#125;&#125;void main()&#123; Vertex v[N]; Edge MST[N - 1]; inputSample(v); Kruskal(v, MST); cout &lt;&lt; "最小生成树为：\n"; for (int i = 1; i &lt; N - 1; i++) &#123; MST[i].printEdge(); &#125; system("pause");&#125; 基于最小堆的有权图单源最短路径Dijkstra算法#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 16#define MAX 100000using namespace std;class AdjList&#123;public: int data; int dist; AdjList* next; AdjList() &#123; next = NULL; &#125;&#125;;class Vertex&#123;public: int id; AdjList* adj; int dist; int visited; int path; Vertex() &#123; adj = NULL; path = 0; visited = 0; dist = MAX; &#125;&#125;;class Heap&#123;public: int size; Vertex a[N];&#125;;void checkOdd(Heap&amp; minHeap)&#123; if (!(minHeap.size % 2)) &#123; minHeap.a[minHeap.size + 1].dist = MAX; &#125;&#125;void incertMinHeap(Vertex v, Heap&amp; minHeap)&#123; int hole = ++minHeap.size; while (hole != 1 &amp;&amp; v.dist &lt; minHeap.a[hole / 2].dist) &#123; minHeap.a[hole] = minHeap.a[hole / 2]; hole = hole / 2; &#125; minHeap.a[hole] = v; checkOdd(minHeap);&#125;Vertex deleteMin(Heap&amp; minHeap)&#123; Vertex min = minHeap.a[1]; int hole = 1; while (hole &lt;= minHeap.size / 2 &amp;&amp; (minHeap.a[minHeap.size].dist &gt; minHeap.a[hole * 2 + 1].dist || minHeap.a[minHeap.size].dist &gt; minHeap.a[hole * 2].dist)) &#123; if (minHeap.a[hole * 2 + 1].dist &lt; minHeap.a[hole * 2].dist) &#123; minHeap.a[hole] = minHeap.a[hole * 2 + 1]; hole = hole * 2 + 1; &#125; else &#123; minHeap.a[hole] = minHeap.a[hole * 2]; hole = hole * 2; &#125; &#125; minHeap.a[hole] = minHeap.a[minHeap.size]; minHeap.size--; checkOdd(minHeap); return min;&#125;void input(Vertex &amp;v, int data, int dist)&#123; AdjList*&amp; p = v.adj; if (data == 0 &amp;&amp; dist == 0)&#123; p = NULL; return; &#125; if (!p) &#123; p = new AdjList; p-&gt;data = data; p-&gt;dist = dist; &#125; else &#123; AdjList* temp = p; while (p-&gt;next) &#123; p = p-&gt;next; &#125; p-&gt;next = new AdjList; p-&gt;next-&gt;data = data; p-&gt;next-&gt;dist = dist; p = temp; &#125;&#125;void inputSample(Vertex v[])&#123; for (int i = 0; i &lt; N; i++) &#123; v[i].id = i; &#125; input(v[1], 2, 2); input(v[1], 4, 1); input(v[2], 4, 3); input(v[2], 5, 10); input(v[3], 1, 4); input(v[3], 6, 5); input(v[4], 3, 2); input(v[4], 5, 2); input(v[4], 6, 8); input(v[4], 7, 4); input(v[5], 7, 6); input(v[7], 6, 1);&#125;void Dijkstra(Vertex &amp;s, Vertex g[])&#123; Vertex v; AdjList* p; Heap minHeap; minHeap.size = 0; s.dist = 0; incertMinHeap(s, minHeap); while (minHeap.size) &#123; v = deleteMin(minHeap); while (g[v.id].visited) &#123; if (!minHeap.size) &#123; return; &#125; v = deleteMin(minHeap); &#125; g[v.id].visited = 1; p = v.adj; while (p) &#123; if (g[p-&gt;data].visited == 0 &amp;&amp; p-&gt;dist + v.dist &lt; g[p-&gt;data].dist) &#123; g[p-&gt;data].dist = p-&gt;dist + v.dist; g[p-&gt;data].path = v.id; incertMinHeap(g[p-&gt;data], minHeap); &#125; p = p-&gt;next; &#125; &#125;&#125;void printPath(Vertex v, Vertex g[])&#123; if (v.path) &#123; printPath(g[v.path], g); cout &lt;&lt; "-&gt;"; &#125; cout &lt;&lt; v.id;&#125;void check(Vertex v[])&#123; AdjList* p; for (int i = 1; i &lt; N; i++) &#123; cout &lt;&lt; i &lt;&lt; '\n'; p = v[i].adj; while (p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; ' ' &lt;&lt; p-&gt;dist &lt;&lt; ' ' &lt;&lt; p-&gt;next &lt;&lt; '\n'; p = p-&gt;next; &#125; &#125; system("pause");&#125;void main()&#123;Vertex v[N];int n;inputSample(v);cout &lt;&lt; "请输入源点序号：\n";cin &gt;&gt; n;Dijkstra(v[n], v);cout &lt;&lt; "请输入终点序号：\n";cin &gt;&gt; n;cout &lt;&lt; "最短路径为：\n";printPath(v[n], v);cout &lt;&lt; "路径权重：" &lt;&lt; v[n].dist;system("pause");&#125; 邻接表存储有向无环图以队列法拓扑排序#include&lt;iostream&gt;#include&lt;iomanip&gt;#define N 16using namespace std;class listNode&#123;public: int data; listNode* next;&#125;;class QueueNode&#123;public: int a; QueueNode* next;&#125;;void enqueue(int a, QueueNode*&amp; rear) &#123; rear-&gt;a = a; rear-&gt;next = new QueueNode; rear = rear-&gt;next; rear-&gt;next = NULL;&#125;int dequeue(QueueNode*&amp; front) &#123; QueueNode* temp = front; front = front-&gt;next; temp-&gt;next = NULL; return temp-&gt;a;&#125;void inputLesson(listNode* head[])&#123; head[0] = NULL; head[1] = new listNode; head[1]-&gt;data = 3; head[1]-&gt;next = NULL; head[2] = new listNode; head[2]-&gt;data = 3; head[2]-&gt;next = new listNode; head[2]-&gt;next-&gt;data = 13; head[2]-&gt;next-&gt;next = NULL; head[3] = new listNode; head[3]-&gt;data = 7; head[3]-&gt;next = NULL; head[4] = new listNode; head[4]-&gt;data = 5; head[4]-&gt;next = NULL; head[5] = new listNode; head[5]-&gt;data = 6; head[5]-&gt;next = NULL; head[6] = new listNode; head[6]-&gt;data = 15; head[6]-&gt;next = NULL; head[7] = new listNode; head[7]-&gt;data = 10; head[7]-&gt;next = new listNode; head[7]-&gt;next-&gt;data = 11; head[7]-&gt;next-&gt;next = new listNode; head[7]-&gt;next-&gt;next-&gt;data = 12; head[7]-&gt;next-&gt;next-&gt;next = NULL; head[8] = new listNode; head[8]-&gt;data = 9; head[8]-&gt;next = NULL; head[9] = new listNode; head[9]-&gt;data = 10; head[9]-&gt;next = new listNode; head[9]-&gt;next-&gt;data = 11; head[9]-&gt;next-&gt;next = NULL; head[10] = new listNode; head[10]-&gt;data = 14; head[10]-&gt;next = NULL; head[11] = NULL; head[12] = NULL; head[13] = NULL; head[14] = NULL; head[15] = NULL;&#125;void scanAll(listNode* list[], int inDegree[])&#123; for (int i = 1; i &lt; N; i++) &#123; listNode* p; p = list[i]; while (p) &#123; inDegree[p-&gt;data]++; p = p-&gt;next; &#125; &#125;&#125;void topSort(listNode* list[])&#123; int v; int inDegree[N]; listNode* p; QueueNode* front, *rear; front = rear = new QueueNode; for (int i = 0; i &lt; N; i++) &#123; inDegree[i] = 0; &#125; scanAll(list, inDegree); for (int i = 1; i &lt; N; i++) &#123; if (!inDegree[i]) &#123; enqueue(i, rear); &#125; &#125; while (front != rear) &#123; v = dequeue(front); cout &lt;&lt; v &lt;&lt; '\n'; p = list[v]; while (p) &#123; if (!(--inDegree[p-&gt;data])) &#123; enqueue(p-&gt;data, rear); &#125; p = p-&gt;next; &#125; &#125;&#125;void main()&#123; listNode* list[N]; inputLesson(list); topSort(list); system("pause");&#125; 2016年3月]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[24岁小结]]></title>
    <url>%2Fblog%2F2017%2F09%2F24%2F%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E5%86%99%E7%9A%84%E4%BA%8C%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[没错，我今天什么都没有写。 抄一首诗在这里。 赵客缦胡缨，吴钩霜雪明。 银鞍照白马，飒沓如流星。 十步杀一人，千里不留行。 事了拂衣去，深藏身与名。 闲过信陵饮，脱剑膝前横。 将炙啖朱亥，持觞劝侯嬴。 三杯吐然诺，五岳倒为轻。 眼花耳热后，意气素霓生。 救赵挥金槌，邯郸先震惊。 千秋二壮士，煊赫大梁城。 纵死侠骨香，不惭世上英。 谁能书阁下，白首太玄经。 愿厚积而薄发。]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记录一些好用的软件]]></title>
    <url>%2Fblog%2F2017%2F05%2F16%2Fe8-ae-b0-e5-bd-95-e4-b8-80-e4-ba-9b-e5-a5-bd-e7-94-a8-e7-9a-84-e8-bd-af-e4-bb-b6%2F</url>
    <content type="text"><![CDATA[regex match tracer 正则表达式匹配工具 phpstudy 简易快速搭建一个Apache服务器，同时启动PHP+MySQL beyond compare 专业文本比对工具 switchhosts 本地hosts文件快速切换 unlocker 快速解除特定软件进程 takecolor 屏幕取色 ComfyFileRecovery 数据恢复 TeamViewer 远程协助 Typora 本地markdown编辑器 Pixel Ruler 屏幕像素测量 FastStone Capture 屏幕截图]]></content>
      <categories>
        <category>应用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-05 DIARY日报]]></title>
    <url>%2Fblog%2F2017%2F05%2F05%2F2017-05-diary-e6-97-a5-e6-8a-a5%2F</url>
    <content type="text"><![CDATA[2017-05-04SUMMARY今天继续羽毛球，遇见两个好搭档，成功霸场，大臂继续疑似拉伤。最近很安逸，处于舒适区，需要搞点事情。 SKILL TREE健身 羽毛球 2h 核心加强计划 卷腹 15*2 平板支撑 30s*2 STATISTIC 体重 59.05kg 2017-05-05SUMMARY今天没忍住继续打球，手臂终于坚持不住了，今天起必须休养半个月。 SKILL TREE英语 扇贝新闻 3篇 健身 跑步机 2000m 12.5km/h 羽毛球 1.5h 核心加强计划 平板支撑 45s*4 STATISTIC 体重 59.40kg 2017-05-06SUMMARY成功掌握了焊接机械键盘轴的技能，还挺好玩的，需要细心 SKILL TREE其他 学会机械键盘换轴 英语 扇贝新闻 2篇 STATISTIC 体重 59.90kg 2017-05-07SUMMARY吃饱喝足休息一天 SKILL TREE电影 《摔跤吧！爸爸》 烹饪 柠檬黄油煎鸡胸 STATISTIC 体重 59.90kg 2017-05-08SUMMARY发现软件SwitchHosts。公司代码上线CDN试验成功。 SKILL TREE健身 跑步机 2000m 12.5km/h STATISTIC 体重 59.15kg 2017-05-09SUMMARY今天买了想买很久的3DS，一个限量版xbox one s 蓝牙手柄，还有一张闪迪的32G SD卡。最近买的东西有点多，要努力点别浪费时间啊。今天别的事啥事没干，真是废柴啊，要积极利落起来啊。 发现一个很厉害的网盘搜索http://www.panc.cc。 SKILL TREE烹饪 基础版味噌汤 STATISTIC 体重 59.15kg 2017-05-10SUMMARY找了一些3DS游戏 SKILL TREESTATISTIC 体重 60.25kg 2017-05-11SUMMARY3DS到货了，成色略差，但是功能很好。手柄有些问题，准备退货。至于3DS破解，就是跟着有人总结的pdf文件一步一步做下来就行，还是挺佩服这些写破解文件的开发人员的。 SKILL TREE其他 A9破解3DS STATISTIC 体重 60.25kg 2017-05-12SUMMARY改BUG改的头大，结果发现是数据问题，还是我定位问题的方法有问题，应该更快速发现BUG的原因。 SKILL TREESTATISTIC 体重 59.75kg 2017-05-13SUMMARY约拍了一个妹子，还行，因为妹子人很憨厚很不错。我还应该表现得更专业和自信一些。玩了一下午游戏，没好好吃饭，不应该这样。也可能是玩上了一直以来想玩的游戏掌机，小时候爸妈不可能给买，所以弥补了儿时的渴望，就像小时候玩游戏一样疯狂啊，还是要控制自己。称重一下瘦了4斤，有点夸张，以后一个人也要好好吃饭。 SKILL TREE摄影 人像约拍99元 STATISTIC 体重 58.25kg 2017-05-14SUMMARY今天去拿到了900块买的新大三，发现非常的划算，32G SD + 64G SD + GW卡 + new 3DSLL，而且还基本装满了游戏，感觉这配置很豪华。但是我手贱点了一下升级系统，GW虚拟系统就不能启动了，很郁闷，搞了半天没办法了。以后没有问题的时候还是不要瞎折腾，就算要瞎折腾也应该在充分了解信息的情况下，分析利弊，再做决定。冲动往往导致一些不好的结果。 SKILL TREESTATISTIC2017-05-15SUMMARY今天状态还行，下面要开始抓紧办理离职手续了。3DS的系统再不想折腾了，毕竟买游戏机的初衷是玩想玩的那几个游戏，而不是装很多游戏装逼，更不是折腾系统什么的，感觉折腾系统已经花费了很多时间了，还是静待GW官网更新吧。今天记录了一下在公司时发现的一些好用的software：http://diaryfun.info/2017/05/记录一些好用的软件/ SKILL TREE健身 跑步机2000m 11km/h 烹饪 红焖牛肉 海鲜菇牛腩汤 STATISTIC 体重 58.25kg]]></content>
      <categories>
        <category>日报</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始写日报]]></title>
    <url>%2Fblog%2F2017%2F05%2F05%2Fe5-bc-80-e5-a7-8b-e5-86-99-e6-97-a5-e6-8a-a5%2F</url>
    <content type="text"><![CDATA[懒惰是有惯性的，而打破这种循环的办法只有一个，那就是立刻行动起来。 准备从今天起写日报，在未来的每一天，希望能够总结当天的收获以及为了目标所作出的努力，避免时间消磨在惰性之上。 先简单写个模板出来（使用Markdown语法）： # 2017-05-04 //日期## SUMMARY //每日收获总结 今天继续羽毛球，遇见两个好搭档，成功霸场，大臂继续疑似拉伤。最近很安逸，处于舒适区，需要搞点事情。 ## SKILL TREE //技能树 ### 健身 //技能树方向 - 羽毛球 2h ##### 核心加强计划 //专项计划名称 - 卷腹 152- 平板支撑 30s2 ## TODO LIST //待办事项 - 做JS五子棋首页入口- 用node.js写爬虫日志备份- 为个人网站应用gulp.js ## STATISTIC //统计数据 - 体重 59.05kg 2017-05-04SUMMARY今天继续羽毛球，遇见两个好搭档，成功霸场，大臂继续疑似拉伤。最近很安逸，处于舒适区，需要搞点事情。 SKILL TREE健身 羽毛球 2h 核心加强计划 卷腹 15*2 平板支撑 30s*2 TODO LIST 做JS五子棋首页入口 用node.js写爬虫日志备份 为个人网站应用gulp.js STATISTIC 体重 59.05kg 感觉wordpress里并没有typora里显示的那么好，不过也没关系了： 之前微博发过了总结的有效提升自己的方法论： 1.保持开放的心态 2.明确自身定位进行倒逼 这两句话很重要 立夏了，又到了最喜欢的季节。 Carpe diem, 一定要过好每一天啊。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cherry G80-3000 机械键盘试用]]></title>
    <url>%2Fblog%2F2017%2F03%2F22%2Fcherry-g80-3000-e6-9c-ba-e6-a2-b0-e9-94-ae-e7-9b-98-e8-af-95-e7-94-a8%2F</url>
    <content type="text"><![CDATA[自从我用了机械键盘以后，我觉得我打字要飞起来了。我了个去，这个声音好大啊。明天上班带着这个，啪啪啪啪的，领导听见以后一定会认为我敲代码很用功，一定会赏识我的！ 写几行代码试试吧 for(var i = 0;i &lt;= 100;i++){ console.log(&quot;我是Cherry G80-3000 青轴&quot;); } 我感觉有一个缺点，就是容易一激动按错键。 还有就是，打多了手有点累啊。我的手这会儿好酸。 cd dcd repositorycd git-learngit initgit add test.jsgit commit -m “From my cherry keyboard”]]></content>
      <categories>
        <category>数码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[世界，你好！]]></title>
    <url>%2Fblog%2F2017%2F03%2F20%2Fhello-world-1%2F</url>
    <content type="text"><![CDATA[你好哇！]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[当我22岁时我在想些什么]]></title>
    <url>%2Fblog%2F2016%2F09%2F24%2F%E5%BD%93%E6%88%9122%E5%B2%81%E6%97%B6%E6%88%91%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[一、总是在碰撞中回望，脆弱累积成担当。 2014年9月24日，我一个人去了南京北站，带了只灰色小熊，拍了些不知所云的照片，回来的时候叫那时还只是朋友的前女友出来吃饭，答复说有事，遂一个人去吃了自助，带了张纸放在桌上，上面写着俩字：“别收”。 2015年9月24日，我跑到新校区去听了如今就职的互联网公司的宣讲会，把书包里不小心揉得皱皱巴巴的纸质简历投了出去，结束后，饥肠辘辘，跑到最喜欢的一家自助凭身份证半价吃了一顿，吃了16个蒜蓉扇贝。 2016年9月24日，我在出租屋里，买了个20块钱小蛋糕，给自己做了顿意大利肉酱面，面煮得有点硬，猛然发现自己不小心丢掉了过生日一个人吃自助的传统，蛋糕吃不完。 回想起这些，明明只不过过去了一两年，但是却觉得已经是很遥远的事情了。细想也是正常，在这转折较多的两年后，我所处的环境与所持的心态已然不同，看了这两年的生日文，则很容易梳理出脉络。 “孤独是一种常态，而不孤独则是激发态。”——2014年思考孤独的本质及其积极意义。 “像诗人，又像无情的杀手，是柔软而坚不可摧的存在，这样就好了。”——2015年崇尚冷酷的理性力量。 很高兴能看到自己走过的轨迹，心一点一点地变得坚硬，正应了我这几天在反复思考的一句话： “凡不能杀死我的，必使我脸皮更厚。” 二、寄蜉蝣于天地，渺沧海之一粟 这个问题，要回溯到3年前，我读Peter H.Raven和George B.Johnson所著《生物学（第6版）》的时候，书中探讨了生命起源的一种可能方式，即海底火山喷发时涌出大量气泡，其中个别气泡随机地包裹了有机物，最后形成了细胞的原型，当时我就在想，如果不是某个非常巧的巧合使得地球上第一个单细胞生物出现，我们是不是就完全不会存在？后来学得越多，越觉得生命是一个伟大的巧合。如果水的键角不是104.5°，偏了一点，104.6°，那么是不是物理性质会发生改变，很多反应都不能发生？其导致的连锁效应是不是会导致所有生命不复存在？如果糖酵解过程中某个反应少释放几个焦耳的能量，是不是就会导致生物无法进化到产生智慧文明？ 我觉得答案是，几乎必然。 就算这些都没有，只要生物漫长进化的过程中某一个岔路走错了，那人类也很可能就永远无法出现。在我看来，人类的出现比彩票中500万的几率小太太太…（太乘以2的64次方）多了。 “天地不仁，以万物为刍狗。” 然而我们已经身处在莫大的幸运中而不自知，遇到困难的时候，想到这些，觉得还是应该心怀感恩，感谢这一切。 嗯，感谢水的键角是104.5°。 三、关于我的欲望 “淡泊以明志，宁静以致远。”——这是我从初一到大三笔袋子里面一直夹着的一张纸上面写的一句话。 其实我一直没懂。 或者说，每一个时代有着不同的理解。 现在的理解无非是两句话拆开看： 1.认清自己的欲望点，不是自己真正需要的东西就看淡吧。 2.保持平和包容的心态，不必大喜也不必大悲，这样长远来看才是提升生活品质的根本途径。 先来说第二点，我也是后来才发现，人的情绪往往是大致守恒的，一个人如果容易狂喜，那么他很可能也会经常特别郁闷，就像我们小的时候一样。控制自己的情绪在一个较小的波动范围内，具体操作就是，不对事物抱有过分乐观的期望，也不对事物抱有过分悲观的猜想，这是一个经过理性考量的抉择。 至于第一点，其实关键点还是那句话：知道自己要的是什么。 看过《瓦尔登湖》的人应该知道，梭罗在《瓦尔登湖》中提倡一种返璞归真，抛弃那些并不是真实需要的欲望的生活。在我看来，这是一种非常正确的思路，虽然我并不想过他那种劈柴种地的生活。他的思想的关键点不在于瓦尔登湖边朴素却丰富的生活，而是尊重自己的独特性，深谙自己真正的欲望点并且付诸实践。 我的欲望点是什么，这也是我一直在思考的内容。回顾我感受到快乐的经历，可以先分为两大类： 第一类是达成某种目标所获得的“成就感”，第二类是一种专注状态下的“心流”。 针对达成某种目标所获得的“成就感”，又可以分为两类：一类是对于自身以及世界的探索，这种探索类似一种挖掘，分为两个方向，向内挖掘自身的能力和向外挖掘这个世界的知识，其实就是对于自我的提升，即“做一个更优秀的人”，这一类从自己与世界的关系来看，算作“输入”；另一类是向外界的自我表达，通俗的来讲，那就是广泛意义上的“装逼”，至于怎么“装逼”，在哪个方向上“装逼”能获得的幸福感最强，这就是每个人差异的地方，至于我倾向于哪种自我表达，这里就省略1000字好了，这一类从自己与世界的关系来看，算作“输出”。 至于专注状态下的“心流”，根据“心流”的产生机制，只有当能力与挑战难度同时较高且大致匹配时，才能更容易产生“心流”。所以，找到自己的天赋并不断提升相关能力是使“心流”更容易产生的关键。 当然，这两大类欲望都是建立在我“好吃懒做”的生存欲望满足以后的基础之上的。 于是，我就可以列出一个欲望清单： 保证基本生活质量的生存 对于自身以及世界的探索 向外界的自我表达 专注状态下的“心流” 如果要排个优先级的话，我选择1&gt;4&gt;2&gt;3 具体实行的话，那么4项同时完成的很好是比较难得的，其原因在于1与4的冲突，因为拥有一份自己特别喜欢，时时产生“心流”，同时还要为社会产生贡献以换取金钱保证生活质量的工作是比较难得的。于是通常情况下就需要在其中做出权衡，似乎我更倾向于“做自己还算喜欢的工作，顺便挣点钱”的模式。 无欲则刚，但是天性难违，你需要满足你天性中真正需要的东西。 我想，这才是对待欲望的正确态度。 四、人生的本质 以前不知道在哪看过这样一句话，“你掉进一口无底深井，但是抓住了一个即将断掉的藤蔓，你看见嘴边的叶子上有一滴闪闪发光的甘露，人的一生，大抵不过是这个吮吸甘露的过程啊。” 这一句话就够了。 人生的本质是一段体验。 无论如何，我们终将一事无成，你说呢？]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[达瑞的2016半吊子小短文]]></title>
    <url>%2Fblog%2F2016%2F01%2F01%2F%E8%BE%BE%E7%91%9E%E7%9A%842016%E5%8D%8A%E5%90%8A%E5%AD%90%E5%B0%8F%E7%9F%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[汪汪汪： 时间来到了2015年12月31日18时36分，图书馆比以往空了一大片，学校莫名其妙在黑夜里开启了喷泉，校门外，没理发的达瑞走在包子铺旁的大街上，看着读秒的红绿灯和来往的生物，盘算着写一篇半吊子小短文。 “叫什么题目呢？” “就叫半吊子小短文吧。” “好呀好呀，就叫达瑞哥哥的半吊子小短文！” “算了，这样太高调。但又要突出作者，就叫达瑞的半吊子小短文吧，哎不对，要加上时间，达瑞的2016半吊子小短文，嗯，就这样。” 有时渴望分享，但更享受自由。 “那今天就分享一下。” 达瑞看着红灯变绿心里响起昨天玩的游戏的背景乐走向镇江锅盖面馆。 过去的这一年，遇到了很多事。 一次多年未遇的飘浮： 我真的很久没有飘得如此厉害。 一次人生观念的猛击： 重塑了之前的观念体系。 一次跌落谷底的沉潜： 感受绝望与沉默。 一次精准华丽的转折： 我只是觉得运气太好罢了。 这些都过去了 于是有了如今的我 以上一句是废话 也许我学了4年生物的最大意义是 我深知，倘若水的键角偏离1度，也许所有的生命都不会存在。 我们存在， 是极小概率事件， 是多么微妙的巧合。 怎好意思不认真虚度？ 接受这世界的随机性， 你已经抽到了最大的巧合。 新的一年 愿 有书有肉有手柄 有网有电有耳机 告别一整个庞杂宏大的2015 带着忘却或忘却不了的痕迹 周而复始 万象更新 2016 尽情享用而已 另：所有人发的新年快乐，我都没回，我懒而已。 喵喵喵 2016.01.01]]></content>
  </entry>
  <entry>
    <title><![CDATA[记老游戏]]></title>
    <url>%2Fblog%2F2015%2F10%2F25%2F%E8%AE%B0%E8%80%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[开一篇帖子记录之前玩过的游戏。 主要收录原则： 我认可并会向人推荐的游戏； 我已通关或了解游戏全貌； 该游戏在当时给我以深刻感动或该游戏相关回忆令人难忘。 希望将满足以上三条的游戏完整回忆并记录。 赤色要塞 英文名：Jackal 发行商：KONAMI 发行时间：1988 运行平台：FC 游戏类型：ACT 这个游戏其实严格来说我并没有通关，而是我爸妈通关。之所以收录，其实是因为那时（大约2000年左右）每天晚上坐在父母中间，看他们欢乐地打游戏，我一个人就在那一直傻乎乎地看，跟着他们一起精神紧绷。还记得他们那段时间好像每晚都要打游戏，而且挑选了好几个游戏准备通关，而这一个貌似是打得时间最长的，所以我印象也就最深。游戏难度不低，我最终是后来在模拟器上无敌模式下才通关的（也就是说，我游戏还没我爸妈打得好），主要原因是最终关（如果我没记错的话是第六关）“蚊子”式直升机太神出鬼没而且子弹快而准确，最终BOSS巨型坦克也是比较难打，总之，我记得我爸妈刷了无数遍游戏都在第六关死掉。 一家三口在一起精神紧绷打游戏的时光，估计是再很难有了，转眼间再过些年也就到了当初父母的年纪，想一想父母当年也是和我们一样生龙活虎的年轻人啊。 综合评分：7.4（品质一般） 评分理由：FC时代的经典之作，和魂斗罗、绿色兵团、沙罗曼蛇并誉为“四强”，可双人游戏，解救人质送往机场的有趣设定，发光人质升级弹药，在当时来说是一部短小精悍的游戏作品。总体的游戏性必然不如后来的游戏，但是已经是很多人心目中童年不可复制的经典。 玩具兵大战：即时战略版 英文名：Army Men RTS 发行商：3DO 发行时间：2002 运行平台：PC 游戏类型：RTS 第一部令我沉迷的PC游戏，当然印象比较深刻，以至于后来都比较喜欢即时战略类游戏。第一次接触到这个游戏是在我爸同学他家，从此以后便夜不能寐（说的有点夸张），由于当时家里还没有买电脑，所以天天期待着被我爸带去他同学家玩（其实去了也是看着我爸玩， 然后我爸玩累了再让我玩一会儿，嗯我爸也是为了蹭电脑玩而去的），其实没玩几次这游戏就被同学家哥哥卸载了。还有一件印象比较深刻的是，我第一次进网吧的时候（被我姐带进去的），居然玩的就是这个游戏（你们想象一下一个三年级小孩在网吧打单机游戏的画面），然后赖在里面迟迟不想回家，当然最后还是被我姑给拽回去了（这事我爸妈至今估计也不知道），我才玩了两个小时啊。由于我每次都只能玩一两个小时，所以我玩了无数遍1-3关（网吧无法存档），偶然能玩一下第5关，然后还日思夜想去我姐家玩，其实就是想让她带我去网吧。直到有一天，我家买了电脑，我立即安了这个游戏，本以为终于能快速通关了，结果当时是上小学每周末我才回一次家，每次回家也就能玩几个小时（父母在家，玩多了你懂的），于是就演变成了我天天盼周末的节奏。记得有一次周末要停几天电，结果我拉了两天的脸，我妈问我你咋了，我说我玩不了游戏了，我妈的反应居然是安慰我（后来细思极恐啊），当然这种事后来再没发生过，后来都是我妈催我关电脑甚至扬言要打我的节奏。 综合评分：8.2（值得一玩） 评分理由：非常有意思的即时战略类游戏，主线任务共15关，是一个带领一堆阳光健康的绿色的塑料兵人打下一个由邪恶的黄色兵人控制的房子的故事，从花园打到地下室，再从厨房打到卧室。游戏中的资源就是塑料和电力，用这些东西造兵、造基地、造直升机、造坦克之类的，类似红警2，有兵种克制，个人认为游戏性与画面质感均不输于红警2，还有一关是掩护乐高玩具（平民）撤退的非常有趣，就是联机游戏性欠佳。 模拟人生2 英文名：The Sims 2 发行商：EA 发行时间：2004 运行平台：PC 游戏类型：SIM 没错，下面是第二部让我沉迷的PC端游戏，居然是模拟人生系列，同样是从另外一个我爸同学家的哥哥那你学到的。这个游戏在后来看觉得特别无聊，不过也毕竟是曾经沉迷过的游戏（其实我觉得是因为这游戏太费时间了），就收录进来说一下。当初我玩这个游戏的时候我是直接自定义了一个家庭，就是一个一家三口，把其中的爸爸设置成了我爸的名字，妈妈设置成了我妈的名字，而小孩，也设成了我的名字（想想也是逗比），然后因为这个事还被我爸骂了一顿说我泄露个人信息。 更那啥的是，我还给那个男的找了份和我爸一样的工作，我也是够了。玩这个游戏印象最深的片段同时也是这个游戏中我最有成就的地方，就是游戏中的这个小孩被我逼着学习成绩A+，最后收获了很多东西，还有什么摇钱树什么的，那个摇钱树居然真能收钱。而这个小孩是怎么得到A+的呢？因为我天天逼着他写作业，只要每天把作业逼着写完，按时去学校，过好几天就A+了。然而我发现逼他写作业特别困难，动不动写着写着就要撒尿，要不然就是要玩游戏，有时候还必须得他妈妈来辅导才能写，更可气的是有时候睡眠值过低写着写着直接就在地板上睡着了，叫都叫不醒，只能等他睡会再抓起来摁着写。我当时就想，这特么写个作业怎么这么困难，要死要活的，我怎么就没这么困难（我当时刚上初中）。结果上高中以后，我才发现，我就是模拟人生中那小孩的翻版（写着写着就地板上睡着了那种），原来模拟人生做的如此真实，顿时这个游戏在我心目中的形象就高大了起来（逗）。 综合评分：7.6（可以尝试） 评分理由：模拟人生系列游戏作为模拟游戏的重要一作，其地位还是值得肯定的，游戏中的元素也很丰富，也有很多官方发行的资料包，如果喜欢此类的同学大可好好得创造一个自己的角色好好地玩一下。但是我觉得这个游戏太费时间，同时其中的游戏人物一天中的大部分时间都会浪费在做饭、洗澡、撒尿、睡觉、工作（现在看好像还挺真实的）上面，玩起来实在是个漫长的过程，主要我对模拟类游戏的兴趣，经此一役，已经玩腻了。 欢乐奇兵 英文名：Happy Tank 发行商：智冠科技 发行时间：2003 运行平台：PC 游戏类型：STG 这个游戏也是我最开始接触的PC端游戏之一，同样是在再另外一个我爸同学家的哥哥（你爸同学家的哥哥有多少个？）那里第一次玩到的。游戏内容说白了就是类似坦克大战的形式，同样也有各种道具可以吃，比如导弹、穿甲弹、快弹、双弹、无敌、隐身等等，而且还有更有意思的炮弹种类比如超声波、榴弹。初始情况下有三辆坦克可以选，分别是毛头机甲、淑女机甲、老爷机甲，各有各的特点，到后来还可以解锁另外两辆坦克：猛男和铁嘴。其实推荐这个游戏的最关键原因是，这是我最推荐的一款PC端双人游戏，是两个人在一台电脑上玩的那种，左右分屏，男女老少咸宜。第一次通关是曾经跟一起长大的发小在他家玩，真的是很美好的回忆。总之，这游戏必须双人玩，堪称好基友并肩作战必备游戏之一。 综合评分：8.0（值得一玩） 评分理由：好基友并肩作战必备游戏之一，很有趣，可以视作儿时坦克大战的延伸。一共24关， 难度较低，游戏元素简单，居家必备。 使命召唤5：战争世界 英文名：Call of Duty : World at War 发行商：Activision 发行时间：2008 运行平台：PC 游戏类型：FPS 时光辗转来到了2011年，在一个略微昏暗的冬天，有一种快过年的气氛，我此刻和张钰祥同学窝在丁一网吧的一个相对独立的小角落里（如果没记错的话应该是001-012号机），打开了Call of Duty的联机模式，开始了两个人协作的战斗。游戏的剧情比较跳跃，时而是扮演美国大兵在南太平洋杀鬼子，时而是扮演苏联小哥打德国，总之是以二战为主题的一作。这是我第一次玩使命召唤系列的游戏，其实也是第一次较长时间玩第一人称射击游戏，感觉很不错，以至于通关后还想找续作来玩。由于我有比较严重的3D眩晕症，所以连续玩FPS类游戏1小时左右就会有点想吐（现在玩《我的世界》都想吐），然而使命召唤5是唯一一部让我没什么难受感觉的游戏，或许是有队友并肩作战的缘故吧。关于这个游戏的记忆，有苏联战场上的波波沙冲锋枪，还有太平洋战场上的百式冲锋枪（捡日本人的，把子在侧面，扫起来感觉很爽的样子），印象最深刻的一幕是，你会扮演那个最终在德国国会大厦插上苏联红旗的士兵，然而在插旗的那个台阶下面还藏着最后一名德国士兵，你走过去他会突然跳起来想捅死你（吓死你），但是你的队友会帮你把他解决了。 综合评分：8.2（值得一玩） 评分理由：好基友并肩作战必备游戏之二，第一人称射击游戏玩家心目中的佳作，同时在此作品中可以大略感受到二战中恐怖残酷的性质。然而本人对FPS类游戏兴趣不大，这基本是我完整玩下来的唯一一部FPS。 命令与征服：红色警戒3 英文名：Command &amp; Conquer: Red Alert 3 发行商：EA 发行时间：2008 运行平台：PC 游戏类型：RTS （图片暂空） 关于这个游戏，我只想先用一句大家听了可能会觉得特装逼的话来表达。于我而言，这个游戏已经不是一款游戏，是青春。能说的事情太多，先占坑，等大家的评论，看完大家的评论我再来填。 综合评分：9.8（关乎信仰） 评分理由： 双星物语 英文名：ZWEI!! 发行商：FALCOM 发行时间：2001 运行平台：PC 游戏类型：ARPG FALCOM出品的经典ARPG游戏，已于2009年出品续作加强版《双星物语 2+》，但我还是觉得一代比较耐玩（可能由于本人3D眩晕的缘故）。作品主要讲述的是一个浮游大陆上古老而宁静的村庄——布克村神庙中各元素神像神秘失窃，由游戏主人公皮皮洛和布库尔姐弟俩前往各种属性的迷宫探险打怪找回，并最终打败大魔王的故事。其中姐姐皮皮洛使用魔法攻击，弟弟布库尔使用刺剑攻击，二者可以随时切换，迷宫中也可以拿到风、地、水、火、光、暗属性的六块宝玉以及各种奥义，从而使出各种不同属性的魔法。同时，还可以领养一只宠物（我选的猫）参战，在足够多的Combo之后会积累单人特技、双人合体技、三人（只）合体技，在关键的时刻可以使用。游戏主角通过吃食物来升级，多个低级食物可以在村子旅馆里换成大餐以补充更多经验值。游戏还有以宠物为主角的外置小游戏，在小游戏中获取的宠物道具会自动放在主游戏里。这个游戏还有很多可以收集的东西，有收集癖的同学也能玩很嗨。总之，对这个游戏的印象就是游戏元素丰富，画风优良，偶尔需要智商，嗯，BGM也不错，是一款不可错过的佳作。 综合评分：9.2（高分神作） 评分理由：游戏元素丰富，画风优良，非常有意思，每个迷宫都会有评分，整个游戏通关之后还可以再玩二周目，完美主义者能玩很久，绝对是一款精致的ARPG佳作。需要注意的是，游戏中彩蛋众多，如果不看攻略，可能会遗漏掉某些隐藏物品。 恋爱物语2 英文名：Eberouge 2 发行商：Fujitsu 发行时间：1998 运行平台：PC 游戏类型：GalGame 作为我第一次玩通的GalGame，《恋爱物语2》在当初也确实给了我一种莫名的幸福感动，以至于玩完之后的感想就是，“好想找个女朋友啊”，现在还能回想起当时成功和攻略女生牵手时呆萌的心情。记的最清楚的可能是玛鲁（我攻略的女生是玛鲁）在和我一起出去到海边玩的时候说的“这样想想好像是有些罗曼蒂克哦”，当时我脸就红了（这句话有什么可脸红的吗？），你可以尽情想象一下半夜对着个屏幕脸红的情景。当时应该是2011年上半年，我记得玩过不久就和我前前女友在一起了，然后我居然给她说了这个游戏，于是乎她就跑去玩了而且还问我喜欢里面的哪个女生，我说“玛鲁啊”，然后她好像不怎么喜欢玛鲁的样子。这个游戏总体有一定的可玩性，就是大家熟悉的要修各种课程使自己变得更优秀，然后去找你喜欢的女生玩并触发相关剧情之类的。但是最后获得HAPPY END的条件很坑爹，为了避免气候变暖使瓦尔大陆被毁灭（什么鬼），你必须和全部5个女生都搞好关系（就是所谓的暖男，你懂的）并且和她们一起创造出友情的结晶——5个“光球”，否则就会因为最后瓦尔大陆毁灭而获得BAD END。我第一次玩的时候完全不知道这设定，然后就和玛鲁一个人关系特别好，于是到最后就世界毁灭了。在我看来，要么感情专一导致世界毁灭，要么狠心做中央空调保卫世界平安，二者不可兼得，于是这游戏太难了。 综合评分：8.2（值得一玩） 评分理由：第一次玩的时候有些感动，又带一点憧憬。但是由于游戏发行年代较老，画风现在看来简直不忍直视，而且好像没有BGM（可能是被我关了），游戏HAPPY END的条件太烦人。给出这个分数，还是出于对于当时心情的纪念吧。 雪之少女 英文名：Kanon 发行商：Key 发行时间：1999 运行平台：PC 游戏类型：GalGame 著名的Key社三部曲（Kanon、AIR、CLANNAD）中的首部作品，我也是玩了以后才知道，据说会很催泪什么的，而我玩完并没有什么太强烈的感觉（我的情绪表现向来不激烈）。那时是2013年1月，我妈正做手术住院，也是我每天在思考一些有关意义的问题很迷茫的一段时间，就在那段时间里，我玩完了Kanon，那些平凡普通而又有一些离奇的故事，但是共通的特点就是，它们都是些温暖的故事。巧的是，这部作品正好是三部曲中以冬为主色调的一部（所谓冬之Kanon），而我当时也正好是冬天，如果我没记错的话，那年冬天下了很多的雪，正是因为这部作品，所以那年冬天在我的记忆里是这么多年最独特的感觉。其实对于这部游戏最深的记忆在于它的BGM，没错，我玩完之后找到原声带听了一整个2013年的冬天，经常是单曲循环或者专辑内随机播放。那段时间正好是我很多观念发生转变的时间，坐在43上，看着车轮压过白色的雪，听着原声带，想到游戏中早上总是睡不醒的表妹水濑名雪，莫名地有一种温暖的力量，生活在每一个当下，人生不过如此吧。虽然Key社的游戏作品中总有些离奇的幻想和太多的不合逻辑之处，但是这并不妨碍它作为一个美好的幻想而存在，人人都很温柔的冬季漫长的北方小镇，也许正是Kanon这部作品想要给我们带来的温柔乡吧，一个在日常充满残酷理性的生活背后温暖自己给自己充电的温柔乡。 名雪平时回答我的时候的那句“嗯”总是明亮而充满肯定，就因为这个，我之后半年对别人的回应都变得积极起来，我想这就是这个游戏对我最明显的改变吧。 综合评分：8.6（强烈推荐） 评分理由：Key社处女作，为我们描绘出一个冬季漫长的北方小镇以及其中发生的充满幻想的温暖故事，1999年首发，实为GalGame经典一作。其实我觉得这部游戏中我最欣赏的亮点还是BGM，BGM的风格很到位，能让人整个冬天都沉浸在游戏所塑造氛围之中，建议在冬天玩。当然剧情有些地方由于大胆的幻想而显得不合逻辑，这也是很多游戏与动漫作品的通病。总之，感谢Key社的创作，感谢Key社的神之BGM，给我带来了一个记忆中不一样的冬天。另外，该作于2002年被东映动画改编为电视动画（不推荐），2006年被京都动画重新改编为电视动画，当然还是推荐游戏原作。 火焰之纹章：圣魔之光石 英文名：Fire Emblem: The Sacred Stones 发行商：Nintendo 发行时间：2004 运行平台：GBA 游戏类型：SRPG SRPG中最受推崇的经典，当属任天堂旗下的火焰纹章系列，而圣魔之光石则是其在GBA平台上三部曲中的最后一作。坦白来说，这种类型的游戏，是我的菜。我是在2011年暑假玩这个游戏的，到现在你还可以看到我相册里一堆我打出来的人物属性截图，当然我硬盘里还备份着我的游戏存档。作为一个战略战棋类游戏爱好者，无论你让我怎么评价这个游戏，我都会告诉你“太棒了”。游戏中有多种职业以及转职后的高级职业，其中我最喜欢的当属“贤者”——理属性魔法的精通者，理属性魔法在三种魔法中具有中等威力/较高命中/最高必杀率的特性，而且名字都很好听（暴露了我喜欢的真实理由），比如雷暴/终末之冬，以及最后的双圣器之『风刃』艾克斯迦利瓦，怎么听怎么炫酷，况且还那么好用（我培养了塞勒夫和露忒两个高属性贤者）。还有更关键的一点是，战斗动画中他们使出必杀的时候，在胸前划出一个六芒星，随即眼前一道硕大的闪电劈下来（使用雷暴），对面的怪基本上就被瞬秒了，简直是帅，以至于后来我在现实生活中都会想象着在胸前划一个六芒星然后一道闪电劈死对面是怎样的一种景象。类似的我很喜欢的职业还有“剑圣”和“勇者”，因为他们的必杀都非常的帅。这个游戏可玩性非常强，剧情也是跌宕起伏，隐藏的彩蛋丰富，随机性也非常高，但这么多优秀的特性，还不足以概括这个游戏的精华，因为它还有一个精妙的设计，里面的人物一旦死亡，就是真正意义上的死亡，后面的游戏中就再也都无法使用。你能想象一下你辛辛苦苦培养到20级的人才因为你的一步疏漏而被对方秒了后你的心情吗？所以你必须精打细算，步步为营，必须像一个思路深邃精密的象棋手，考虑好每一步所可能带来的后果，因为，在你悉心培养的将士面前，你根本没有悔棋的机会。《刀剑神域》这部动画为什么好看，很大程度上是由于游戏中角色死亡会导致现实中自己的死亡，对死亡的恐惧所带来的真实感使人惊心动魄全情贯注，而火焰纹章系列也是很好的利用了这一点，对于将士死亡的敬畏，使玩家获得了更好的游戏体验，再加上各方面的优秀设计，成就了其一代游戏经典的地位。最后说一下BGM，那熟悉的主旋律我到现在还会哼，以8位机音质，做出这么好听的作品，不可不谓之曰“神”，正如游戏本身以极低的像素，但还是刻画出一个个生动而富有个性的人物形象，做出了各方面都很完美的作品。一直以来因为原声带不是很好找，所以没有弄到手机上，直到今天在网易云音乐上找到了火焰纹章系列的主题曲，打开一听，有种热泪盈眶的冲动，就像见到一个好久不见的老朋友，毕竟也是曾令我感动过的游戏啊。 综合评分：9.4（高分神作） 评分理由：GBA平台上的良心大作，BGM、剧情、人物刻画、游戏性等各方面均表现得非常出色，虽然画质在现在看来很是复古，但绝对是一部值得收藏的经典，高分力荐。 正文部分完 附录部分将收录不全满足但部分满足收录原则的游戏进行评分并陈述评分理由。 附录： 真三国无双5 英文名：Shin Sangokumusou 5 发行商：KOEI 发行时间：2007 运行平台：PC 游戏类型：ACT 综合评分：7.9（可以尝试） 评分理由：玩起来很爽，还可以和基友一起双人游戏，感觉非常棒，而且还可以顺便了解一下三国历史知识，就是游戏模式沿袭各种无双，比较单调。 极品飞车14 英文名：Need for Speed：Hot Pursuit 发行商：EA 发行时间：2010 运行平台：PC 游戏类型：RAC 综合评分：8.3（值得一玩） 评分理由：最喜欢的赛车游戏，出色的音乐更是其亮点。极品飞车系列中可玩性最强的几部作品之一。 命令与征服：红色警戒2 英文名：Command &amp; Conquer: Red Alert 2 发行商：EA 发行时间：2000 运行平台：PC 游戏类型：RTS 综合评分：7.7（可以尝试） 评分理由：风靡一时的即时战略游戏，几乎人人皆知，但其相较红警3而言游戏平衡性欠佳，偏重娱乐性。 瘟疫公司 英文名：Plague Inc. 发行商：Ndemic Creations 发行时间：2012 运行平台：PC 游戏类型：SLG 综合评分：7.5（可以尝试） 评分理由：很有创意的一款游戏，模拟细菌或病毒的传播，目标是使人类灭绝，有引发大众思考的目的，玩法较为简单，值得尝试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[用/(.*?)d/正则表达式匹配abcd为什么得到的是abcd而不是d?]]></title>
    <url>%2Fblog%2F2015%2F09%2F30%2F%E7%94%A8-d-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8Dabcd%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%97%E5%88%B0%E7%9A%84%E6%98%AFabcd%E8%80%8C%E4%B8%8D%E6%98%AFd%2F</url>
    <content type="text"><![CDATA[问题： 用/(.*?)d/正则表达式匹配abcd为什么得到的是abcd而不是d？而用”/a(.*?)/“正则表达式匹配”abcd”则只得到”a”。 用”/a(.*?)d/“正则表达式匹配”abcd”为什么得到的是”abcd”而不是无法匹配？ 回答： 看到了一个非常棒的帖子，从NFA引擎机制上解释了这一问题 引用过来供大家参考 本题相关关键内容已加粗并下划线 （其中有两张图大家看完一定就明白了） 对于贪婪与非贪婪模式，可以从应用和原理两个角度进行理解，但如果想真正掌握，还是要从匹配原理来理解的。 先从应用的角度，回答一下“什么是贪婪与非贪婪模式？” 2.1 从应用角度分析贪婪与非贪婪模式 2.1.1 什么是贪婪与非贪婪模式 先看一个例子 举例： 源字符串：aatest1bbtest2cc 正则表达式一：.* 匹配结果一：test1bbtest2 正则表达式二：.*? 匹配结果二：test1（这里指的是一次匹配结果，所以没包括test2） 根据上面的例子，从匹配行为上分析一下，什是贪婪与非贪婪模式。 正则表达式一采用的是贪婪模式，在匹配到第一个“”时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以仍然要向右尝试匹配，查看是否还有更长的可以成功匹配的子串，匹配到第二个“”后，向右再没有可以成功匹配的子串，匹配结束，匹配结果为“test1bbtest2”。当然，实际的匹配过程并不是这样的，后面的匹配原理会详细介绍。 仅从应用角度分析，可以这样认为，贪婪模式，就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。 正则表达式二采用的是非贪婪模式，在匹配到第一个“”时使整个表达式匹配成功，由于采用的是非贪婪模式，所以结束匹配，不再向右尝试，匹配结果为“test1”。 仅从应用角度分析，可以这样认为，非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。 2.1.2 关于前提条件的说明 在上面从应用角度分析贪婪与非贪婪模式时，一直提到的一个前提条件就是“整个表达式匹配成功”，为什么要强调这个前提，我们看下下面的例子。 正则表达式三：.*bb 匹配结果三：test1bb 修饰“.”的仍然是匹配优先量词“”，所以这里还是贪婪模式，前面的“.”仍然可以匹配到“test1bbtest2”，但是由于后面的“bb”无法匹配成功，这时“.”必须让出已匹配的“bbtest2”，以使整个表达式匹配成功。这时整个表达式匹配的结果为“test1bb”，“.”匹配的内容为“test1”。可以看到，在“整个表达式匹配成功”的前提下，贪婪模式才真正的影响着子表达式的匹配行为，如果整个表达式匹配失败，贪婪模式只会影响匹配过程，对匹配结果的影响无从谈起。 非贪婪模式也存在同样的问题，来看下面的例子。 正则表达式四：.*?cc 匹配结果四：test1bbtest2cc 这里采用的是非贪婪模式，前面的“.?”仍然是匹配到“test1”为止，此时后面的“cc”无法匹配成功，要求“.?”必须继续向右尝试匹配，直到匹配内容为“test1bbtest2”时，后面的“cc”才能匹配成功，整个表达式匹配成功，匹配的内容为“test1bbtest2cc”，其中“.*?”匹配的内容为“test1bbtest2”。可以看到，在“整个表达式匹配成功”的前提下，非贪婪模式才真正的影响着子表达式的匹配行为，如果整个表达式匹配失败，非贪婪模式无法影响子表达式的匹配行为。 2.1.3 贪婪还是非贪婪——应用的抉择 通过应用角度的分析，已基本了解了贪婪与非贪婪模式的特性，那么在实际应用中，究竟是选择贪婪模式，还是非贪婪模式呢，这要根据需求来确定。 对于一些简单的需求，比如源字符为“aatest1bb”，那么取得div标签，使用贪婪与非贪婪模式都可以取得想要的结果，使用哪一种或许关系不大。 但是就2.1.1中的例子来说，实际应用中，一般一次只需要取得一个配对出现的div标签，也就是非贪婪模式匹配到的内容，贪婪模式所匹配到的内容通常并不是我们所需要的。 那为什么还要有贪婪模式的存在呢，从应用角度很难给出满意的解答了，这就需要从匹配原理的角度去分析贪婪与非贪婪模式。 2.2 从匹配原理角度分析贪婪与非贪婪模式 如果想真正了解什么是贪婪模式，什么是非贪婪模式，分别在什么情况下使用，各自的效率如何，那就不能仅仅从应用角度分析，而要充分了解贪婪与非贪婪模式的匹配原理。 2.2.1 从基本匹配原理谈起 NFA引擎基本匹配原理参考：正则基础之——NFA引擎匹配原理。 这里主要针对贪婪与非贪婪模式涉及到的匹配原理进行介绍。先看一下贪婪模式简单的匹配过程。 源字符串：”Regex” 正则表达式：”.*” 图2-1 注：为了能够看清晰匹配过程，上面的空隙留得较大，实际源字符串为“”Regex””，下同。 来看一下匹配过程。 首先由第一个“””取得控制权，匹配位置0位的“””，匹配成功，控制权交给“.*”。 “.*”取得控制权后，由于“*”是匹配优先量词，在可匹配可不匹配的情况下，优先尝试匹配。从位置1处的“R”开始尝试匹配，匹配成功，继续向右匹配，匹配位置2处的“e”，匹配成功，继续向右匹配，直到匹配到结尾的“””，匹配成功，由于此时已匹配到字符串的结尾，所以“.*”结束匹配，将控制权交给正则表达式最后的“””。 “””取得控制权后，由于已经在字符串结束位置，匹配失败，向前查找可供回溯的状态，控制权交给“.*”，由“.*”让出一个字符，也就是字符串结尾处的“””，再把控制权交给正则表达式最后的“””，由“””匹配字符串结尾处的“””，匹配成功。 此时整个正则表达式匹配成功，其中“.*”匹配的内容为“Regex”，匹配过程中进行了一次回溯。 接下来看一下非贪婪模式简单的匹配过程。 源字符串：”Regex” 正则表达式：”.*?” 图2-2 看一下非贪婪模式的匹配过程。 首先由第一个“””取得控制权，匹配位置0位的“””，匹配成功，控制权交给“.*?”。 “.*?”取得控制权后，由于“*?”是忽略优先量词，在可匹配可不匹配的情况下，优先尝试不匹配，由于“*”等价于“{0,}”，所以在忽略优先的情况下，可以不匹配任何内容。从位置1处尝试忽略匹配，也就是不匹配任何内容，将控制权交给正则表达式最后的“””。 “””取得控制权后，从位置1处尝试匹配，由“””匹配位置1处的“R”，匹配失败，向前查找可供回溯的状态，控制权交给“.*?”，由“.*?”吃进一个字符，匹配位置1处的“R”，再把控制权交给正则表达式最后的“””。 “””取得控制权后，从位置2处尝试匹配，由“””匹配位置1处的“e”，匹配失败，向前查找可供回溯的状态，重复以上过程，直到由“.*?”匹配到“x”为止，再把控制权交给正则表达式最后的“””。 “””取得控制权后，从位置6处尝试匹配，由“””匹配字符串最后的“””，匹配成功。 此时整个正则表达式匹配成功，其中“.*?”匹配的内容为“Regex”，匹配过程中进行了五次回溯。 全文链接： 正则基础之— 感谢原作者]]></content>
  </entry>
  <entry>
    <title><![CDATA[黄金时代]]></title>
    <url>%2Fblog%2F2015%2F09%2F24%2F%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[借我一个暮年， 借我碎片， 借我瞻前与顾后， 借我执拗如少年。 借我后天长成的先天， 借我变如不曾改变。 借我素淡的世故和明白的愚， 借我可预知的险。 借我悲怆的磊落， 借我温软的鲁莽和玩笑的庄严。 借我最初与最终的不敢，借我不言而喻的不见。 借我一场秋啊，可你说这已是冬天。 ——樊小纯《借我》 高而能下，满而能虚， 富而能俭，贵而能卑， 智而能愚，勇而能怯， 辩而能讷，博而能浅， 明而能暗，是谓损而不极。 能习此道，惟至德者及之。 ——刘向《说苑·敬慎》 我愿做一个无比强大的人 不会因环境所恼 不会因情绪所惑 不会因爱而沉沦 而是独立、自信、有尊严的光芒矗立 在每一个大地山河与星空海洋 像诗人 又像无情的杀手 是柔软而坚不可摧的存在 这样就好了 我竟如此真实地存在 在这个美好的世界中 那就去吧，在你的 黄金时代]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[16 versus 21]]></title>
    <url>%2Fblog%2F2015%2F09%2F24%2F16%20versus%2021%2F</url>
    <content type="text"><![CDATA[16岁、我希望我能够开心一些—-21岁，我挺开心的 16岁、我希望我能够成熟一些—-21岁，我对成熟没有定义 我希望我能长得更高—-好像没长 我希望我能长得更帅—-这我不知道，我妈说我丑了 我希望我稍微长胖一点—-尚未实现 我希望学习有所进步—-什么是进步 我希望我能更有文采—-文采是什么 我希望我能更有智慧—-哦 我希望我字能写得更好看—-很久不写字了，目前是不用钢笔不好看 我希望我吉他能弹得更好—-是更好了 我希望我能学会编曲—-能编 我希望我唱歌能更好听—-这不知道 我希望我羽毛球打得更好—-经历了高三巅峰又废了 我希望我希望我长跑更好—-水 我希望我身体更棒—-还行吧 我希望我做饭能更好吃—-更难吃了 我希望我能努力考所好大学—-还行吧，被专业毁了 我希望我能更博学多才—-那肯定 我希望我能学到更多、不止是知识—-挺多的 我希望我能挖掘出我更多的潜能—-发掘潜能是痛苦的过程，方向不对发掘错了也不一定 我希望我能帮助到更多的人—-尽量吧 我希望我能收获到更多的友情—-这我不知道 我希望我的朋友们能够因我而快乐—-不清楚 我希望我不会让任何一个朋友为了我而伤心—-哦，我不知道怎么说 我希望我会珍惜每一个真心对我好的人—-哦好 我希望在每一个生日都能收到满满的祝福—-嗯 我希望偶尔也能收到几件小礼物、很贴心、也很开心—-哦 我希望我们的小太阳永远不分离—-哦 我希望我们可以完整的制作出一首真正只属于我们的歌—-完整做出来了三首自己的歌 我希望我可以在立夏到夏至之间的某一个阳光明媚的晴天里、在一个葱绿的小角落、抱着吉他、唱《晴天》—-唱得不好，只会弹前奏 我希望我们小太阳的愿望可以实现、我们可以在未来的某一个夏天看到我们在某一个山坡上亲手种下的向日葵—-本来是要种的，种的那天种子丢了，改种蒲公英了，隔年上山，未长 我希望43路车在我考上大学之前不要换新车—-换了，现在都换第二次了 我希望我家院子能很久以后才拆—-还没拆呢 我希望我能坚持在妈妈上下班的时候替她扛自行车—-在家就扛，哦现在她不骑了 我希望我爸爸能少生气、少骂我几句—-哄着点 我希望我的爷爷奶奶姥姥姥爷可以健康长寿—-好 我希望我的哥哥姐姐、我的弟弟妹妹、还有我家的猫咪、能够更快乐—-猫死了 我希望我的家人平平安安—-好 我希望我能再创作出几首好歌—-是不是好歌不知道，能听 我希望我能拍到许多有感觉的好照片—-在拍 我希望每天都有一点时间看一些自己喜欢的书、做一些自己喜欢的事、或者只是静静的听听歌、做白日梦—-你喜欢干啥 我希望我能遇到更多喜欢的诗、喜欢的歌、以及文章—-经常有 我希望我不要遗忘那些从前最单纯的快乐与悲伤—-没忘 我希望我能不断的留下一些美好的记忆、给未来—-做的不错 我希望我能开心地回忆过去、积极地面对未来—-好 我希望无论遇到什么事我都能够平静地面对—-还能更好 我希望我能够充实地过好每一天—-不管怎样度过，生命始终都是充实的 我希望我不会因为寂寞而随便找女朋友—-这个我可以肯定地说你做到了 我希望我即使一个人上学、一个人回家、一个人听着歌、一个人望着窗外、一个人走在校园、一个人路过人潮、也不会太孤单、也会开心的笑—-笑啥 我希望我能够坚守我的独立人格—-不存在绝对独立人格 我希望我能真正地享受一个人的快乐、不需要去羡慕别人的快乐—-享受了，就是我有时候还挺羡慕你的 我希望我能一直相信着亲情、友情、爱情、以及其他的一切美好—-我保持沉默 我希望能有一个真心喜欢我、并且我也真心喜欢的女孩子、然后在一起—-没 我希望我会珍惜一切—-嗯 我希望我能保持一颗纯粹的心—-嗯 总之、我要做我自己、做一个优秀的人—-你是你自己，什么是优秀 我相信、我能够努力让这些愿望实现—-16岁、我的愿望]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[卖萌的臭傻逼]]></title>
    <url>%2Fblog%2F2015%2F06%2F27%2F%E5%8D%96%E8%90%8C%E7%9A%84%E8%87%AD%E5%82%BB%E9%80%BC%2F</url>
    <content type="text"><![CDATA[今天，我遇到一个卖萌的臭傻逼。 他一直在图书馆窗子外面叫， 喵了个咪的。 整个图书馆的人都嫌他烦。 断断续续， 叫了一下午。 他一直在外面窗台上走来走去。 他好像想进图书馆。 他是黄色的。 外面一直在下雨。 我想过去把他放进来， 但是不是会影响同学们学习。 算了不装逼了。 雨越下越大。 叫声越来越惨。 有几个人时不时看他， 然后又低头学习。 我戴上眼镜看他。 确实是黄色的。 不看了学习。 他是不是被淋了。 淋死了咋办。 算了学习。 关我毛事。 不行我要去救他。 回宿舍拿伞。 我先去图书馆后面看看。 从来没去过。 就当探险了。 没戴眼镜看不清路。 算了踩水里就不好玩了。 回去拿伞。 回到了图书馆。 怎么不见了。 是不是死了。 就当他死了吧。 十分钟后。 这鸟人怎么又来了。 叫得一声比一声惨。 图书馆的同学们又看他。 你们为什么没人去救他。 我再看他一眼我就学习。 他好像在看我。 不行我还没有学习。 不行我出去一趟。 我拿着我的超级无敌酷炫加强版大黑伞。 我觉得我一定是遗传了我爷我爸救麻雀救蛇救斑鸠的**基因 我走向黑暗的图书馆背面。 这次戴眼镜了。 好像可以过去。 墙边没水坑。 我顺着墙。 前面是窗子了。 我看见他了。 确实是黄色的。 咪咪。 他不过来。 好像有所防备。 扔个树枝过去看看。 他没有去捡树枝。 后悔没带吃的。 不能再向前了。 否则就被图书馆里的同学们看到了。 那样太逗比了。 我蹲下从窗台下面偷偷过去。 这好像叫做蛙步。 打着伞。 我好像一个蘑菇。 到了。 他在窗台上紧张地看着窗台下的我。 眼睛很圆。 脸很小。 符合现代审美。 小母猫？ 不对长这么萌应该是男的。 他不安地在窗台上走来走去。 然后不见了。 我再往前两步。 确保视野无死角。 怎么真的不见了。 我检查了下空调机的缝隙。 什么都没有。 我去他从哪走的。 为何瞬间消失。 我眼神不好。 我认了。 不对我是来干嘛的。 不对窗台上好像并不会淋到雨。 上面有挡的。 醉了。 回去好好学习。 我回到图书馆。 坐定。 看看大家看我的表情。 并无异样。 还好没有被发现。 学习。 学你个头回宿舍。 完 卖萌的臭傻逼 2015.6.26]]></content>
  </entry>
  <entry>
    <title><![CDATA[但愿直面 你的孤独]]></title>
    <url>%2Fblog%2F2014%2F09%2F24%2F%E4%BD%86%E6%84%BF%E7%9B%B4%E9%9D%A2%20%E4%BD%A0%E7%9A%84%E5%AD%A4%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[“我不挽留，而他们也没再回来。” 我20岁，我会挽留，而我已不奢望他们再回来。 以孤独为话题，很容易就写得可笑而辛酸。 我是个念旧的人，或者说是一个喜欢赋予感情的的人。笔袋里的尺子，是初三的，上面有颗小磁铁，是从眼保仪上卸下来的，吸着枚一毛的硬币，2005年的；自动铅是前女友给的，陪伴我记录了17、18、19岁这三年，我不能扔了它。 可是你的旧物，你的朋友，你的才能，乃至你的生命，你所拥有的一切，不是总有一天会丢失的吗？ 你本一无所有，是拥有带给你恐惧。 我一贯不赞成，将人生想象得苦闷而无聊，即使它本来的面目就是这样，我们要相信一些美好的，才能从这个拥挤的世界里看到光。亲情、友情、爱情，你总得相信几样，有些东西明知道是错的，还是要去坚守，何况，这世界本无对错。我相信孤独的力量，那么我的心里就有光，“从茫茫人海中一眼就能认出你，因为你的身上有别人没有的光芒”，这样的人一般都是“独行侠”。那么，孤独是朋友，我想认识他。 你曾经在生日的零点以后，收到一条有一条的祝福，你以为那就是不孤独；你曾经刚写完文章，就看到大家长长的回复，你以为那就是不孤独；你不会忘记，你17岁生日那天，抱着满满一大袋快要装不下的生日礼物上了公交车，你以为那就是不孤独。可是呢现在呢？有谁还会清楚地记得你的生日，有谁还会写长长的留言？你以为你孤独了，你失落，你悲伤，你觉得无所适从了。 “虽然言语的波浪永远在我们上面喧哗，而我们的深处却永远是沉默的。” 人生而孤独，以我此生仅限的经历来看，孤独是一种常态，而不孤独则是激发态。“回顾我有生以来的岁月，发现还是孤独的时间最多，我对世界呼喊了那么久，才知道自己的声带有问题，喊声的频率不对，没有人能听到，人生不就是如此吗？”我们将处并长时间处于孤独的道路上，你独自奋进的身影那么远，你的频率又有谁能知道呢？正因为这个世界充满了不友善，友善才显得格外珍贵；正因为人生而孤独，所以才对陪伴的人心存感激。孤独不是结果，而是一个美好的前提。 当你翻开好友列表，你有300好友，但你再也无法去打扰谁。你看着他们的动态，觉得他们恍若还未走远，但你已经无法再插话了。屏幕对面的人怎么样，你觉得他应该在忙，纵使他理你又怎样，你和他聊天，只不过是为了得到片刻的慰藉，你不可能一直得到慰藉，你也不可能凭此度过此生，你对朋友的依赖太深，就无法独立。 对面你的好朋友发一句“哦”，你竟无言以对。 不是累了倦了，不是友情淡了，而是你要长大了。 于是你放下手机，戴上耳机。 但愿直面，你的孤独。]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[致最衰败的城市——兰州]]></title>
    <url>%2Fblog%2F2014%2F03%2F15%2F%E8%87%B4%E6%9C%80%E8%A1%B0%E8%B4%A5%E7%9A%84%E5%9F%8E%E5%B8%82%E2%80%94%E2%80%94%E5%85%B0%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[总归要为兰州写一篇文章，但没想到是用这样的标题。 出了兰州，我才对这座城市了解更深。我知道有很多人和我一样，离开兰州之后，才开始关注兰州的新闻，兰州的建设，以及关于兰州的一切琐碎事，我们会用近乎赤诚的心，搜寻点滴，不漏蛛丝马迹，维持着我们与这座城市微妙而又近乎痴狂的联系。 说到新闻，我就经常搜一些“兰州地铁最新进展”之类的东西，当然，如我所料，铺天盖地的无非是“兰州地铁10月开建（2012）”“有望年内开工（2012）”“将于今年6月全线开工（2013）”“有望明年2月正式开工（2013）”“兰州轨道交通本月中旬全线开工（2014.3）”之类的消息，更有甚者“第一条轨道线计划2010年建设，2014年建成（2007）”，随之而来的，一种失望，一声叹息。 后来会在贴吧上看一些兰州的新闻和数据，比听记者说会来的真实一些，然而有一则真实的数据却着实让我心头战栗，1978年改革开放前夕，兰州的地区生产总值（GDP）21.8亿元，名列全国20名左右，在省会城市中位列中游，而到2010年左右，兰州的GDP排名竟直接跌破全国前100。我不由地感叹，兰州的经济衰落速度，堪比坠崖。30余年来，兰州的经济指标不仅先后被郑州、太原、长沙、昆明、南宁、南昌、福州、合肥、乌鲁木齐、呼和浩特等十余个省会城市反超，而且更是被数以十计的非省会城市竞相秒杀。我只能说，惜哉，痛哉。回顾历史上兰州的几次辉煌，秦汉文明，已太过遥远，那时黄土高原还是一片郁郁葱葱的森林；隋唐盛世，也暂且不提，丝绸之路的繁华往来早已成为往事。我们就且从清朝看起，从清中期1764年，陕甘总督迁兰州府，兰州开始总督甘陕，抚控西北，“节制三秦，怀柔西域”，成为整个西北地区的中心城市；到清末洋务运动，兰州织呢局（中国第一家机器毛纺织厂）、甘肃制造局（今兰通厂）纷纷建立，黄河上第一座近代公路桥梁“第一桥”（今中山桥）建成通车，甘肃法政学堂（今兰州大学）成立；再到新中国初期，“共和国长子”——兰炼、兰化建厂，兰州成为新中国第一个石化重工业基地；最后到近年来，GDP在全国100位左右徘徊，城市综合实力逐年被大量城市超越，甚至连曾经周边毫不起眼的“小弟弟”城市们也都已经接连发出挑衅，跃跃欲试，兰州，已经俨然不像一个西北第二大城市的样子。我不禁要问，兰州，你去哪了？可是兰州还在这儿啊。不禁想起当年在外上学的姐回来给我说：“每次出去，就发现那儿（指她学校所在城市）又有了新的变化，每次回兰州，却发现和半年前还是一个样。”当时我就觉得，好像真是这么一回事，现在回头看，“我说我怎么觉得自己以前一直生活在一个安定平和、幸福而不多变的城市之中呢。”可见，在全国各大城市都在飞速发展的时候，兰州却一直都在缓步徐行，兰州近几十年来的衰败，有目共睹。 兰州的衰败是有很多原因的，地形因素便是其中之一，黄河河谷带状盆地城市，这是我对兰州地形的定义。去过兰州的人都知道，兰州市区特别的“长”，以至于别的城市的市区图都是方或长方的，而兰州市区图是“奏折”型的。东西长，南北窄，是黄河赋予这座城市与生俱来的特点，以至于你在市区的几乎任何一个地点，都能看见山的踪影，他们属于兰州的“南北两山”，就因为这个，每当我离开兰州而到达一个平原上的城市时，心中都会有些许不安，一眼看不到尽头的平原，没有了山给予我厚重的安全感。因为我早已习惯了，一抬头就能看见一堵山，走两步就能看到黄河的日子。就这样，从某种程度而言，兰州是被“挤”死的，两山夹一河夹成了三明治，兰州就是里面的生菜，该用的地用完了，能用的地也用完了，怎么办？我们可以看到兰州市区内高楼密度相比其他城市还是非常大的，两个字，“逼的”，别的城市有的是发展空间，而兰州没有，殊不知在兰州还时不时地开展着真人版的“愚公移山”，那把楼建得更密集就是情理之中的事了。传言兰州市部分地段人口密集程度超过香港，传言的真实性还有待考证，但是形象性我觉得还是蛮形象的。许多南方的朋友总是固执地认为，兰州地处西北，应该缺水，却不知兰州这座城市，水资源丝毫不愁，土地资源却令人堪忧，想在市区周边找块地来大肆开发一下，实属不易，这也就成就了兰州这座西北“千年老二”的城市，唯独房价出类拔萃，直指第一。 地形的影响还不止于此，更在于交通，市区的交通就不用赘述了，东西贯穿的就那么几条道，不堵才怪，不是有个笑话，一个西固的哥们大清早叫一个东岗的哥们：“快过来我请你吃饭”，然后他们吃的是晚饭。据我观察，兰州是修路最频繁的城市之一，当然不是修新路，是挖开重修，而且刚修好的路一般过两个月就又有“补丁”出现了，为啥？车太多，压的，尤其是大车。兰州去年开始施行8吨以上大车禁入市区，可是为什么还会有车偷偷地入？一是还有很多工厂在市区内，这个暂且不说，二是过境车辆不过市区你让他怎么过？过境交通体系的不健全，使老城倍受交通压力。兰州恐怕是全国为数不多的没有绕城高速的城市之一，为什么没有，为什么不建？因为没钱，当然这只是一个因素，更主要的是地形，纵观兰州周边的高速高铁，我们可以明显地发现，这些工程的桥隧比都普遍高达75%左右，这个数据要是放到平原地区简直就高得不可思议，这意味着什么，这意味着这些高速只有四分之一甚至不到的路程是在平地上直接修的，其余都要打洞或者建桥，要知道建这样一条高速，同里程所需投资和工期都比平原之上要高很多，这样一来，没有钱似乎就变得很正常了。 地形还不是兰州衰败的主要原因，兰州衰败的另一大因素是老国企的衰落。作为一个90后出生的人，我对兰州众多老国企兴衰的了解，“兴”来自父母口中，“衰”则是我亲眼所见。我出生在省建预制厂的职工家庭，虽然后来这个厂子几经易名，但是都无法改变他衰败的事实。后来经常会看到厂门口两侧的竖牌加了又加，我知道，那是厂领导又把地租给别人了，再后来，干脆在从前一大片厂区的入口处起了一个富丽堂皇的名字，“工业园”，一个多么让人哭笑不得的字眼，其实只能充满讽刺地证明，曾经辉煌一时的老厂早已支离破碎。事到如今，我只能望着那些窗户全破，墙面也黑乎乎的老厂房，想象着当中热火朝天，齿轮滚滚的景象；只能看着墙面上偶尔残存的“文革”式字体，描绘出当时工厂工人下班时车水马龙的喧闹；只能透过奶奶厨柜里那只印着“甘肃省建预制厂企业整顿合格纪念”的瓷碗，看到父母语气中的骄傲；也只能看着厂门口“十人合抱”的老槐树，看着他枝繁叶茂。厂子里的人都说，老槐树死了，这厂子就再没有活过来。回想老槐树死的那一年，正值90年代，厂子的衰落，和兰州的衰落几近同步。已经数不清兰州有多少名噪一时的老国企，那些名字从老一辈人口中说出时总显得如数家珍，单就我所知道的，兰炼兰化排除在外，兰棉厂、三毛厂、兰高阀、玻璃厂、洗衣粉厂、兰州制桶厂、西固食品厂、兰石厂、兰通厂、二通厂、三通厂、一毛厂、二毛厂、四毛厂、客车厂、阀门厂、504，还有春风电视机厂，一个个揪心的名字，我相信这还只是兰州众多老国企之中的冰山一角，这些企业大都早已不复往日辉煌，破产或是名存实亡。有一次我有些好奇地问我妈：“那个1872年建厂的兰通厂怎么样了，是不是都应该被当做文物保护起来了？”“那厂子跟预制厂差不多，半死不活的，工人们也全待家里发不出来工资着呢。”一个时代的远去，势不可挡，昔日的辉煌，遥不可及，时光给了兰州一记响亮的耳光，呼呼生风。这座以重工业为主，产业结构蹩脚的老城，失败似乎在半个多世纪前就已经埋下伏笔，综合实力极度下降，GDP从20到100，多么痛的领悟。 除了这两个因素以外，我认为最致命最核心的一个因素还是在于人才流失。兰州，这座黄土高原之上的城市，人才的流失远比他湿陷性黄土的流失要严重得多。有人说，十年内，从兰州大学流失的高水平人才，完全可以再办一所兰州大学。兰州，留不住人。兰州的小孩普遍从小被灌输着一个思想：“要去东南沿海大城市，要去东南沿海大城市，要去东南沿海大城市……”满脑子的“东南沿海大城市”，仿佛“只要出兰州，我就成功啦！”。不妨说说，其实原来我也有这样的心态。“离开兰州”是每个家长、老师挂在嘴边的“别人家孩子”，闪闪发光，成功的标志。无论你去做些什么，无论你过的怎么样，只要你离开兰州，你就会高人一等。事实上也的确这样，有本事的出兰州，没本事的留兰州，这几乎已经成为一个定律。于是兰州就这样培养人才，失去人才，培养人才，失去人才，周而复始，兰州也就几近变身一个向外输送人才，向内吸纳庸才的集散地。虽然占着一所985综合类大学，但是高端人才的流失，还是使兰州在最宝贵的资源上丧尽优势。当然这也是有其中复杂原因的，首先便是缘于兰州私企、外企的缺失，大部分公司都是工资低、待遇差，这样一来，高端人才就算是想留兰州都难。兰州这座城市居住起来确实非常幸福舒适，换句官腔来说就是“宜居”，但是当“留兰州”与“好待遇”不可兼得时，不少人还是会选择“好待遇”，“人往高处走，水往低处流”，东部地区对人才的吸夺也是很正常的事情。但是，人才的流失还有一个更深层次的原因，那就是深深根植于兰州人心中的一种自卑情绪。有人说兰州人好面子，特别在意别人对自己的看法，这其实是自卑的一种体现。其实，兰州人更在意别人对兰州的看法。不知道有多少人和我一样，一出兰州，便急于向别人宣传兰州多好多好，兰州不是大沙漠，我也不是没水喝，那里回民真不多，兰州大学真不错等等。为什么我们会有这样的举动？为啥？都是因为自卑，因为我害怕啊，我被外地人对于兰州近乎无知的了解吓怕了，我害怕别人以为兰州是大沙漠，以为兰州人没水喝。按理说，心理学上讲，一个人缺什么就会炫耀什么，可是兰州什么都不缺啊？是的，兰州什么都不缺，但就是缺一个他应得的、正常的、与之相符的名誉，这也正是我们急于这样做的原因。我们害怕的是别人误解了兰州，因为遍布全国各地（除了兰州）的那些所谓的“兰州拉面”早已把兰州的形象毁的是一干二净，殊不知那些面馆大多和兰州没有半毛钱关系，因为它们根本就不是兰州人开的。出门在外的兰州人自卑，而没出过兰州的人更自卑。我们从小就对这座城市恶言相向，骂兰州成为了一种习俗。太多没出过兰州的人幻想着外地多繁华多高端，于是兰州在他们的眼中就显得一无是处，丑陋不堪。他们只想着如何脱离苦海，逃离兰州，却何曾了解他们的幻想太美好太天真。城里的人想着出去，城外的人想着回来，兰州人的自卑仿佛踏入了一个死循环。而兰州人对这座城市的失望与绝望，就像一剂不温不火的毒药，迷倒了整座城市的神经。如果你是一个兰州人或者曾经在兰州生长过的人，不妨停止妄自菲薄，重拾对兰州的自信，改自卑为谦卑，骂兰州也好，夸兰州也罢，“君子讷于言而敏于行”，兰州就在那里，兰州的衰败就在那里，就看你怎么做。 不可否认，兰州的衰落还有政府、政策以及其他多重的原因，在这里就不一一细说，但是兰州衰落的速度为何如此之快？这就不得不提到“兰州速度”。在许多兰州市民的字典中，“兰州速度”就是慢的代名词，还不只是慢，是非常慢、相当慢、超级慢，慢到简直没法在慢前面加一个合适的程度副词。不止是早晚高峰时段的车速慢，更主要的是城市的开发建设慢。堪称“世界公路建设史之最”（最慢）的南山路，很多很多很多年前就提上日程了，很多很多年前就听说在建了，很多年前就说有望完工了，结果现在还在建。2003年兰州红山根体育场拆除，随即要在崔家大滩启动建设兰州奥体中心，国务院都已经批复同意，结果到现在（11年后的2014年）还连根羽毛都没有建起来，唯一的成果，就只有地铁路线图上一个堂而皇之的站名奥体中心站赫然在目。就是这样的速度，怪不得会有兰州人在谈论到地铁的时候调侃地说：“我这辈子估计是坐不上了，就看我未来的儿子（或女儿，还不确定）能不能坐上了。”兰州的每一个工程，永远像是患了重度拖延症一样，拖了又拖，令人咬牙切齿，触目惊心。兰州铁路局的火车还偶尔早点，但兰州的建设好像还真没按期完过工。这神一般的“兰州速度”，让每个兰州人对其恨之入骨，一如其爱之弥深。也正是这样的速度，让兰州的衰落速度“一马当先”，真可谓“兰州速度”也。 有些网友辩解说，“兰州虽然GDP落后于人，但是科教、文体、医疗卫生方面还是无法轻易被赶超。”，没错，正所谓“百足大虫，死而不僵”，这些软实力确实无法轻易被超越。可是10年后、20年后呢？兰州大学近年来为什么会衰落？为什么在当年美国《科学》杂志中排名全国第六，而在最新武书连排名中滑落全国第27？还不是因为兰州！兰州经济发展的好，兰大会衰落吗？倘若回到史上“天下称，富庶者无如陇右”之时，兰州地区的科教文体等软实力会差么？现在的兰州，就像一个家道中衰的豪门子弟，面对着一群土豪暴发户，倘若不趁早发力发展，迟早有那么一天，土豪很轻易地变成了高富帅，而兰州，则成了永远扶不起的穷屌丝。 最近几年，兰州好像也逐渐在苏醒、发力。地铁、会展中心、元通大桥、深安大桥、金雁大桥、红楼、金茂、兰州中心、兰渝铁路、中川城际、宝兰客专、西客站、还有每个兰州人津津乐道的第五个国家级新区——兰州新区。兰州新区的获批，一度被视为均在兰州生活工作过多年的胡锦涛、温家宝卸任前送给兰州人民的一个礼物。可是我们能抓住机遇么？建设的显然还是显示出兰州的风格——“慢半拍”。结果，2014年1月，国家在西部连批两个国家级新区：陕西西咸新区和贵州贵安新区。这下傻眼了，这消息无异于当头棒喝，敲醒了沉浸在获批国家级新区的喜悦中的兰州人民，兰州新区西北唯一国家级新区的优势全无，竞争压力很大。说实话，如果我不是兰州人，要投资，我应该会选择西咸，同样是国家级新区，为什么不选择在相对富庶便利的关中平原而要选择在黄土高原呢？也许我目光短浅，这样看来，兰州的崛起依旧举步维艰。 1925年，国父孙中山逝世，在其临终留下的《总理遗教》中念念不忘“中国的国都，须建在兰州”，足以见得兰州战略地位的重要。新中国“一五”、“二五”期间布局大量工业于兰，也可见当时国家领导对于兰州战略地位的重视。但是，改革开放以后，随着计划经济的解体以及国家的全面对外开放，随着东部地区的迅速发展和西北地区的全面落后，兰州，还剩下什么？是不是只剩下一个“战略地位”的空壳？ 兰州发展的上一个黄金时代已经远去，兰州近几十年来的衰败已是历史必然，兰州正处于他的低谷，兰州能否重返往日辉煌还尚未可知，但是兰州期待着触底反弹，兰州的发展已经刻不容缓。 从兰州出来的乐队低苦艾说：“我们每年都会回来，和你们在这个破败的城市里相聚。”但是，“我爱兰州。” 我几乎从每一个兰州人脸上读到他们对这座城市不离不弃、有血有肉的热爱。 “我在黄河边长大，我想有一天我也会在这里老去。” 兰州的崛起还有一线希望，因为我知道有太多太多和我一样一腔热血热爱兰州的人。 但是兰州的悲哀在于，热爱兰州的你，此时在做些什么呢？ （19岁少年拙见，见识鄙陋，文中纰漏百出，且不含任何讽刺、抨击、批判之意，仅抒发个人思想与情绪耳，望以一己之力而助兰州，若有得罪，望诸位见谅，切勿断章取义。）]]></content>
  </entry>
  <entry>
    <title><![CDATA[19]]></title>
    <url>%2Fblog%2F2013%2F09%2F24%2F19%2F</url>
    <content type="text"><![CDATA[19，每一次生日都有要写一篇日志的习惯，到现在已经是第四年了吧，从高一时的傻里傻气、无畏无邪到高二高三的阳光耀眼、精彩辉煌，再到大一时的沉郁孤寂、昏暗无华。现在的我，已经好久找不到，那种积累起每一天路途上的灵感，来拼凑起一篇日志的感觉了，于是，我只能像是应付差事地在生日前一天，在这图书馆里，写下这些随口就说的文字。 之前的每一篇生日日志都是要生日当天发出来的，为此也费了不少周折。我家一直没电脑，当然我说的是钟家河。16岁那次是到跟我关系极好的发小小兄弟家打的，17岁是在丁一，就吧台后面那片，具体哪台我也记不清了，18岁就已经是在大学机房了，这次也不知道要去哪发，估计是南京的哪个网吧吧。 还记得16岁的那篇日志，好像是我想，想了很多的事情要做，当然其中有很多现在都没能做成，也有很多没做成但是依然在做，这是我当初早就料到的结果，现在还留下的应该是真正的渴望了吧，17岁的好像是一个勉励自己的，因为当初感觉自己要失恋，结果后来就真失恋了，当然这都是后话了，我这人有个特点，每次感觉“她喜欢我”，那肯定是一个错觉，而每次感觉“我要失恋”，然后就准了，18岁《再见王子》，写完后好像就真的和王子再见了，找不到一点原来自己的样子，过得很黑暗。 之所以说到这些，是因为现在回过头来，就感觉这一切离现在的我都很遥远，不知道是不是离家1764km的原因，感觉自己与原来的自己处在完全不同的两个世界，也就是传说中的“恍如隔世”。又提到南京，总感觉我真的是不大喜欢这座城市，但是也谈不上讨厌，毕竟是我现在每天生活着的地方，这里的人民待你也不错，也有着不少好人，不喜欢，完全是性情所致。如果要给个综合评价，那就是我觉得“还不错”，就是不适合。 关于“恍如隔世”，我觉得这确实是对我大一一年最准确的解释，用我口头些的一句话就是“这差距有些大”，我在南京和兰州的表现简直是判若两人，这和气候有一定的关系，但终究是多方面因素造成的，没养成一个适合自己的良好习惯，应该是根源所在。以前，每天的作息都很规律，所以也过得很开心，至少是很扎实，6:30起床，赖到40，起来狂穿衣服洗脸，坐45或50或55的43，到的早就门口买个鸡柳夹馍或者菜夹馍，到得晚就下了车一路狂奔进教室，至于中午就是两趟43，晚上回家又是一趟43，在车站还有很多朋友在那谝啊谝，动不动还会来句“人太多等下辆”，然后又是五分钟。现在想起来那生活真是无比的安逸，主要是歌听的比较多，每天4次43，就是两个小时，而且还是在车上听歌，感觉那真的是当初每天最好的享受，也是最好的调节，听着歌，然后什么坏情绪都忘记。我真的很喜欢这样的生活节奏，其实，离开了才发现，西固区更像是一个世外桃源，不止一个人对我这样说过。到了南京以后，首先公交车是没机会坐了，偶尔想坐个公交车，又发现南京的公交系统极度的混乱，而且还比较贵，大街上总是停着那么多自行车电动车，大概南京的市民是不怎么坐公交车的。这只是一个小小的例子，总之，一切都与以往不同，于是，生活变得混乱，什么都开始变得不顺心，而且再也没有从前那样一个发泄情绪的出口，一切都变得天昏地暗。不断袭来的，一方面是偌大的世界仿佛只剩我一人的孤独感，一方面是没有习惯的混乱的恶性循环，感觉真的很艰难。 前段时间把电脑上游戏全删了，把手机上的社交软件也全删了，其实就是想找到一个适合自己的节奏，把手机装满了以前p3上的歌，发现有很多歌一两年来再也没有听过，把钢笔灌满了水，才发现里面早就堵住了，很多的好习惯，丢掉了就再没有拾起。从前，没有电脑，拿个mp3加个上网功能基本上算作废的国产200块钱小手机，怎么能那么开心，而现在，开手机刷这个刷那个刷这个刷那个，要不然就是对着电脑屏幕发上半天呆，不知道怎样才能高兴点，这或许就是关键所在。 那天，马哲老师说，现在的许多所谓的大师都教导着人们怎样怎样才能成功，功成名就，达到自己的目标，而孔子呢，则是教导人们如何“心安”。我一下就觉得这节课好像也不是很水，孔子总是为我们讲述什么是君子，怎样做一个君子，因为做一个君子，则心中自然安定平和。而且孔子提倡一种“风乎舞雩，咏而归”的生活追求，其实我也一直很赞同他，就像我很喜欢坐43，坐后排吹着风听着歌，这样就已经足够，那种感觉无法用言语来形容。 至于“心安”与成功，他们完全不是什么对立的东西。要成功，“心安”会使成功更加容易，而成功又是为了什么呢，为了“心安”，至少我这么认为。总是会看到空间里，有人又喝了星巴克，又吃了哈根达斯，我一开始就想，真有钱，然后我就问自己，这是你想要的生活么？然后答案就很明了了，我就算喝十杯星巴克，吃十个哈根达斯，也比不上我吃完牛肉面坐上43听歌的感觉好。我们很容易去追求一些虚拟的虚荣的东西而忽略了心灵的本真。我们总是刷手机而不和身边的世界沟通，我们总是坐在电脑前而不去选择出去走走，网上总有些人在那发着些什么瞎胡扯的东西，就像以前玩LOL总有些人在那骂来骂去。后来想想，那都是些什么人呢，无非是整日无事，没有大脑，泡在网上想要找点乐子的人，你想和他们一样么？不想，那么我想你已经知道该怎么做了。 其实，有很多话想对自己说，只是说了太多我想也会疲惫，每次写日志都会配上一首歌，16岁的《小时候》和《再见小时候》，17岁的《生还者》，18岁的《再见王子》，19岁呢？一首《初爱》致从前的自己，一首《稻香》给现在的我。 刚翻了一下以前的那三篇日志，真的有很多的宝贵的东西已经遗失了呢，还好，我现在已经有勇气找回他们了。 你一定可以的。 一定可以的。 加油，小太阳]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[致女朋友]]></title>
    <url>%2Fblog%2F2013%2F06%2F14%2F%E8%87%B4%E5%A5%B3%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[是不是每个像我这样的男生，心里都有一个一直陪伴着你的女朋友呢。 那些每年一起过情人节的兄弟们，你们还好么，现在是不是有妹子了呢？ 没有妹子的，你们看了这篇日志会不会也有同样的感受呢。 我也是突然就想写下这篇日志的。 刚才去操场上跑了十圈，一圈估计是400米吧。很久都没有这样跑过了吧，跑完坐在操场的假草皮上，就坐在足球场的白边线上，看着黑下来的天空，看着空荡荡的操场，操场的围栏，外面的树木，就想着我要是有个女朋友，她会和我坐在一起，一起坐在球场的白线上，我会给她说我今天好高兴啊，我今天终于发现一个人也可以蛮高兴的，好久没有长跑了，在跑步的时候，我就觉得我自己是一个英雄，至少是自己的英雄，哈哈。然后我唱着《开天窗》，是谁说半夜不能吃便当，唱着《知足》，怎么去拥抱一夏天的风，就好像你在一旁听着，又好像你听不见。 我好喜欢你啊。 每当看到喜欢的景色，每当做着想做的事，你都会出现在我身边，听我说，看我笑，目光沿着我手指的方向，让我偷偷给你拍照。 其实你一直就这样在我的生活中，形影不离，你说我是不是个自恋狂呢。 其实说实话，我一直以来对朋友的依赖都很大，不过还好之前我运气一直都不错，每次都能遇见那么些跟我一样，可以和我一起傻不啦叽一起走的兄弟。以前做什么事情都有朋友，也一直把友情看的挺重，见到个朋友也特开心，笑的跟个花一样的，当然这只是我自己想象的，笑起来估计挺二。 总之就是有些离不开朋友。 这可能是我现在最大的弱点了。 人总是要经受住孤独的，每个人都有不同的路，我们终究要各奔西东，终究要一个人奋斗，一个人吃饭，一个人上课，一个人做所有的事，一天下来一直都是一个人，其实这都是很正常的，之前一直地抱怨这些，说这些孤独的感受，其实也改变不了什么。或者一天到晚拿个手机一直刷，微信人人微博空间贴吧，看看有没有人找我说话，生怕漏掉了哪一个人给我的留言，生怕没有及时回复你们的话。离不开手机，是从什么时候开始的呢，从我感受到经不起孤独的那一天开始，大概高中就开始了，不过那时只是在家用，高三扔下了半年手机与世隔绝的感觉，但是其实每天上学的时候那朋友还是一抓一大把的，所以一直都没能摆脱对朋友的依赖。那天把QQ状态改成了Q我吧，刘文婷还截图发了个感觉我好可怜，其实我原本根本没想到这一点，我只是偶然间想起了还有这个状态觉得挺好玩，还能置顶多好多帅多拉风是吧。她反倒把我给提醒了，挂一天也没人跟我说话，看起来是挺可怜的，不过我还是觉得挺好玩的，我看别人都不用就我一个人用，嗯不错。 一个人，独行侠，这才叫真正的霸气是吧，只不过一般人都做不到，我觉得我也只是徒有其表而内心挣扎，学会孤独，尤其对我来说，真是个很难的课题。其实以前孤独的时候，一直是有个你在身边的，你特别好，总让我感觉我还有力量，后来写了个《再见王子》，好像就把你给抛弃了，抛弃在家乡了，也不是，说好的要并着你的勇气一起坚持呢？那还是抛弃了。 前一段时间的我，肯定你也不会喜欢吧，我也不喜欢，但那就是我啊，没有经历这些哪来的收获与感悟，其实挺好的。你都看到了，我这一年的状态，你肯定想骂我，但你肯定会对我笑，因为你知道我是好人。你会说，景色没人看到，感受没人分享，其实也没啥，独行也有好的一面，不紧不慢，比较自由。 一个人，一个人，一个人，没有志同道合，没人跟我说想说的话，没人和我听一样的歌，没人想组乐队，没人和我打羽毛球，没人跟我跑步做引体向上，没人热衷于玩红警三，没人喜欢拍照，没人乐于旅行。他们都完全被绩点学分或是LOL所困。 只听见你对我说，这些都不能是你活的不够精彩的理由，一个人就不能奋斗了？一个人就不能快乐了？一个人就不能做自己想做的事了？什么屁话。 远离家乡，没有朋友，没有亲人，也没有那熟悉的土地和槐树香。 天地间仿佛就剩下了我一个人，我就笑了。 那又怎样，你不是一直都在呢么。]]></content>
  </entry>
  <entry>
    <title><![CDATA[I wanna write down the dream]]></title>
    <url>%2Fblog%2F2013%2F04%2F27%2FI%20wanna%20write%20down%20the%20dream%2F</url>
    <content type="text"><![CDATA[我们在一个陌生的实验室大楼外围转来转去，我的同伴的身份在梦中还很模糊，我们终于找到了坐在办公桌前的有机化学老师，她穿着白大褂，对我们说了些什么。之后我看到一辆大巴，上面有我爸，我坐了上去，大巴开啊开，跨过了一个很长很长的大桥，下面的河我感觉像是黄河，因为那河的黄色和岸边的树我都让我觉得很眼熟。 又过了一段时间，我突然出现在炼二的教学楼里，我抬头望着“高三二班”的班牌，迟迟不敢进去，我觉得里面应该都是学弟学妹了，我很难受，决定下楼买吃的，我下楼，走到一楼发现从这个楼梯出不去，出口被一个玻璃橱窗挡住了，外面的学弟对着我笑，我觉得很尴尬，我想学校的变化我都已经不知道，这把人丢完了。 于是我回到楼上，准备绕向另一边，不知不觉却遇见了陈辉，身边也多出了两个人，陈俊儒和李柏杭，一白一黑的衣服，只有我穿的校服。陈辉让我们每三天一起做一张语文卷子，每做完一张来找她取下一张，陈俊儒拿出一张做完的卷子给她看（什么时候做的），她给了我们新的一张，看样子好像是群力还是楚星，然后我们就一起下楼，边下楼边讨论按陈辉要求这样做卷子对成绩的提高有没有帮助，我说我挺懒，我可能没时间做，他们好像没说话，我说，好吧，做吧。 然后陈俊儒就消失了，我和李柏杭从教学楼出来往大门走，走着走着，身后跑来个小学妹，拿了个礼物好像，我就暗自想，估计又是哪个学妹喜欢我了，正开心呢，结果小学妹是把东西送给了李柏杭，我很不爽啊，李柏杭看出来了，问我“你是不是特不爽，我刚也还以为她跑过来是找你的一个。”他长满痘痘的脸就是堆满了那种说不上来的笑。他打开礼物跟我晒，原来是个小本子，然后他又拿出几个小本子来甩啊甩，我顺手抢过来最大的一本绿皮的翻开看，发现好像是窦一秀送给他的，前几页写满了鼓励的话，我继续往后翻，发现了李柏杭的听写，不多，十几个单词标着序号，可他只错了一个。然后我就拿出我的听写本给他看，只对了三四个，有些单词不会直接写的汉语，我就问他这个词咋写，他说corper，我说这么简单我都不会，就问他，你说英语怎么学呢，“就那么学呗，我也不知道”然后稀里糊涂讲了一大堆。他突然说他要回安宁了，我问，明天还来呗？“当然了，不是要一起做语文卷子么。”然后他就走了，我一个人在校门口的台阶上收拾书包。 过了一会一个眼睛大大的特心疼的妹子穿校服从学校里走出来，然后我就盯着她看，她发现了我，也盯着我看，然后她越走越近，越走越近，直直地就要走到我面前了，然后嘎嘣一声，她踩到了我还没装进书包放在地上的铅笔，“对不起”，然后她就走了。。。 又过了一会儿，又有一大波学弟学妹们从学校里出来，我心想他们这是才下课么。突然，人群中高出别人一头像一根大葱一样的张钰祥，没穿校服穿着个蓝棉袄就向我径直冲来，他说，你怎么来了，然后我还没来得及回答他他就不见了，我愣了一下，等我回过神来发现他已经在一边被学妹在脸上挖了几道子，脸上还贴着酒精棉。。我说，你这是怎么惹人家学妹了，是不是因为你抓癞蛤蟆那个事，这不毁容么。然后学妹在人群中被簇拥着到了马路对面，我和张钰祥也跟了过去，然后我就说了学妹几句，学妹也没理我，就是不说话，然后张钰祥就上前用手横过来砍她脖子（就你当年说要对张明刚做的那姿势，张钰祥你懂的），然后又轻轻扇了学妹两饼子，我看着就感觉不疼，他对学妹说，“我这只是意思一下”。然后呢，然后我就醒了。。。 这梦说明了什么，我也不知道。]]></content>
  </entry>
  <entry>
    <title><![CDATA[再见王子]]></title>
    <url>%2Fblog%2F2012%2F09%2F24%2F%E5%86%8D%E8%A7%81%E7%8E%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[真实是唯一的信仰，自己是唯一的偶像。 很高兴我现在，我的十八岁，依然是这样。这篇文章有几段未完成的原稿，但是被我落在了兰州，很可惜，我已经忘得差不多了，这篇本来打算在高考之后就发表的文章，被我一拖再拖，没想到到了现在，却要在这漂泊异乡的时候写下来，作为给自己十八岁最好的礼物，这样子，貌似会更加的刻骨铭心吧。 十八岁生日，以前盼望了很久，总以为那会是很重要，很美好，很难忘的一天。然而，事实呢，在一个远离家乡陌生的地方，和一些还不是很熟的同学，想着想坐却坐不到的43，却还听着那些从前在43上天天听着的熟悉的歌，我想，这大概会是我十八年来最孤独最冷清最落寞的一次生日了吧，不过，成人礼么，或许就应该是这样一种特殊的历练，不是么？ ​ 再见王子。 怎么说呢？在我的意识之中，或许存在着另一个平行时空，在那里住着另一个自己，他是一个很优秀的人，真的很优秀，而且他有一个很善良，很单纯，并且很可爱，当然也很喜欢他的女朋友。他总是很乐观，他总是会很自信地笑。面对困难，他总是比我更有勇气；遭遇挫折，他总是比我更加坚强。当我收获进步而暗自得意的时候，我总是能够看到他谦逊的姿态；当我遭受打击而倍感失落的时候，我总是能够看到他温暖的笑容。他就这样陪伴着我，像空气，像一阵风，像一个影子一般的存在。 他有着风一样的自由。他总会在人群之中穿梭，以自己的节奏。从一条大街到另一条大街，从一个路口到下一个路口，像风一样，逆着人潮，就这样穿过浮华与喧嚣，迈着坚定的步伐，带着灼热的目光，走向那未知的远方。 他有着近乎完美的品质，有一颗完美主义的心。每一个想做的事，他都会认真尝试；每出现一点瑕疵，他都会力争完美。他会弹吉他，会唱歌，会编曲，会制作，他会一切我想学或是正在学而尚未精通的东西，他精通历史、地理、数学、哲学，他比我更加博学多识。“天行健，君子以自强不息”，他总是想让自己更加优秀；“地势坤，君子以厚德载物”，他总是能够放下自私，真诚地对待一切。 他还有一张阳光一般明媚而温暖的侧脸。不管心情怎么样，他都会给周围的每一个人一份阳光，一份温暖的笑。他的乐观，他的自信，好像是我永远都学不到的财富。 正因为这样，他有很多好朋友，很多很多真诚的好朋友。 无论在什么样的环境下，他还是时刻保持着自己特立独行的姿态，坚守着自己的灵魂，他始终我行我素，他有着他的风格，他从不退缩。 他总喜欢顶风前行，我能感受到他炽烈的勇气；他总喜欢冒雨奔跑，我能感受到他挥洒的执着。无论认定的方向多么深不可测，他都会选择尝试；无论四周的黑暗多么浓厚而沉重，他都会握紧光明。 因为他有着纯真的梦想，并且他知道，梦想总会到达。 而现在呢？ 他微笑的脸，好久不见。 我离开了他住的城市，离开了他无比热爱着的家乡，离开了他熟悉的街道，离开了他所习惯的生活的色调。 嘿，我是要离开他了么？ 再见，王子。 要和从前略带稚气的自己告别，却又要紧紧地握住一个真实的自己，这会是一种怎样的蜕变。 我不知道。 仿佛又能看见他，看到他温暖的侧脸，他就那样像往常一样微笑着对我说：“你可以的。” 是的，我可以的。 我会并着你的勇气一起坚持。 再见吧，我的王子，梦想还没有消失。 再见吧，王子。 再见，王子]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那些你再也回不去的时光]]></title>
    <url>%2Fblog%2F2012%2F08%2F10%2F%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%86%8D%E4%B9%9F%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E6%97%B6%E5%85%89%2F</url>
    <content type="text"><![CDATA[高考后的暑假，就这样稀里糊涂地过去了，早就想写几篇日志，到现在才提起笔来，却发现自己已经不会写字了。 要不是那一天又一遍听到《老男孩》，貌似我也并没有什么太大的感触。就好像这只是一个跟往常一样再普通不过的假期，就好像开学以后又要回到那个带了六年的讨厌的学校，就好像还是要天天坐着43，在车上想今天会不会不迟到。也许现在说出来会有些好笑，但是在心底里，更准确地说应该是潜意识里，我一直是这么认为的。就这样，离要走的日子越来越近，直到那一天听到那句“各自奔前程的身影匆匆渐行渐远”，我笑了，我突然意识到，有些事好像是再也不会发生了吧。 一个假期究竟改变了多少，我只感觉到日复一日的颓废，我要去哪里，我要干什么，我是谁，这种问题在假期里总是懒得去回答，以前天天坐在43上却能思考得很多。有时候就觉得，坐公交车成了我的一种习惯，似乎我只有在公交车上才更能静下心来思考到很深，很多。真的不知道以后坐车的机会少了该怎么办，再也没有了，我的43。 ​ 有些事情你事前会觉得很重要，而事后却发现它原来并没有想象中那么重要，有些事情你当时会觉得再平常不过，而总有一天你会发现，它对你来说是多么的重要。 我说的，前者是高考，而后者，则是这三年以来的高中生活。 我承认我的高考很失败，而我也真心觉得，高考并没有想象之中的那么重要，它只是一个目标，而不是一个结果，真正让我觉得重要的，是那一年那一颗不知疲倦勇往直前的心，是那时每一天无比坚定的步伐，最重要的，是那时的那一种简单而纯粹的信念。 要走了，我马上就要离开这个十八年来我一直未曾远离的城市。有时候还真的有些手足无措，还想着在阳光明媚的校园里打羽毛球挥洒汗水，那种感觉比球馆里爽得多，仿佛还可以在生物课上写化学，化学课上写数学，数学课上写物理，物理课上认真听讲，然后，被生物老师赶到教室后面罚站看风景。多么想再多不写几次作业被老师柴,多么想再迟到几次，多么想再上课偷吃方便面，多么想再假装上厕所，我大课间还是想去买袋洋芋，早饭还是想抢同桌的面包。原来总觉得我高中三年啥都没干，到现在才发现值得回忆的其实很多。只不过，好像也只能回忆了吧。 仿佛每周六张钰祥还是会等在教室门口喊着：“nāi子，快些，等会没机子了！”，仿佛还是会带着轻快的心情迅速地收拾起书包，仿佛还是会出了校门一路狂奔，仿佛我们还能够很熟练地脱下校服，仿佛我们还能在吧台旁等得很耐心。学校到丁一的路只有那么一两百米，却承载了我们太多的快乐，“今天天气不错，适合上网。”“不上晚自习，真的假的？”“今天我咋这么烦的，玩会儿走。”“终于放假了，今晚包夜？”“你请客我就去。”“今天不会不给开吧？”“才五点半，走呗？” 嘿，听见了么，那些，就是你再也回不去的，时光。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的高考]]></title>
    <url>%2Fblog%2F2012%2F06%2F22%2F%E6%88%91%E7%9A%84%E9%AB%98%E8%80%83%2F</url>
    <content type="text"><![CDATA[说实话，高三一年，一直以为高考是一场神圣而庄严的战斗，每一天都为了一个灿烂的目标，坚定的走下去，然而，当卷子发到我手里的时候，我笑了，它的题目并没有想像中的那样正规而严谨，精彩而伟大，相反地，它更像是一场游戏，或是一个命运和我开的玩笑，它告诉我说：比智商和努力以及心态更重要的，其实是你的运气。 分数下来后，我更加确定了这一点，我高中三年最感激最尊敬的老师张明刚，他对我说：“这就是命。”我想他说的是对的。 其实在老张拍着我和张文峰肩膀对满满一办公室的老师自信的说：“这两个绝对600分以上。”的时候，我马上就只想赶快逃离这个办公室。没想到还真上600了，真他妈上的好，可笑了。 知道分数后好兄弟打来电话，我说不出话，真的说不出来，感觉每说一个字都有可能情绪失控，这是什么情况。 情绪不知道是啥情绪，反正就是想杀人，听《歪腰》结果半边耳机是坏的，想把丁一耳机全砸了。打开QQ，一会儿一个问分数的，我全给关了，然后就盯着屏幕上的歌词发呆。 人生就像是歌手上通告 最需要出其不意的滑倒 让眼泪交织哄堂的大笑 要坏掉也要光荣的坏掉 管他的坏就坏掉 谁不会歪腰歪腰 命运偶尔也会 好好笑 我不会鬼吼鬼叫 顶多是歪腰歪腰 就算搞笑我也 绝对不求饶 最近很想吼两句这个，感觉像是给我写的。 最后又去了趟学校，但是又实在不想见老师，结果拉着个脸目光呆滞地进去，老师都说：“没什么的”，然后拉着个脸又出来了。 最后坐了辆好像是末班车的43回了，也没开窗吹风。 就是这样，睡觉吧，我又想起来高考前一天晚上我几乎没睡着觉。 写于2012年夏至后一夜]]></content>
  </entry>
  <entry>
    <title><![CDATA[当我们一起走过]]></title>
    <url>%2Fblog%2F2012%2F06%2F10%2F%E5%BD%93%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%B5%B0%E8%BF%87%2F</url>
    <content type="text"><![CDATA[2009-2012，我们都很清楚这三年对我们来说意味着什么，那是我们一起走过的，高中时代。 一直想着毕业后要写一首歌，名字就叫做《高中时代》，歌词中叙写些不写作业被老师柴的情景片段，或是记录下一天到晚补作业的苦闷与补完作业之后巨大的满足感。这样的日子固然辛苦，但是从一开始我就明白，这会是我一生中一段美好而宝贵的岁月，一段可以触摸、可以铭刻、可以在微风中莞尔回眸的，年华。 一直以为我和班上的大多数同学是没有什么感情的，事实也似乎正是如此，我甚至和班上某些同学三年来几乎从没说过一句话，我觉得这样实在可悲，但我也无能为力。然而，说到高三二班，我却有一种说不出的感情，是景仰，或是自豪？我不知道。有时候觉得高考是一场战役，而我们虽不曾感情多么的深厚，却也一直是在并肩战斗，也能感受到那种同学之间淡淡的友情，尤其是在运动会和篮球赛的时候。印象最深的是高二那次篮球赛，在决赛之中最后时刻因为误判我们以一分差距败北之后，我看到每一个人的表情都很沉重，还记得那天晚自习我在语文书的行隙间填下的那首： 江城子 · 二班必胜 甘苦与共一春秋，不曾丢，志满楼。五十六人，团结胜一筹。过关斩将谁与休，风华秀，英姿流。 挥汗如雨冷风投，暴雨后，人莫愁。针锋相对，拼搏何须由？二班学子志尚在，今虽败，不低头！ 二班必胜，我依然这样说。 高中以来，和我坐同桌时间最长的莫过于牛笛了。还记得我和牛笛的那个小约定，“毕业后、一起唱笑忘歌”，写着这九个字的小纸条被我放在课程表的后面，但它竟然在不知不觉中神秘地失踪了。“伤心的，都忘记了，只记得这首笑忘歌，那一年天空很高风很清澈，从头到脚趾都快乐。”每当这熟悉的旋律回荡在耳边，就会想起那些校园之中的晴朗日子，阳光下的羽毛球场，以及每一个可以抱着吉他唱出微风或是顶着烈日挥洒汗水的角落，当然，还有许多来不及被记录、被定格的言语与画面。还记得那是一个大风天，我和牛笛一边吼着这首歌，一边挥舞着手中的拍子，近乎疯狂，击打着那在风中飘摇的羽毛球，那一刻，真真切切地感受到了高中时代的轻狂与自由，那种在狂风之中勇往直前的自由。高中时代无以名状的快乐，就好像拥抱了一场大雨瓢泼，却还会微笑着对你说加油，仿佛又可以哼唱着一首歌，随着那绵长的曲调，肆无忌惮地奔向某一个未知的远方。 “与牛笛同桌倒计时0000天”，用铅笔肆意涂抹的字迹，新学期来了后还在那张桌子上留着，随手又拍了一张，继续我们未完成的伟大事业，说好了最后一起做一些东西记录高中的，怎么就走了呢？也忘了告别时的最后一句话是什么，或许只是一句再见，又或许是一句加油，不过我知道，是兄弟，不管多远，都会一起努力的。还记得那个写满一行“我爱学习”的草稿本么？本来说好要一起写满整个封面的，可是你走了之后我就再很少写过。 最近坐在43上，当车开得飞快，听着歌，有一种高中时代从身旁飞驰而过的感觉，感觉它就要被我狠狠地甩在身后，然后在车厢模糊地抖动中渐行渐远，越来越远。像风一样，时常在我的身旁穿梭，而到了想抓住它的时候，却怎么也抓不住。“如果说要我选出代表青春那个画面，浮现了那滴眼泪那片蓝天那年毕业，那一张 边哭边笑还要拥抱是你的脸，想起来可爱可怜可歌可泣可是多怀念。”一遍又一遍地播放着这首歌，好像留恋完就可以不再留恋。“怀念总是突然怀念不谈条件，当回忆冲破考卷冲出岁月在我眼前，我和你留着汗水喝着汽水在操场边，说好了无论如何一起走到未来的世界。”我就在想，还会有多少这样单纯而自由的时间，还会有多少这样坚定而充满理想的诺言，珍惜吧，我对自己说，至少我曾经这样真实地走过。 坐43总容易迟到，尤其是高三的时候，到处都在挖路，一路上堵了又堵。一个43车友对我说，这上学简直就跟二万五千里长征一样，我觉得挺对。有时候车开得特别慢我就很来气，但气很快就消了，这么多年，毕竟和43有种老朋友的感觉。有一次和那个车友一起迟到，在校门口被拦住记名字，我就对她说，赶紧留个帅气的签名吧，等毕业了你想签都没机会了。现在想想，43上“艰难”的上学路，真的也是高中时代一个不错的怀念。 高中时代，我们似乎都突然地成熟了许多，很明显，当我们现在看到一群高一小孩在一起打打闹闹乱喊乱叫的时候，总会不禁地对其嗤之以鼻，然而，殊不知当年的我们和现在的他们，其实并没有什么两样。偶然翻到些高一时候写下的文字，其中的思想未免幼稚而单调，文笔也显得华丽与空洞。而现在，我们大多已经成年，三年的时光，给予了我们多少快乐与忧伤、沉默与张扬、浮躁与持重、草率与彷徨，是高中时代，催促着我们在拥挤的年轮中快步向前，是高中时代，拉扯着我们的臂膀，追逐着，换来一张张沉稳而自信的面庞。 高中时代我认为最幸运的事，就是遇到了一个知己，或者说一个和我极其相似的朋友。相似的思想、相似的行为、相似的性格、相似的追求，甚至连字体也很有几分相似，还记得那时和他坐过半个学期的同桌，他总是爱把我的卷子拿错。当年高一军训时分在同一个宿舍，初次见到他时那种扑面而来的似曾相识的感觉，到现在我还记得很清。到后来，一起经历了一些事，我和他才每每惊奇地发现，我们的想法总是能无比精准地一拍即合，具体是一些什么事我已经记不清，但那种会心一笑的默契，那种精准得恰到好处的感觉，真的有些难以用言语去表达，有时候，真的难以相信，这世界上怎么会还有一个这么像我的人呢？甚至觉得，他就像是我的一个影子，看到他，同时，也看到了我自己。 就记得有一次和他闹翻了，我准备第二天彻底不理他，一去学校，就看到他坐在靠窗的位置上一言不发。当时，就特别想板着脸，装出一副特严肃的样子，然后从他身边经过。结果呢？他抬起头来对着我一个傻笑，我的计划就彻底宣告了破产。那时就想，也许这就是真正的好朋友，想不理都困难，偶尔有了矛盾，只要一枚傻傻的笑，就可以让我们抛开一切，抛开一切彼此间的误解与愤怒。不得不说的是，每一次正式的考试之前，我和他都会以我们特定的方式，击一下掌，来互相鼓励，只记得我每一次都很使劲，有时候觉得不够疼，还要举起手掌再来一下，我也忘了是从哪次考试起我们养成了这个习惯，只是后来的每次考试前，这几乎成为了我们的默契，总是能够感觉到，击一下掌，比其他任何方式都更加能使我们感觉到踏实而充满力量。还记得有一次考试前，天空泛着昏黄的颜色，大概那也是一个大风天，我们单肩背着书包，在操场中央游荡，头发和校服都被吹得有些乱，然后我们驻足、告别、击一下掌、说一句加油。这样的画面在我脑海中挥之不去，不知道为什么，最近总是在大风之中生发出感情，是不是因为大风更能让人感受到被时光打磨着的勇气与力量。 毕业，一直觉得这是一个令人向往而又引人伤感的词汇，预示着新的开始，也就意味着不得不与过去告别。再也不能和大家一起被铺天盖地的卷子所埋没，再也不能在暑假补课时充满期待地修改着桌子上写下的倒计时，再也不能被老师叫起来之后支支吾吾，再也不能在要交作业的时候手足无措，再也不能用铅笔在课桌上畅谈梦想，再也不能在课文旁边信手涂鸦，再也不能在教室里争抢着一包富含二氧化硅的北京方便面，再也不能在上课时偷偷啃着华林路444号生产的肉松面包，再也不能趴在教室窗台上张望着楼下经过的女生，再也不能周末放学后一帮人迫不及待地冲向网吧……太多的再也不能，太多的再也回不去，正是那些平常以为再平常不过的小事，搭起了我们三年漫长而又短暂的高中生活，成为了我们记忆中琐碎而美好的片段，突然就想唱和着，“它们都老了吧，它们在哪里啊，我们就这样，各自奔天涯……” “有多少苦痛有你和我一起度过、一起承受，有多少快乐有你和我一起享受、一起感动。”当我们一起走过，再回首，身后早已是落英缤纷，那些美好，那些纯真，就让它留在心底里的某个角落，在疲惫时候，再在风中，酿成一首遥远的、朴实的，勇气之诗。 最后，我只想说，毕业后，即使我们天各一方，即使我终究还是忘记了你的名字，但是我也一定会记得，高中时代，三年二班，有我们一起走过。有时候真的不想离别，离开一个熟悉的地方，一些熟悉的人，去一个完全未知的远方，但是，没有办法，我们都只能沿着岁月的轨迹继续前行。未来，或许还会有那么一天，我和你，在某个陌生的地点相遇，那时，如果我还能认出你，我一定会慢慢地走近你，我会坚定地望着你的眼睛，踏实地拍拍你的肩膀，然后就那样一如既往地笑着说，加油，我的好兄弟。]]></content>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2Fblog%2F2011%2F10%2F25%2F%E6%97%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[车上只剩我一个人， 当车在这条长长的街上开得像飞一样， 我感受到了最真实的最本质的自由， 我知道， 这是只属于我的无法形容的最宝贵的财富。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一路向北]]></title>
    <url>%2Fblog%2F2011%2F09%2F28%2F%E4%B8%80%E8%B7%AF%E5%90%91%E5%8C%97%2F</url>
    <content type="text"><![CDATA[要写一篇文章，只是一时的冲动。 还有多少的勇气，还有多少次的，一路向北。 在43上听《一路向北》，突然又让我想到了很多，与歌词无关，与曲调无关，仅仅是因为歌名，与那段电吉他所带来的震撼。 道可道，非常道。 忘了想写些什么，总之有很多想说却又无法去记录的思索。总觉得自己有着哲人的思考，诗人的敏感，以及独我的狂妄。当然，再加上一点傻，就是完整的我了。傻是我坚守的核心。 大智若愚，大巧若拙，大音希声，大象无形。 我一路向北，就想这样一路向北，沿途得到一些，失去一些，经历一些，改变一些，有回忆，有憧憬，有珍惜，有遗憾。时不时地反省一下自我，看清一个真实的自己，然后继续执著地向前，不犹豫，不后悔。 我说，没有什么过不去，无论美好或是悲哀。 还好，我还能坚守我自己。 那就让我，一路向北。]]></content>
  </entry>
  <entry>
    <title><![CDATA[十七岁、我所认为的美好]]></title>
    <url>%2Fblog%2F2011%2F09%2F24%2F%E5%8D%81%E4%B8%83%E5%B2%81%E3%80%81%E6%88%91%E6%89%80%E8%AE%A4%E4%B8%BA%E7%9A%84%E7%BE%8E%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[十七，一个简单的数字，在我心里有种说不出的感觉。没有十八岁成人礼的重要，十七岁的生日，很平淡的样子，没有什么纷扰，只有我最爱的自由，一个人，坐在这里，写下这篇文章。 还有最后一年，我对自己说。还有最后一年我可以称自己为未成年，还有最后一年我可以犯傻与推脱，可是我早不该这样了，我知道。 关于独立，关于成熟，我不想说太多，以前的我或许看起来像一个小男生，但我一直更愿意让别人觉得我是一个大男孩。而现在的我，是一个大男孩，没问题。 17岁的大男孩，没有什么可以阻挡我的方向。我有我的信仰，我有我的光芒，我有我的意志，我有我的疯狂，这些都是我的，这些也都是构成我必不可少的要素。这个世界上独一无二的我，是我坚定不移地放在心里的，小太阳。 我不够闪亮，没关系，平凡的温暖就是我最大的亮点；我不够优秀，没关系，炽热的执著会是我最终的强音。 ——小太阳宣言 翻着以前的说说，也找到了这条曾经发表的《小太阳宣言》。不可否认的是，我一直在变，从稚气到成熟，从昏惑到透彻，慢慢地学会控制自己的情绪，慢慢地学会了感性与理性的调配。每一次的痛苦都是一次成长，我也深刻地体会到了这句话。我知道我还会这样继续变下去，但是，那个独一无二的我是绝对不能改变的，小太阳的精神，必须坚守。 快乐，提到快乐，我说过，没有人能够使我不快乐，除了我自己。所以说，保有一颗乐观的心，比什么都重要。 最后，想说一下珍惜与感恩。世界上没有哪个人是应该对我好的，这一点我应该明白。我要感谢，感谢现在还在我身边陪伴着的人，感谢那些一直默默支持并关心我的人，感谢所有喜欢或是曾经喜欢过我的人，感谢那些在乎我且真心对我好的人，感谢父母，最后，感谢自己。 十七岁 相信一切美好的，就这样吧。]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[红警3 2v2 4：0 纪实]]></title>
    <url>%2Fblog%2F2011%2F07%2F17%2F%E7%BA%A2%E8%AD%A63%202v2%204%EF%BC%9A0%20%E7%BA%AA%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[5：45 丁一 开始我们新一轮的征程 第一战 生死一线 绝地制胜 打开红警三，战役逼近，苏维埃进行曲已经奏响。 我的昵称依旧叫Li Ming， 张钰祥的昵称依旧是Danny。 颜色依旧是我们的必胜色：黄色和绿色。 阵营：我—苏联，张钰祥—帝国 战役开始，四人都在紧锣密鼓地建造基地。兵营完成，侦查熊派出，防空步兵进驻敌附近的楼，发现离我最近的红色苏联造了两个船场（傻着呢），并出了几辆磁暴快艇与牛蛙，我也加紧点磁暴与牛蛙发展好海军。战事首先在张钰祥侧打响，我发现红色派其小股海军也去攻打张钰祥，基地空虚，恰好我小股海军初具规模，于是我立即调海军编队，闪击其两个船厂，扫平其海面设施，接着，趁其不备，磁暴快艇从其薄弱处登陆，一举炸平其主基地、兵营、矿场，一直到一切基础设施。（我一直纳闷他海军怎么一直没回防，是不是被张钰祥灭了）最后，我的双刃直升机编队调来炸掉其核电厂，他被击败。可是喜悦还没有持续，张钰祥被击败，被日本的将军战列舰群。 现在成了1v1，敌将军战列舰群接着就驶来我的基地，我见势立即将基地车迁往内陆高地。只见他的一大群将军在海边徘徊干瞪着我而无用武之地，哈哈我就笑了。可是丝毫不敢放松警惕，抓紧在内陆发展，同时用陆军准备扫平他已经被张钰祥打得残破的基地，可是当我的陆军开到他的基地，发现他基地还有一个将军，结果我的陆军在他的一艘将军对地强大的火力覆盖下无可奈何，最终几乎全军覆灭。他将将军群调回基地防守，发展陆军，企图攻我基地，我意识到，只有用空军了，于是，造机场出双刃，去炸其船厂，差点炸毁，不料被其天狗击落。为夺取制空权，我只好造米格战斗机与天狗对抗，可是，同时他狂造天狗，我米格战机被击落，最终制空无望，同时，他也不断以小股兵来侵袭，我只能造些小恐怖来应对，结果恐怖造多了，多余的我放在他基地旁一小岛（他视野外）上待命，双刃也躲在那里。接着，没有钱了，战车厂也被他炸毁，我总共的财产就剩一个主基地，一个机场，一个矿场，一辆矿车，一个小电厂，一个防空炮，三个小恐怖，几架双刃，和几个在楼里的防空兵，失败几乎已经注定，应该可以认输了。可是，只要还有机会，就不认输，何况可以断定他也肯定没钱了。我用小恐怖侦查照亮视野，用轨道坠落砸他的船厂，用磁力卫星吸走他的矿车，可这些都是杯水车薪。可是，就在此时，他的全部天狗变身去打我的矿车，我的矿车差点被打暴，还好我还有恐怖，以及我事先专门安的防空炮，他的天狗被全歼。机会啊，他这时没任何防空单位，我立即派仅有的几架双刃从南面小岛直扑其基地，一举炸掉他的战车厂，接着开始炸已经快被他修好的船厂，不好的是，他船厂出了一个海翼（防空），这样我的双刃就危险了，不过，我的磁力卫星恰好好了，我往潜着的海翼上一放，海翼一浮出水面就被吸走（太惊险了），这样，随着他在海与陆上所向披靡的将军战列舰群眼睁睁地看着其船厂的崩塌，他大势已去，我扫平他的矿场，他最终意想不到地战败了。这把赢得可谓惊心动魄。 小结：嘿，小日本将军舰很猛么，哥两架双刃就能把你给废了，谁让你为了阴张钰祥把将军舰造那么多的。不过，这也是我有史以来最惊险，最有技术含量的一场战役。也为今天开了一个好头。 （未完）­]]></content>
  </entry>
  <entry>
    <title><![CDATA[生无所息 行而不止]]></title>
    <url>%2Fblog%2F2011%2F07%2F09%2F%E7%94%9F%E6%97%A0%E6%89%80%E6%81%AF%20%E8%A1%8C%E8%80%8C%E4%B8%8D%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[子贡倦于学，告仲尼曰：“愿有所息。”­ 仲尼曰：“生无所息。”­ 我，总是会想，未来要去往哪里，一直想到自己也觉得疲惫。有时候也会突然不知所措，不知道等待我的，会是一个怎样的未来。其实，只想坚定的对自己说，就这样，一直走。­ 有时候也会抱怨一下“和谐”社会，也会偶尔想到为什么我不是“富二代”。世界上没有什么事是完全公平的，更何况我已经得到了很多很多。仔细一想，我完全不需要羡慕那些富二代，我拥有着那么多他们可能永远都没有机会拥有的思想与快乐。其实就是这样，一个人拥有一些的同时，在另一些方面，就会自然而然的失去一些，这是一条定律。­ 这就谈到了选择，假设现在让我重新选择自己的出身与个性，我会毫不犹豫地选择现在的自己，一成不变。我只想说，我凭什么羡慕别人，就像我留言板上的那句寄语，我，就是我的作品。­ 一路上总会有阻碍，甚至是选择。我父母极其希望能够强加他们的意志于我的选择，我只说，不可能。我会听取他们的建议，但不会顺从于他们的逼迫。我明白，他们为我考虑得很好，但是我的一生总不可能由他们来规划，也许他们为我找到的是一条捷径，我也更愿意自己去闯，毕竟，那才是我自己的路。我知道，这样很可能会吃更多的苦，碰更多次壁，但是我明白，只要这是我的抉择，我就不会后悔。当然，结果会是怎样，也只能由我自己来承担。肯定会有许许多多的人笑我天真，那就笑吧。我也明白我的倔强，但那不是天真，也许是天性，喜欢简单而随性的自由，这就是我，我不会改变。­ “青春是人生的实验课，错也错得很值得。”“总有一天我们都老了，不会遗憾就OK了。”很喜欢这两句歌词，可以将一切的迷茫打碎。走自己的路，难免会有更多坎坷，没关系，错了就错了，沿途的风景才是最大的快乐。世上只有想不通的人，没有走不通的路，那么我，怕什么。­ 我会一直这样走，不想想太多。如果有人愿意陪我，那我也不会奢求太多。一把吉他，几个一生的好朋友，真的就已经足够。我要的只不过是我的信仰，我的快乐。人生的意义，归根究底不就是为自己追寻快乐。人生短暂，我不能让自己后悔。­ 生无所息，行而不止。­ 2011.7.8 3:09­]]></content>
  </entry>
  <entry>
    <title><![CDATA[我想]]></title>
    <url>%2Fblog%2F2011%2F04%2F17%2F%E6%88%91%E6%83%B3%2F</url>
    <content type="text"><![CDATA[一­ 我想做很多的事，总想做很多的事。­ ­ 我想好好学习。­ 我想锻炼身体。­ 我想弹好吉他。­ 我想恋爱。­ 我想继续我的小说。­ 我想录些我喜欢的歌。­ 我想练练唱功。­ 我想把编曲精通。­ 我想完成我写的歌。­ 我想组起小太阳。­ 我想每天练哑铃。­ 我想每天去跑步。­ 我想打好羽毛球。­ 我想学好打篮球。­ 我想多读些东西。­ 我想背新华字典。­ 我想挤出时间写日志。­ 我想学历史和地理。­ 我想拿着相机到处去拍照。­ 我想写些文字，记录高中。­ ­ 总是想做各种各样的事，总是觉得自己都应该做到，总是认为自己完全可以变得更加优秀，总是感觉自己内心拥有着无比强大的力量。可是然后呢，总是没有时间，总是困了累了不得不去睡觉，总是无法坚持着把这些事情一一完成，总是庸庸碌碌地在作业堆里熬过一天又一天。我想，我总是如此，勤奋而懒惰。­ 我要趁着年轻做一些想做的事，我总是这样想。当然我也总是尝试去做，想做的事太多，可我却没有那么多的时间，也就力不从心。每次只能去做其中的一两件，只能是顾此失彼，没有办法。我无法让自己不用睡觉，更无法把我的一天变成48个小时。所以，我想我必须学会选择，先选择自己必须做的，再选择自己应该做的，最后选择自己最想做的，在适合的时间做合适的事，只能这样。我想，无论怎样选择，我都必须要努力，带着我如风的自信，带着我必胜的决心，带着我的勇气与意志，做到最好。­ 我想，我想要做的事，不会只是想想。­ ­ 二­ 我想，我总想改变自己。­ 我总想更加自信，却难免偶尔自卑。­ 我总想更加善良，却难免偶尔邪恶。­ 我总想更加勇敢，却难免偶尔畏怯。­ 我总想更加坚毅，却难免偶尔懦弱。­ 我总想更加谨慎，却难免偶尔疏忽。­ 我总想更加果断，却难免偶尔迟疑。­ 我总想更加宽仁，却难免偶尔小气。­ 我总想更加睿智，却难免偶尔迷惑。­ 我总想更加谦逊，却难免偶尔傲慢。­ 我总想更加诚实，却难免偶尔虚伪。­ 我总想更加成熟，却难免偶尔幼稚。­ 我总想更加稳重，却难免偶尔轻狂。­ 我总想更加阳光，却难免偶尔阴郁。­ 我总想更有斗志，却难免偶尔怠惰。­ 我总想要一个完美的自己，却发现完美的人不存在。­ 我想，也许这才是最真实的我，我不需要改变。但我还是想要改变，因为我始终相信，会有那样一个更好的我。­ “仁者不忧，智者不惑，勇者不惧。”小时候第一次看到这句话，心里就萌生了那时最大的理想，那就是做一个仁者+智者+勇者。现在还是一样，虽然我明白我达不到那么完美，但我还是一直在心里默念，我可以。­ “淡泊以明志，宁静以致远。”至今我笔袋里还夹着我写的这张字条。改变自己，其实不需要什么刻意的表现，只要我明白，只要我能时刻看清自己，只要我一直在努力改变。我想，就这样很好。­ 我想，改变自己，我可以更优秀。­ 三­ 我想，我总会想起你们。­ ­ 我的朋友不怎么多，但每一个都很好，我总是对别人这样说，也对自己说。­ 一个人独处的时候，总会想起一些人，现在或是曾经，那些在我生命中留下过或大或小足迹的人，那些无论怎样总是陪伴在我左右的人，那些改变过我或是因我而改变的人，那些，我的朋友。­ 我喜欢的友情，是那一种淡淡的不夹杂质的味道，这样的感觉就很好。不需要什么精彩的情节，只需要一些平实的温暖，一些无声的鼓励与支持，一种不用说话就全都早已明了的默契，一种不受时间与空间阻隔的熟悉而踏实的感受。或许那只是一句加油，一包牛奶，一次挥手，一个真实的笑，或是在你口渴难忍时抛过来的一瓶矿泉水，或是夜深人静时手机屏幕上突然的一句“还不睡？”我想，我无法记住所有的细节，但是我会记得那一种真实的感觉，每一种，对每一个人独一无二的感受。­ 我想，我总会想起你们：我的小太阳们TT、荣、浩、嘉；我的小旭、亮仔、二愣、钰祥兄，以及我所有的初中的朋友们；我的小学同学尹超、王雪晶等等；我的榜样学长马祥、何莉、王旭东；我天生的好兄弟李柏杭和王勇，以及我所有的高中的朋友们；和我一起坐43的朋友们；我的大猪、琦、大兔子、小狮子；我的“小妹妹”小西；和我一起长大的小弟郭锐……­ 我想，我会想着你们，我的朋友。­]]></content>
  </entry>
  <entry>
    <title><![CDATA[43、我的43]]></title>
    <url>%2Fblog%2F2011%2F01%2F21%2F43%E3%80%81%E6%88%91%E7%9A%8443%2F</url>
    <content type="text"><![CDATA[也有人问过，我的幸运数字是几，其实我也不太清楚，没有多想，我告诉他，是43。 &nbsp; 说到43，这个对我来说再熟悉不过的数字，我不想说太多，只想表达一下自己心中最真实而温暖的感受。可以这么说，43成为了我的习惯，前一阵子吃过一段时间的小饭桌，中午不回家，这本是为了更好的午休，而我却常常觉得不爽，尤其是在看到43在马路对面的车站停靠时，我总是有一种想要冲上车去的冲动。每天坐的次数由原来的四次变为了两次，按常理来说本应该觉得轻松的，但恰恰相反，有点累，或者说，总有些疲惫的感觉。吃了快两个月，我对我妈说，我中午想回家了，理由是：“我想坐43了。”有时候觉得这个理由有点傻，但是真的。 &nbsp; 有一次听到同学谈论一些关于私家车的问题，我说，我家有自行车，他们打趣地说，43不是你家的么，哈哈，就是，有时候真的觉得43是我一个不可失去的拥有，它属于我，至少在心灵层面上，它对我来说是一个类似于家一样的存在，不想多说，其实也没有什么可说，就是，很温暖，像它那暖和的皮垫子一样。 &nbsp; 43的皮座位，好像是它所特有的，看上去感觉就很好，有一种说不上的很适合喝奶茶的气息，至于在椅背上胡写乱画，比如说“XXX喜欢XXX”“XXX是个二百五”之类的，那些都是小时候的事了，我写的应该，不是应该，是肯定早九辈子没有了。有一次，听到一个刚上车的陌生人说，你瞧，这43这破车都烂成什么样了，我心里什么滋味，涩涩的。我曾经在我的生日愿望里写下，希望43不要换新车，毕竟从小到大坐得久了。 &nbsp; 听音乐，更准确的来说应该是听歌。一上车，站着，等有双人的座位空下后，再坐在靠窗的位置上，从口袋里笨兮兮的掏出来一个MP3，解开缠绕的耳机线，短线为左，长线为右，塞在耳朵里，耳机的海绵套蓬蓬的很有厚重感。调大音量，盖过43发动机的轰鸣声，不知道为什么，在车上听歌总是比其他情况下听歌更有感觉，或许是因为车的轰鸣声使低音更加充实，或许是因为车的开动使节奏更加清晰，或许都不是，有时候听歌，就感觉是自己在唱，就这样一句一句地在心里唱出歌词，才会被感动，其实，也就是被自己感动。 &nbsp; 写文章，每次的灵感似乎都是在做43时产生的，不知道为什么，就是这样，喜欢把车窗向前推开，风吹进来，大脑空空的，进入了一种自动读取自己心灵的状态，然后文字就源源不断的流淌出来，貌似是在对别人诉说，也许就是在对自己诉说，其实就是独白。当然，不知不觉流出来太多文字，就一时难以记录，于是就一个人静静地走回家（不敢跑、因为害怕加速遗忘），用铅笔，不停的回忆，找回并记录下那些文字，不过总是会有些遗憾，因为大部分的文字还是被快速地遗忘，如同褪色，今天也一样。 &nbsp; 坐在43上心情总是平静的。似乎没有什么事可以扰乱这个定律，总感觉43有一种奇特的力量，一种使人清醒且安静的力量，一种使人无法也无暇去感受孤独的力量。我不知道为什么，但确实是这样。坐在43上，任风把一切的烦恼吹到时光之外，散落在某个未知的荒原，在这一段短暂的行程中，就再也不去拾起，这未尝不是一种最好的享受。车厢内仿佛是一个独立的时空，身在其中，感觉不到忧伤，心灵可以小憩。淡泊以明志，宁静以致远，最近很喜欢这句话，坐在43上的时候，应该就是我最宁静的时间，可以淡泊了一切，可以看清的更多，我想，这就是所谓的思考。每天都有两个小时花在43上，除了困倦的时候用来睡觉，剩下的时间，大概都在重复着这种广泛的思考。有的时候也会思考得很深，但一下车便忘了，偶尔也会拼命地去回忆，浓缩几句，就记在我的那个大本子上。至于使人无法去感受孤独，倒不如说是使人感受到了独处的美妙，一个人，没人打扰，尽情思考，也不错。 &nbsp; 最喜欢坐着43冲过那一段树林旁的路，也就是所谓的西固苗圃，里面有着大片大片不同种类的树苗。天气好的时候，总觉得这里的空气会比较清新，于是打开窗户，扑面而来的空气，淡淡的，似乎也没有什么特别的味道，但是那种风扑在脸上的感觉，很惬意，或者说是一种轻快感，尤其是在回家的时候，这种感觉更为强烈。曾经写了一首诗，写到冲向死亡的夏天，那种感觉坐在43上才能够更好地有所感受。顶风前行，或许会使人更容易联想到飞翔，而坐在飞驰的43上，则有一种飞速奔跑的感觉，尤其在黑夜，感受到快要凝止的呼吸，感受到快要喷涌而出的血液，此刻，用呼吸让自己沉浸其中，脑海就像被抽成了真空，时间、空间，以及其他的一切，仿佛都在这一瞬间与我无关，只有耳边的音乐，还有紧皱的眉头，深邃而锐利的目光。被融化的感觉。 &nbsp; 突然想说说在车上爱听的歌了。我习惯于通过每一首歌的时间凭经验计算好它所经过的路程，于是，我就完全可以在某个时间某个路段，根据某一种心情，播放某一首歌。就这样，每首歌都有了它最适合的环境，都只喜欢在特定的环境下被按下播放。一直如此，我也乐此不疲。 &nbsp; 感受最深的一首歌就是周杰伦的《飘移》。“找只笔写下日期记录勇气，我可以对着墙壁让拳头叛逆。”回家的时候听，就在车开得最快的那一段听，风声、43的发动机声、车轮的飞转声，以及音乐里的风声、发动机声、超车声、刹车声、飘移声，混杂在一起，感觉整颗心、整个世界、整个闭上眼后偌大的空间，都在一起飘移。同时有一种向前冲的感觉，至于冲向什么，放空眼前，不知道，只觉得心里充斥着无穷的力量，等待爆发。感受很相似的一首歌是他的《一路向北》，再不多说，然而碰巧的是，这一段路，恰好是一路向北。 &nbsp; 而他的《晴天》《园游会》《稻香》和南拳妈妈的《香草吧噗》《橘子汽水》《河流•午后•我经过》则适合在一个阳光充足的大晴天，坐在向阳的车窗边，打开窗，听。当然最好是在回家的路上听，那样会感到更轻松。到冬天，晚上放学天就全黑了，在车上听《夜曲》，特别有感觉。灯光在车厢内流动，光影交错，那些明的、暗的，参差着、交织着，更像是一幅华丽的乐章。静静地，看椅背的影子投射在前一个椅背上，渐渐升高、变淡、随着新的影子的出现而褪去、消失，再升高、变淡、褪去、消失，如此循环，车就这样走过了一个又一个橘色的路灯。在这样光与影的和弦进行下，也适合听石头剪子布的《时间》，诡秘的节奏，容易引发诡秘的思考。可以说的歌太多，看来是说不完了，我想，每一首歌都有着它特有的意象，而我只是对这些意象做出了相似的还原。 &nbsp; 未来，有时候真的不敢想未来，等到高中毕业之后，去外地上大学，就再也坐不了43了，或许心里会有些空荡荡的。从小时候拉着爷爷奶奶的手去逛菜市场坐43不用买票，到后来每天坐43上初中、高中，43路车一直都没有变。倘若每次坐车都给座位上扎个洞，那我估计43二十几辆车，每辆车的后三排座位都得让我给扎穿，或者直接扎没了都有可能，嘿嘿。想象到时候放假回家看到43，应该会是特激动吧，或者就是温暖得无话可说？43承载了些什么，太多了以至于我说也说不清，反正我一看到43就知道，我到家了。 &nbsp; 43，我的43。 &nbsp; 2010.11.09 &nbsp; 后记： &nbsp; 就在2010年12月23日（冬至后一日），43换新车了。再也没有那朴实亲切的红白条纹了，再也没有那平实温暖的皮质座位了，再也没有那庞大的噪声做我听歌时厚重的低音了，取而代之的，是看起来更加“现代”的一切。从前的43，带着它所承载的我所寄予的一切，从我的世界里突然消失。当我再次站在车站，看到新的43那副冰冷的、陌生的外壳时，我感到一种巨大的、生硬的缺失，我想，我应该知道那是什么，我与43十年来潜存的默契，就此而终结。我不知道我是否应该感到无奈，但我知道我必须接受这改变。没有什么是一成不变的，我所做的，应该只是珍惜与释然。就这样。 &nbsp; 还有记忆。还有我。 还有我的43。 ​ &nbsp; 以下照片转自bbs.xbus.com，拍摄于2008年 &nbsp; （增补于2014.3.23）]]></content>
  </entry>
  <entry>
    <title><![CDATA[纸飞机]]></title>
    <url>%2Fblog%2F2010%2F12%2F05%2F%E7%BA%B8%E9%A3%9E%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[纸飞机、我的勇气越过湿地、穿过密林 没有什么可以阻挡我的足迹没有什么可以击垮我的信心与毅力 绝不哭泣、这是对我的终极磨砺绝不放弃、坚持是最终属于我的胜利 没有风助我一臂、那我就冲向荆棘没有人和我一起、那我就顶天立地 做我自己、我必无敌 我的纸飞机、我的勇气 我就是、程达瑞]]></content>
  </entry>
  <entry>
    <title><![CDATA[16岁、我的愿望]]></title>
    <url>%2Fblog%2F2010%2F09%2F24%2F16%E5%B2%81%E3%80%81%E6%88%91%E7%9A%84%E6%84%BF%E6%9C%9B%2F</url>
    <content type="text"><![CDATA[16岁、我希望我能够开心一些­ 16岁、我希望我能够成熟一些­ &nbsp; 我希望我能长得更高（也希望TT能长高）­ 我希望我能长得更帅（啊哈哈哈哈）­ 我希望我稍微长胖一点（也祝愿张荣减肥失败、哈哈）­ 我希望学习有所进步­ 我希望我能更有文采­ 我希望我能更有智慧­ 我希望我字能写得更好看（也祝张钰祥画画得更好）­ 我希望我吉他能弹得更好（还有鹿浩也要弹得很棒）­ 我希望我能学会编曲­ 我希望我唱歌能更好听­ 我希望我羽毛球打得更好­ 我希望我希望我长跑更好­ 我希望我身体更棒­ 我希望我做饭能更好吃­ 我希望我能努力考所好大学­ 我希望我能更博学多才­ 我希望我能学到更多、不止是知识­ 我希望我能挖掘出我更多的潜能­ ­&nbsp; ­ 我希望我能帮助到更多的人­ 我希望我能收获到更多的友情­ 我希望我的朋友们能够因我而快乐­ 我希望我不会让任何一个朋友为了我而伤心­ 我希望我会珍惜每一个真心对我好的人­ 我希望在每一个生日都能收到满满的祝福­ 我希望偶尔也能收到几件小礼物、很贴心、也很开心­ 我希望我们的小太阳永远不分离­ 我希望我们可以完整的制作出一首真正只属于我们的歌（要学编曲啊、录音啊、混音啊、后期啊、、、、我晕了）­ 我希望我可以在立夏到夏至之间的某一个阳光明媚的晴天里、在一个葱绿的小角落、抱着吉他、唱《晴天》­ 我希望我们小太阳的愿望可以实现、我们可以在未来的某一个夏天看到我们在某一个山坡上亲手种下的向日葵­ 我希望43路车在我考上大学之前不要换新车­ 我希望我家院子能很久以后才拆­ 我希望我能坚持在妈妈上下班的时候替她扛自行车­ 我希望我爸爸能少生气、少骂我几句­ 我希望我的爷爷奶奶姥姥姥爷可以健康长寿­ 我希望我的哥哥姐姐、我的弟弟妹妹、还有我家的猫咪、能够更快乐­ 我希望我的家人平平安安­ &nbsp; ­ 我希望我能再创作出几首好歌­ 我希望我能拍到许多有感觉的好照片­ 我希望每天都有一点时间看一些自己喜欢的书、做一些自己喜欢的事、或者只是静静的听听歌、做白日梦­ 我希望我能遇到更多喜欢的诗、喜欢的歌、以及文章­ 我希望我不要遗忘那些从前最单纯的快乐与悲伤­ 我希望我能不断的留下一些美好的记忆、给未来­ 我希望我能开心地回忆过去、积极地面对未来­ 我希望无论遇到什么事我都能够平静地面对­ 我希望我能够充实地过好每一天­ 我希望我不会因为寂寞而随便找女朋友­ 我希望我即使一个人上学、一个人回家、一个人听着歌、一个人望着窗外、一个人走在校园、一个人路过人潮、也不会太孤单、也会开心的笑­ 我希望我能够坚守我的独立人格­ 我希望我能真正地享受一个人的快乐、不需要去羡慕别人的快乐­ 我希望我能一直相信着亲情、友情、爱情、以及其他的一切美好­ 我希望能有一个真心喜欢我、并且我也真心喜欢的女孩子、然后在一起­ 我希望我会珍惜一切­ 我希望我能保持一颗纯粹的心­ 总之、我要做我自己、做一个优秀的人­ &nbsp; 我相信、我能够努力让这些愿望实现]]></content>
      <categories>
        <category>生日</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[夏 · 碑铭]]></title>
    <url>%2Fblog%2F2010%2F06%2F04%2F%E5%A4%8F%20%C2%B7%20%E7%A2%91%E9%93%AD%2F</url>
    <content type="text"><![CDATA[立夏夏天了，不是么? ­ &nbsp; 树梢的风停了­ 氤氲的梦醒了­ 天边的云碎了 惺忪的眼醉了­ 冬候鸟掠过枝叶摇晃下纹丝不动的晴朗­ 大片大片的洋槐扑灭了又一轮纵火的黄昏­ &nbsp; 小满­嗯、又是夏天了­ &nbsp; 雾气渐涨­ 雨水斑驳­ 风荡入密叶层层覆盖下的半片天空­ 在叶与叶的罅隙间­ 点点遗漏­ 然后­ 从拐角­ 撑开树影­ 握紧手心的潮热­ 光芒­ 在眼底灼灼绽放­ &nbsp; 芒种夏天了，怎么样?­ &nbsp; 直走­ 一直走­ 走过滴水的画室­ 走过鸟鸣的诗­ 破裂的乐谱­ 唱起温润的歌声­ 乱了琴弦­ 湿了薄烟­ 浓绿的墨色­ 在叶脉之中浅浅蔓延­ 微笑上扬­ 风从树林的一端向另一端渐次拨起褶皱­ 奔跑着­ &nbsp; 夏至­夏未至­ &nbsp; 冲向，死亡的夏天­­ 冲向死亡的，夏天­ &nbsp; 2010.夏至]]></content>
  </entry>
  <entry>
    <title><![CDATA[永远的四班——最难忘片段]]></title>
    <url>%2Fblog%2F2009%2F08%2F30%2F%E6%B0%B8%E8%BF%9C%E7%9A%84%E5%9B%9B%E7%8F%AD%E2%80%94%E2%80%94%E6%9C%80%E9%9A%BE%E5%BF%98%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[最难忘片段 1：还记得老李带我们跳大绳，跳了300多下，最后居然把绳子给跳断了。 最难忘片段 2：还记得我们班在运动会上集体总分总是第一，最后一次还得了全校超高分。 最难忘片段 3：还记得我们跳大绳还被武启明拍下来在校电视台播了一下 最难忘片段 4：还记得我们初三学广播操时集体逃跑吗？把教操那女的无奈着。 最难忘片段 5：还记得老李亲自率领我们打扫学校卫生，那叫个干净，还被学校表扬了一下，+10分，赞。 最难忘片段 6：还记得那年教师节放假，正好轮到我们打扫学校卫生，打扫完了我去“丁一”一看，额里面一堆咱们班的。 最难忘片段 7：还记得雷锋日那天，老李让我们出校门去擦马路两边的护栏，我们等了好久都没见记者来采访一下的，哎。 最难忘片段 8：还记得最后一个运动会，我们在一起玩“我爱记歌词”，我还是领唱呢，呵呵！ 最难忘片段 9：还记得补课时我们把破袜子放在讲桌上跟斌强扎刺。 最难忘片段 10：还记得四十有一次实验做成功了特高兴，让我们把试管传着看，可是张和万往里面放了个扎面包的条条，我们都看那个去了，把四十气坏了。 最难忘片段 11：还记得四十有一次实验和变魔术似的，试管一摇，绿了；再一摇，蓝了。 最难忘片段 12：还记得斌强有一次骂阿煤，骂着骂着自己忍不住就笑了，一直靠在讲桌上笑了五分钟没讲课 最难忘片段 13：还记得有人在校服背上画画被斌强抓了，之后张故意在背上画了个电路图跟斌强扎刺，还写了个E=MC2 最难忘片段 14：还记得我们在放学时喊的“Hooray” 最难忘片段 15：还记得我们学电磁感应时，斌强带来了个手摇发电机，他正摇的时候，我们喊“再快点，不要停”、“亮了，亮了”，斌强越摇越带劲，最后，发电机的手柄被摇断了。 最难忘片段 16：还记得我们的珍藏版校服。 最难忘片段 17：还记得老李打人PP时有多疼，到现在才觉得再疼也值了。 最难忘片段 18：还记得我们在联欢会上给李亮和凤玉婷举办的婚礼。 最难忘片段 19：还记得蛋蛋在广播时说的那句“这首歌送给初三四班的李亮和凤玉婷同学，祝他们友谊地久天长。” 最难忘片段 20：还记得窝窝对我的讽刺：“乖娃娃，站起来。” 最难忘片段 21：还记得窝窝说“勾股定理！”时的语气。 最难忘片段 22：还记得我们做眼保健操时一起跺脚。 最难忘片段 23：还记得我们一起对斌强发出高压锅的声音。 最难忘片段 24：还记得窝窝拖堂后说：“谁说的下课？他不是学生！” 最难忘片段 25：还记得小波总是把我们的体育课撬了不来上。 最难忘片段 26：还记得斌强和大锤没能和我们一起照毕业照，“特遗憾一个”。。。 最难忘片段 27：还记得窝窝在白板上讲题写不下了，一激动，直接往墙上继续写。 最难忘片段 28：还记得窝窝有一次别的老师来听窝窝的课，窝窝一声不吭直接让我们自己看了35分钟的“回顾与思考”，最后5分钟才开始讲课，又拖了9分钟的堂，强悍~~呵呵！ 最难忘片段 29：还记得窝窝在联欢会上用笛子吹了首菊花台，吹得那么快，还让我们跟着唱。 最难忘片段 30：还记得窝窝总是拖堂直到下节课K40快来了才走，K40一来就问“这谁擦的黑板啥？”，我们答：“万子一”四十又问：“为啥不擦黑板？”我们答：“上节课拖堂了，真的拖堂了。”直到最后一节课K40也没搞清楚我们是骗他的还是真的。 最难忘片段 31：还记得我初三时老迟到，而且每次都碰到小红的课，她问我：“怎么回事？”我每次都答：“车慢了”，最后小红都懒得问了。 最难忘片段 32：还记得老李的癖好：每一届初三四班他都要带。 最难忘片段 33：还记得张钰祥对大耗子超级玛丽版的“大大大大肌” 最难忘片段 34：还记得我和贺杰在桌子底下打架，被斌强发现了：“那两个男生，手拉手干啥着呢？！” 最难忘片段 35：还记得最后一节语文晚自习小红被我们的一句“兰老师，谢谢你，我们永远爱你！”感动得哭了，我们大家也都快哭了。 最难忘片段 36：还记得张荣每次“上道”都偷懒，最后被推车了。 最难忘片段 37：还记得我陪小省长等车，等了快一个小时。 最难忘片段 38：还记得我被“笨笨”骂作“老年痴呆”。 最难忘片段 39：还记得我们教室前的“宁静致远”，教室后的一排奖状，以及教室里一砖一瓦的摸样。 最难忘片段 40：还记得我们永远的四班。]]></content>
  </entry>
  <entry>
    <title><![CDATA[永远的四班——K40语录]]></title>
    <url>%2Fblog%2F2009%2F03%2F24%2F%E6%B0%B8%E8%BF%9C%E7%9A%84%E5%9B%9B%E7%8F%AD%E2%80%94%E2%80%94K40%E8%AF%AD%E5%BD%95%2F</url>
    <content type="text"><![CDATA[第一名：把门开（K)开(K)！第二名：哎，说（刷）对了！第三名：向后转，走！第四名：玩（wan）着！第五名：这题中考不考就找我来。第六名：喝一口，死不了！第七名：现在说闲话的，大声点，让我也听听！第八名：集（di）气瓶第九名：这个我们留到下节课讲~第十名：去！到教育局告我去！！第十一名：玉不琢不成器，大家都是和氏璧！！！！第十二名：对着呢错着呢错着呢对着呢~~ …… 哎对着呢！第十三名：人不为己，天诛地灭第十四名：损人不利己的事别做，损人利己的事做一点还是可以理解的~~第十五名：各位，把练习本给我拿（拉）出来！第十六名：蛾子也要学化学！第十七名：来来来干撒起老？第十八名：那人家是特级教师，我是个啥？？第十九名：别听那些专家的，各位第二十名：看来我得采取些武力措施！！ （答：校长好~）第二十一名：啊！你说啥！？（学DFG的）第二十二名：往出走！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[永远的四班——斌强语录]]></title>
    <url>%2Fblog%2F2009%2F03%2F24%2F%E6%B0%B8%E8%BF%9C%E7%9A%84%E5%9B%9B%E7%8F%AD%E2%80%94%E2%80%94%E6%96%8C%E5%BC%BA%E8%AF%AD%E5%BD%95%2F</url>
    <content type="text"><![CDATA[第一名：你缺啥？第二名：你挑衅是吧？！第三名：特遗憾一个！第四名：以后上课女生不许看男生！（他不是男生？？？）第五名：你的饭量和成绩成不成正比？第六名：脏宝宝！（阿煤专用）第七名：转笔的同学把你的脑筋多转一转啊！第八名：考那么点分，回家数数碗里的米粒，你对得起吗？第九名：我觉得我像马戏团的驯兽师！第十名: 把你爸叫来!第十一名: 回家和你爸做游戏去!第十二名: 对得起饭不?!第十三名：你是小丑吗？（万ZY专用）第十四名：饭桶一个！！第十五名: 以后买袜子就买一只！（万ZY专用）第十六名：家里吃饱了，到学校消化来了吗？？第十七名：我看你不是傻子，胜似傻子。第十八名：你一天老轰轰哈哈啥呢？！把海鲜吃上你还嗷嗷呢吗？？（阿煤专用）第十九名：再别说了，把嘴扯破了！！！(涛）第二十名：再别转笔了，绑个皮筋，最简单的物理疗法！！（×子专用）第二十一名：回家给你的脑子内存整理一下去！（祥）第二十二名：别动窗户了，再动就从窗户出去！！！第二十三名：家里把你当宠物养着呢吗！？第二十四名：这个题有问题！！！第二十五名：唉！有点乱！！！第二十六名：做一次，还是天天做！？第二十七名：你！ 做上了没有？？第二十八名：你！ 为啥不学习！ 智商就这么弱呗！！！第二十九名：你！ 钱包大的很那！（涛）第三十名：你是不是吃撑着呢！！第三十一名：在上面站着表演呢吗！第三十二名：再不要捋胡子了！第三十三名：我看你不正常！！！第三十四名：再别摇头了，摇头啥意思？？ 忏悔着呢吗？第三十五名：别回头，再回头就别转过来！！第三十六名：满脑子的垃圾，回家倒一倒！！！（万ZY专用）第三十七名：你日常用语咋那么多的！！第三十八名：你咋这么粗呢？！第三十九名：计算题就写个“已知”，“已知”的“知”还写错了、、第四十名：吓死了？死了才好！！~~第四十一名：脸有多厚？？第四十二名：赶紧多吃点臭豆腐，把智商提高点！！！第四十三名：回家把智商测测，看能不能达到百分之零！！！！第四十四名：都做一做，这题比游戏简单！！！第四十五名：你爸是干嘛的！！你爸啥都会吗！？第四十六名：哎（矮）呀！看不懂，这题我也分析不来！！第四十七名：都这么大了还吃手，你说年过完怎么也该长一岁了吧，怎么还吃手啥？第四十八名：自己做又不做，一起学又不学，，你有障碍啊！？第四十九名：叫他领你上高中，上不去高中向他索赔！第五十名：你一天尽笑啥着呢？咋这么乐观？！第五十一名：忘了？ 那么深刻的教训能忘了？！第五十二名：你有本事考个第一！来个笑傲江湖！第五十三名：初中三年···除了长肉，还长了些啥？？第五十四名：如有雷同 ~情绪别激动 ~~第五十五名：记住、 劳动最光荣！！！（万ZY专用）第五十六名：扔垃圾的那个把垃圾吃上！ 你野人吗！？？（薛小宝专用）第五十七名：这是个很失败的电路！！第五十八名：你！说个话咋还瞪着我说？！（Bull专用）第五十九名：你！故意的是吧！？故意装饭桶，，还是真的饭桶？？第六十名：去！后面站着去我受不了了（摸了摸啤酒肚）受不了了啊！！！（薛小宝专用）]]></content>
  </entry>
</search>
